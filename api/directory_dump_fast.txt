📄 config.py (1KB)
    Content:
      
      
      # ===== API/CONFIG.PY =====
      import os
      from dotenv import load_dotenv
      
      load_dotenv()
      
      class Config:
          # Flask
          SECRET_KEY = os.getenv('FLASK_SECRET_KEY', 'dev-secret-key')
          
          # Supabase
          SUPABASE_URL = os.getenv('REACT_APP_SUPABASE_URL')
          SUPABASE_KEY = os.getenv('REACT_APP_SUPABASE_ANON_KEY')
          
          # OpenAI
          OPENAI_API_KEY = os.getenv('REACT_APP_OPENAI_API_KEY')
          
          # ElevenLabs
          ELEVENLABS_API_KEY = os.getenv('REACT_APP_ELEVENLABS_API_KEY')
          ELEVENLABS_VOICE_ID = os.getenv('REACT_APP_ELEVENLABS_VOICE_ID')
          
          # Resend
          RESEND_API_KEY = os.getenv('REACT_APP_RESEND_API_KEY')
          
          # App settings
          APP_URL = os.getenv('REACT_APP_APP_URL', 'http://localhost:3001')
          ADMIN_EMAIL = os.getenv('REACT_APP_ADMIN_EMAIL', 'admin@example.com')
          print(ADMIN_EMAIL)
          # Usage limits
          TRIAL_HOURS_LIMIT = 3
          BASIC_MONTHLY_HOURS = 50
          PRO_MONTHLY_HOURS = 50
          
          # Unlock duration (hours)
          BASIC_UNLOCK_DURATION = 24

📄 create_favicon.py (1.8KB)
    Content:
      # ===== CREATE_FAVICON.PY =====
      # Run this script to create a simple favicon.ico file
      
      import os
      from pathlib import Path
      
      def create_simple_favicon():
          """Create a simple 16x16 favicon with 'CC' text"""
          try:
              from PIL import Image, ImageDraw, ImageFont
              
              # Create a 16x16 image with a blue background
              img = Image.new('RGBA', (16, 16), color=(0, 123, 255, 255))
              draw = ImageDraw.Draw(img)
              
              # Try to draw "CC" text (for Cold Calling)
              try:
                  # Use a simple font
                  font = ImageFont.load_default()
                  # Draw white "CC" text
                  draw.text((2, 2), "CC", fill='white', font=font)
              except:
                  # If font loading fails, draw a simple circle
                  draw.ellipse([4, 4, 12, 12], fill='white')
              
              # Save as favicon.ico
              static_dir = Path('static')
              static_dir.mkdir(exist_ok=True)
              
              img.save(static_dir / 'favicon.ico', format='ICO')
              print("âœ… Created simple favicon.ico in static/ directory")
              
          except ImportError:
              print("âš ï¸  PIL/Pillow not installed. Creating empty favicon.ico file instead.")
              # Create an empty ICO file
              static_dir = Path('static')
              static_dir.mkdir(exist_ok=True)
              
              # Minimal ICO file header (basically empty but valid)
              ico_data = b'\x00\x00\x01\x00\x01\x00\x10\x10\x00\x00\x01\x00\x20\x00\x68\x04\x00\x00\x16\x00\x00\x00'
              ico_data += b'\x00' * (0x468 - len(ico_data))  # Pad to correct size
              
              with open(static_dir / 'favicon.ico', 'wb') as f:
                  f.write(ico_data)
              print("âœ… Created minimal favicon.ico in static/ directory")
      
      if __name__ == '__main__':
          create_simple_favicon()

📄 CREATE_PLACEHOLDER_IMAGES.PY (4.7KB)
    Content:
      # ===== CREATE_PLACEHOLDER_IMAGES.PY =====
      """
      Simple script to create placeholder avatar images for the roleplay system.
      Run this from the project root directory.
      """
      
      import os
      from pathlib import Path
      
      def create_placeholder_images():
          """Create placeholder avatar images to prevent 404 errors"""
          
          # Create the directory if it doesn't exist
          avatar_dir = Path("static/images/prospect-avatars")
          avatar_dir.mkdir(parents=True, exist_ok=True)
          
          # List of images we need
          images_needed = [
              'default.jpg',
              'technology.jpg', 
              'tech.jpg',
              'finance.jpg',
              'healthcare.jpg',
              'manufacturing.jpg',
              'education.jpg',
              'executive.jpg',
              'technical.jpg',
              'manager.jpg'
          ]
          
          # Create simple SVG placeholders
          for image_name in images_needed:
              image_path = avatar_dir / image_name
              
              if not image_path.exists():
                  # Get industry/type from filename
                  industry = image_name.replace('.jpg', '').replace('_', ' ').title()
                  if industry == 'Default':
                      industry = 'Person'
                  elif industry == 'Tech':
                      industry = 'Technology'
                  
                  # Create SVG content
                  svg_content = f'''<?xml version="1.0" encoding="UTF-8"?>
      <svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="grad" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
          </linearGradient>
        </defs>
        
        <!-- Background circle -->
        <circle cx="100" cy="100" r="100" fill="url(#grad)" />
        
        <!-- Person icon -->
        <circle cx="100" cy="75" r="25" fill="white" opacity="0.9" />
        <path d="M 60 150 Q 100 120 140 150 L 140 200 L 60 200 Z" fill="white" opacity="0.9" />
        
        <!-- Industry label -->
        <text x="100" y="190" text-anchor="middle" fill="white" font-family="Arial, sans-serif" font-size="12" font-weight="bold" opacity="0.8">
          {industry}
        </text>
      </svg>'''
                  
                  # Write SVG file (we'll use .svg extension but serve as needed)
                  svg_path = avatar_dir / f"{image_name.replace('.jpg', '.svg')}"
                  with open(svg_path, 'w') as f:
                      f.write(svg_content)
                  
                  print(f"Created placeholder: {svg_path}")
          
          # Also create a simple HTML file to view all avatars
          html_content = '''<!DOCTYPE html>
      <html>
      <head>
          <title>Avatar Previews</title>
          <style>
              body { font-family: Arial, sans-serif; padding: 20px; }
              .avatar { display: inline-block; margin: 10px; text-align: center; }
              .avatar img { width: 100px; height: 100px; border-radius: 50%; }
              .avatar p { margin: 5px 0; }
          </style>
      </head>
      <body>
          <h1>Prospect Avatars</h1>
          <div>'''
          
          for image_name in images_needed:
              svg_name = image_name.replace('.jpg', '.svg')
              industry = image_name.replace('.jpg', '').replace('_', ' ').title()
              html_content += f'''
              <div class="avatar">
                  <img src="{svg_name}" alt="{industry}">
                  <p>{industry}</p>
              </div>'''
          
          html_content += '''
          </div>
      </body>
      </html>'''
          
          # Write preview HTML
          with open(avatar_dir / 'preview.html', 'w') as f:
              f.write(html_content)
          
          print(f"\nCreated {len(images_needed)} placeholder avatars in {avatar_dir}")
          print(f"View them at: {avatar_dir / 'preview.html'}")
          
          # Create a simple Python script to serve the SVGs as JPEGs
          serve_script = '''# Simple script to serve SVG avatars as images
      from flask import Flask, send_file, abort
      import os
      from pathlib import Path
      
      app = Flask(__name__)
      AVATAR_DIR = Path("static/images/prospect-avatars")
      
      @app.route('/static/images/prospect-avatars/<filename>')
      def serve_avatar(filename):
          """Serve SVG files as images"""
          # Try to find the corresponding SVG file
          svg_filename = filename.replace('.jpg', '.svg').replace('.png', '.svg')
          svg_path = AVATAR_DIR / svg_filename
          
          if svg_path.exists():
              return send_file(svg_path, mimetype='image/svg+xml')
          
          # Fallback to a default SVG
          default_path = AVATAR_DIR / 'default.svg'
          if default_path.exists():
              return send_file(default_path, mimetype='image/svg+xml')
          
          abort(404)
      
      if __name__ == '__main__':
          print("This would serve avatars. Integrate into your main Flask app instead.")
      '''
          
          with open(avatar_dir / 'serve_avatars.py', 'w') as f:
              f.write(serve_script)
          
          return avatar_dir
      
      if __name__ == "__main__":
          create_placeholder_images()

📄 debug_openai.py (6.1KB)
    Content:
      # ===== UPDATED DEBUG SCRIPT - TEST OPENAI CONNECTION (v1.0+ Compatible) =====
      # Save this as api/debug_openai.py and run it to test your setup
      
      import os
      import logging
      from dotenv import load_dotenv
      from openai import OpenAI
      
      # Load environment variables
      load_dotenv()
      
      # Set up logging
      logging.basicConfig(level=logging.INFO)
      logger = logging.getLogger(__name__)
      
      def test_openai_connection():
          """Test OpenAI API connection and configuration"""
          print("ðŸ” Testing OpenAI Connection...")
          print("=" * 50)
          
          # Check API key
          api_key = os.getenv('REACT_APP_OPENAI_API_KEY')
          print(f"1. API Key: {'âœ… Found' if api_key else 'âŒ Missing'}")
          
          if not api_key:
              print("\nâŒ ERROR: REACT_APP_OPENAI_API_KEY not found in environment")
              print("Please add it to your .env file:")
              print("REACT_APP_OPENAI_API_KEY=sk-proj-your-key-here")
              return False
          
          # Mask the key for security
          masked_key = api_key[:12] + "..." + api_key[-4:] if len(api_key) > 16 else "***"
          print(f"   Key: {masked_key}")
          
          # Set up OpenAI client (NEW v1.0+ syntax)
          client = OpenAI(api_key=api_key)
          
          # Test connection
          try:
              print("\n2. Testing API Connection...")
              response = client.chat.completions.create(
                  model="gpt-4o-mini",
                  messages=[
                      {"role": "system", "content": "You are a helpful assistant."},
                      {"role": "user", "content": "Say 'Connection successful'"}
                  ],
                  max_tokens=10,
                  temperature=0
              )
              
              result = response.choices[0].message.content
              print(f"   Response: {result}")
              print("   âœ… OpenAI API connection successful!")
              
              # Test roleplay scenario
              print("\n3. Testing Roleplay Scenario...")
              roleplay_response = client.chat.completions.create(
                  model="gpt-4o-mini",
                  messages=[
                      {
                          "role": "system", 
                          "content": """You are a Manager at a Technology company receiving a cold call.
                          
      CRITICAL INSTRUCTIONS:
      - Respond naturally and realistically 
      - Keep responses short (1-2 sentences)
      - Show realistic prospect behavior - skeptical but professional
      - Stay in character as a busy business professional
      
      The caller just said: 'Hi, I know this is out of the blue, but may I tell you why I'm calling?'
      
      Respond naturally as the prospect:"""
                      },
                      {"role": "user", "content": "Respond to this cold call opener."}
                  ],
                  max_tokens=50,
                  temperature=0.8
              )
              
              roleplay_result = roleplay_response.choices[0].message.content
              print(f"   Roleplay Response: {roleplay_result}")
              print("   âœ… Roleplay prompt working!")
              
              return True
              
          except Exception as e:
              error_type = type(e).__name__
              print(f"   âŒ {error_type}: {e}")
              
              # Provide specific guidance based on error type
              if "authentication" in str(e).lower():
                  print("   Check your API key is correct and active")
              elif "rate_limit" in str(e).lower():
                  print("   Your API key is valid but you've hit the rate limit")
              elif "billing" in str(e).lower():
                  print("   Check that your OpenAI account has billing set up")
              else:
                  print("   Check your API key and OpenAI account status")
              
              return False
      
      def test_environment():
          """Test environment configuration"""
          print("\nðŸ”§ Testing Environment Configuration...")
          print("=" * 50)
          
          # Check for .env file
          env_file_exists = os.path.exists('.env')
          print(f"1. .env file: {'âœ… Found' if env_file_exists else 'âŒ Missing'}")
          
          if not env_file_exists:
              print("   Create a .env file with your API keys")
          
          # Check all required environment variables
          required_vars = [
              'REACT_APP_OPENAI_API_KEY',
              'REACT_APP_ELEVENLABS_API_KEY',
              'REACT_APP_SUPABASE_URL',
              'REACT_APP_SUPABASE_ANON_KEY'
          ]
          
          print("\n2. Environment Variables:")
          for var in required_vars:
              value = os.getenv(var)
              status = 'âœ… Set' if value else 'âŒ Missing'
              print(f"   {var}: {status}")
      
      def main():
          """Main debug function"""
          print("ðŸš€ Cold Calling Coach - OpenAI Debug Script (v1.0+ Compatible)")
          print("=" * 60)
          
          # Test environment
          test_environment()
          
          # Test OpenAI connection
          success = test_openai_connection()
          
          print("\n" + "=" * 60)
          if success:
              print("ðŸŽ‰ All tests passed! Your OpenAI setup is working correctly.")
              print("\nNext steps:")
              print("1. Update your openai_service.py to use the new v1.0+ API")
              print("2. Replace your roleplay_engine.py with the updated version")
              print("3. Test the roleplay system")
          else:
              print("âŒ Setup issues found. Please fix the errors above.")
              print("\nCommon solutions:")
              print("1. Check your .env file has the correct API key")
              print("2. Verify your OpenAI account has billing set up")
              print("3. Make sure the API key starts with 'sk-proj-' or 'sk-'")
              print("4. If you see 'authentication' errors, double-check your API key")
      
      if __name__ == "__main__":
          main()
      
      # ===== QUICK TEST COMMANDS =====
      """
      To run this debug script:
      
      1. Save this file as api/debug_openai.py (replace the old one)
      2. Run: python api/debug_openai.py
      3. Check the output for any errors
      
      Key changes for OpenAI v1.0+:
      - Use: client = OpenAI(api_key=api_key)
      - Use: client.chat.completions.create() instead of openai.ChatCompletion.create()
      - Error handling is now based on standard Python exceptions
      
      If you still see errors:
      - "API Key Missing": Add REACT_APP_OPENAI_API_KEY to .env file
      - "Authentication Error": Check your API key is correct
      - "Rate Limit Error": Wait a few minutes or check billing
      - "Invalid Request Error": Check the model name is correct
      """

📄 debu_roleplay.py (13KB)
    Content:
      # ===== DEBUG_ROLEPLAY_11.PY - Test OpenAI and Services =====
      
      import os
      import sys
      import logging
      from datetime import datetime
      
      # Add the current directory to Python path
      sys.path.append(os.path.dirname(os.path.abspath(__file__)))
      
      # Set up logging
      logging.basicConfig(
          level=logging.INFO,
          format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
      )
      logger = logging.getLogger(__name__)
      
      def test_environment():
          """Test environment variables"""
          print("=== ENVIRONMENT TEST ===")
          
          # Check OpenAI API key
          openai_key = os.getenv('REACT_APP_OPENAI_API_KEY')
          if openai_key:
              print(f"âœ… OpenAI API Key: {openai_key[:8]}...{openai_key[-4:]}")
          else:
              print("âŒ OpenAI API Key: NOT FOUND")
              print("   Please set REACT_APP_OPENAI_API_KEY in your .env file")
          
          # Check ElevenLabs API key
          elevenlabs_key = os.getenv('REACT_APP_ELEVENLABS_API_KEY')
          if elevenlabs_key:
              print(f"âœ… ElevenLabs API Key: {elevenlabs_key[:8]}...{elevenlabs_key[-4:]}")
          else:
              print("âŒ ElevenLabs API Key: NOT FOUND")
          
          # Check Supabase URL
          supabase_url = os.getenv('REACT_APP_SUPABASE_URL')
          if supabase_url:
              print(f"âœ… Supabase URL: {supabase_url}")
          else:
              print("âŒ Supabase URL: NOT FOUND")
          
          # Check Supabase Key
          supabase_key = os.getenv('REACT_APP_SUPABASE_ANON_KEY')
          if supabase_key:
              print(f"âœ… Supabase Key: {supabase_key[:8]}...{supabase_key[-4:]}")
          else:
              print("âŒ Supabase Key: NOT FOUND")
          
          print()
      
      def test_openai_direct():
          """Test OpenAI API directly"""
          print("=== OPENAI DIRECT TEST ===")
          
          try:
              from openai import OpenAI
              
              api_key = os.getenv('REACT_APP_OPENAI_API_KEY')
              if not api_key:
                  print("âŒ No OpenAI API key found")
                  return False
              
              client = OpenAI(api_key=api_key)
              
              # Test simple completion
              print("Testing simple completion...")
              response = client.chat.completions.create(
                  model="gpt-4o-mini",
                  messages=[
                      {"role": "user", "content": "Say 'Hello from OpenAI!' and nothing else."}
                  ],
                  max_tokens=10,
                  timeout=10
              )
              
              result = response.choices[0].message.content.strip()
              print(f"âœ… OpenAI Response: {result}")
              
              return True
              
          except Exception as e:
              print(f"âŒ OpenAI Direct Test Failed: {e}")
              return False
      
      def test_openai_service():
          """Test our OpenAI service"""
          print("=== OPENAI SERVICE TEST ===")
          
          try:
              from services.openai_service import OpenAIService
              
              service = OpenAIService()
              print(f"âœ… OpenAI Service Initialized")
              print(f"   Available: {service.is_available()}")
              print(f"   Model: {service.model}")
              
              # Get status
              status = service.get_status()
              print(f"   Status: {status}")
              
              if service.is_available():
                  # Test roleplay flow
                  print("Testing roleplay flow...")
                  test_result = service.test_roleplay_flow()
                  print(f"   Flow Test: {test_result}")
              
              return True
              
          except Exception as e:
              print(f"âŒ OpenAI Service Test Failed: {e}")
              return False
      
      def test_roleplay_engine():
          """Test roleplay engine"""
          print("=== ROLEPLAY ENGINE TEST ===")
          
          try:
              from services.roleplay_engine import RoleplayEngine
              
              engine = RoleplayEngine()
              print(f"âœ… Roleplay Engine Initialized")
              
              # Get status
              status = engine.get_service_status()
              print(f"   Status: {status}")
              
              # Test session creation
              print("Testing session creation...")
              user_context = {
                  'first_name': 'Test',
                  'prospect_job_title': 'CTO',
                  'prospect_industry': 'Technology'
              }
              
              session_result = engine.create_session(
                  user_id='test_user',
                  roleplay_id=1,
                  mode='practice',
                  user_context=user_context
              )
              
              if session_result.get('success'):
                  session_id = session_result['session_id']
                  print(f"âœ… Session Created: {session_id}")
                  print(f"   Initial Response: {session_result.get('initial_response')}")
                  
                  # Test user input processing
                  print("Testing user input processing...")
                  response_result = engine.process_user_input(
                      session_id,
                      "Hi, I know this is out of the blue, but can I tell you why I'm calling?"
                  )
                  
                  if response_result.get('success'):
                      print(f"âœ… Input Processed Successfully")
                      print(f"   AI Response: {response_result.get('ai_response')}")
                      print(f"   Evaluation: {response_result.get('evaluation')}")
                      print(f"   Call Continues: {response_result.get('call_continues')}")
                  else:
                      print(f"âŒ Input Processing Failed: {response_result.get('error')}")
                  
                  # Test session ending
                  print("Testing session ending...")
                  end_result = engine.end_session(session_id)
                  
                  if end_result.get('success'):
                      print(f"âœ… Session Ended Successfully")
                      print(f"   Score: {end_result.get('overall_score')}")
                      print(f"   Coaching: {end_result.get('coaching')}")
                  else:
                      print(f"âŒ Session Ending Failed: {end_result.get('error')}")
              
              else:
                  print(f"âŒ Session Creation Failed: {session_result.get('error')}")
              
              return True
              
          except Exception as e:
              print(f"âŒ Roleplay Engine Test Failed: {e}")
              return False
      
      def test_elevenlabs_service():
          """Test ElevenLabs service"""
          print("=== ELEVENLABS SERVICE TEST ===")
          
          try:
              from services.elevenlabs_service import ElevenLabsService
              
              service = ElevenLabsService()
              print(f"âœ… ElevenLabs Service Initialized")
              print(f"   Available: {service.is_available()}")
              
              if hasattr(service, 'get_status'):
                  status = service.get_status()
                  print(f"   Status: {status}")
              
              if service.is_available():
                  # Test TTS
                  print("Testing TTS generation...")
                  try:
                      audio_stream = service.text_to_speech("Hello, this is a test.")
                      if audio_stream:
                          audio_data = audio_stream.getvalue()
                          print(f"âœ… TTS Generated: {len(audio_data)} bytes")
                      else:
                          print("âŒ TTS returned None")
                  except Exception as e:
                      print(f"âŒ TTS Generation Failed: {e}")
              
              return True
              
          except Exception as e:
              print(f"âŒ ElevenLabs Service Test Failed: {e}")
              return False
      
      def test_full_conversation():
          """Test a full conversation flow"""
          print("=== FULL CONVERSATION TEST ===")
          
          try:
              from services.roleplay_engine import RoleplayEngine
              
              engine = RoleplayEngine()
              
              # Create session
              user_context = {
                  'first_name': 'Test',
                  'prospect_job_title': 'CTO',
                  'prospect_industry': 'Technology'
              }
              
              session_result = engine.create_session(
                  user_id='test_user_full',
                  roleplay_id=1,
                  mode='practice',
                  user_context=user_context
              )
              
              if not session_result.get('success'):
                  print(f"âŒ Session creation failed: {session_result.get('error')}")
                  return False
              
              session_id = session_result['session_id']
              print(f"âœ… Session Created: {session_id}")
              print(f"Prospect: {session_result.get('initial_response')}")
              
              # Simulate a conversation
              conversation_steps = [
                  "Hi, I know this is out of the blue, but can I tell you why I'm calling?",
                  "Fair enough. I work with CTOs like yourself who are struggling with data silos. Can I ask you a quick question?",
                  "We help companies like yours connect their data sources in minutes instead of months. How are you currently handling data integration?",
                  "That's exactly what I thought. Would you be open to a 15-minute call next Tuesday at 2 PM to see how this could help?"
              ]
              
              for i, user_input in enumerate(conversation_steps, 1):
                  print(f"\n--- Step {i} ---")
                  print(f"SDR: {user_input}")
                  
                  response_result = engine.process_user_input(session_id, user_input)
                  
                  if response_result.get('success'):
                      print(f"Prospect: {response_result.get('ai_response')}")
                      print(f"Evaluation: Score={response_result.get('evaluation', {}).get('score', 'N/A')}, "
                            f"Passed={response_result.get('evaluation', {}).get('passed', 'N/A')}")
                      
                      if not response_result.get('call_continues'):
                          print("Call ended by prospect.")
                          break
                  else:
                      print(f"âŒ Error: {response_result.get('error')}")
                      break
              
              # End session
              end_result = engine.end_session(session_id)
              if end_result.get('success'):
                  print(f"\nâœ… Conversation Complete!")
                  print(f"Final Score: {end_result.get('overall_score')}/100")
                  print(f"Session Success: {end_result.get('session_success')}")
                  print(f"Duration: {end_result.get('duration_minutes')} minutes")
                  
                  coaching = end_result.get('coaching', {})
                  if coaching:
                      print(f"\nCoaching Feedback:")
                      for category, feedback in coaching.items():
                          print(f"  {category}: {feedback}")
              
              return True
              
          except Exception as e:
              print(f"âŒ Full Conversation Test Failed: {e}")
              return False
      
      def main():
          """Run all tests"""
          print("ðŸš€ ROLEPLAY 1.1 SYSTEM TEST")
          print("=" * 50)
          print(f"Timestamp: {datetime.now()}")
          print()
          
          # Load environment
          try:
              from dotenv import load_dotenv
              load_dotenv()
              print("âœ… Environment loaded")
          except ImportError:
              print("âŒ python-dotenv not installed")
          except Exception as e:
              print(f"âŒ Environment load error: {e}")
          
          print()
          
          # Run tests
          tests = [
              ("Environment", test_environment),
              ("OpenAI Direct", test_openai_direct),
              ("OpenAI Service", test_openai_service),
              ("Roleplay Engine", test_roleplay_engine),
              ("ElevenLabs Service", test_elevenlabs_service),
              ("Full Conversation", test_full_conversation)
          ]
          
          results = {}
          
          for test_name, test_func in tests:
              try:
                  print(f"\n{'='*20}")
                  result = test_func()
                  results[test_name] = result
              except Exception as e:
                  print(f"âŒ {test_name} test crashed: {e}")
                  results[test_name] = False
          
          # Summary
          print(f"\n{'='*50}")
          print("ðŸ TEST SUMMARY")
          print("=" * 50)
          
          passed = 0
          total = len(results)
          
          for test_name, result in results.items():
              status = "âœ… PASS" if result else "âŒ FAIL"
              print(f"{test_name:20} {status}")
              if result:
                  passed += 1
          
          print(f"\nOverall: {passed}/{total} tests passed")
          
          if passed == total:
              print("ðŸŽ‰ All tests passed! Your Roleplay 1.1 system is ready!")
          else:
              print("ðŸ”§ Some tests failed. Check the errors above.")
              
              # Provide guidance
              print("\nðŸ’¡ TROUBLESHOOTING TIPS:")
              
              if not results.get("Environment"):
                  print("- Check your .env file has the correct API keys")
                  print("- Make sure REACT_APP_OPENAI_API_KEY is set correctly")
              
              if not results.get("OpenAI Direct"):
                  print("- Verify your OpenAI API key is valid and has credits")
                  print("- Check your internet connection")
                  print("- Try a different model (gpt-3.5-turbo instead of gpt-4o-mini)")
              
              if not results.get("OpenAI Service"):
                  print("- Check the services/openai_service.py file")
                  print("- Make sure the OpenAI library is installed: pip install openai")
              
              if not results.get("Roleplay Engine"):
                  print("- Check the services/roleplay_engine.py file")
                  print("- Ensure the OpenAI service is working first")
      
      if __name__ == "__main__":
          main()

📄 index.py (24.1KB)
    Content:
      # ===== api/index.py (VERCEL FIXED HANDLER) =====
      from flask import Flask, render_template, redirect, url_for, send_from_directory, make_response, request, session, jsonify
      from flask_cors import CORS
      import os
      import logging
      from datetime import datetime
      
      # Configure logging for Vercel
      logging.basicConfig(
          level=logging.INFO,
          format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
      )
      
      logger = logging.getLogger(__name__)
      
      # Define the roleplay structure
      ROLEPLAY_STRUCTURE = {
          '1': {
              'name': 'Opener + Early Objections',
              'description': 'Master call openings and handle early objections',
              'subtypes': {
                  '1.1': {
                      'name': 'Practice Mode',
                      'description': 'Single call with detailed CEFR A2 coaching',
                      'icon': 'user-graduate'
                  },
                  '1.2': {
                      'name': 'Marathon Mode', 
                      'description': '10 calls, need 6 to pass',
                      'icon': 'running'
                  },
                  '1.3': {
                      'name': 'Legend Mode',
                      'description': '6 perfect calls in a row',
                      'icon': 'crown'
                  }
              }
          },
          '2': {
              'name': 'Pitch + Objections + Close',
              'description': 'Perfect your pitch and close more meetings',
              'subtypes': {
                  '2.1': {
                      'name': 'Practice Mode',
                      'description': 'Single call with detailed coaching',
                      'icon': 'user-graduate'
                  },
                  '2.2': {
                      'name': 'Marathon Mode',
                      'description': '10 calls, need 6 to pass',
                      'icon': 'running'
                  }
              }
          },
          '3': {
              'name': 'Warm-up Challenge',
              'description': '25 rapid-fire questions to sharpen your skills',
              'direct': True,
              'icon': 'fire'
          },
          '4': {
              'name': 'Full Cold Call Simulation', 
              'description': 'Complete end-to-end cold call practice',
              'direct': True,
              'icon': 'headset'
          },
          '5': {
              'name': 'Power Hour Challenge',
              'description': '10 consecutive calls to test your endurance',
              'direct': True,
              'icon': 'bolt'
          }
      }
      
      # Create Flask app instance
      app = Flask(__name__)
      
      # Configuration for Vercel
      app.secret_key = os.getenv('FLASK_SECRET_KEY', 'dev-secret-key-change-in-production')
      
      # CORS configuration
      CORS(app, supports_credentials=True)
      
      # ===== HELPER FUNCTIONS FOR ROLEPLAY ROUTING =====
      
      def get_user_profile_safe(user_id):
          """Safely get user profile with fallback"""
          try:
              from services.supabase_client import SupabaseService
              supabase_service = SupabaseService()
              profile = supabase_service.get_user_profile_by_service(user_id)
              
              if not profile:
                  logger.warning(f"No profile found for user {user_id}")
                  profile = {
                      'first_name': 'User',
                      'prospect_job_title': 'CTO',
                      'prospect_industry': 'Technology'
                  }
              return profile
          except Exception as e:
              logger.error(f"Error getting user profile: {e}")
              return {
                  'first_name': 'User',
                  'prospect_job_title': 'CTO',
                  'prospect_industry': 'Technology'
              }
      
      def get_roleplay_info_from_structure(roleplay_id):
          """Get roleplay info from the structure"""
          # For direct roleplays (3, 4, 5)
          if roleplay_id in ['3', '4', '5']:
              return ROLEPLAY_STRUCTURE.get(roleplay_id)
          
          # For subtypes (1.1, 1.2, etc.)
          main_id = roleplay_id.split('.')[0]
          main_info = ROLEPLAY_STRUCTURE.get(main_id)
          
          if main_info and 'subtypes' in main_info:
              subtype_info = main_info['subtypes'].get(roleplay_id)
              if subtype_info:
                  # Combine main info with subtype info
                  return {
                      'id': roleplay_id,
                      'name': subtype_info['name'],
                      'description': subtype_info['description'],
                      'icon': subtype_info.get('icon', 'phone'),
                      'main_category': main_info['name']
                  }
          
          return None
      
      def render_roleplay_selection(main_roleplay_id, user_id):
          """Render selection page for roleplays with subtypes - FIXED"""
          try:
              # Get user profile
              profile = get_user_profile_safe(user_id)
              
              # Get roleplay info
              roleplay_info = ROLEPLAY_STRUCTURE.get(main_roleplay_id)
              if not roleplay_info:
                  return redirect(url_for('dashboard_page'))
              
              logger.info(f"Rendering selection page for roleplay {main_roleplay_id}")
              
              # FIXED: Handle Roleplay 1 specifically
              if main_roleplay_id == '1':
                  # Get user progress for Roleplay 1 modes
                  try:
                      from services.user_progress_service import UserProgressService
                      progress_service = UserProgressService()
                      user_progress = progress_service.get_user_roleplay_progress(user_id, ['1.1', '1.2', '1.3'])
                  except Exception as e:
                      logger.warning(f"Could not load user progress: {e}")
                      user_progress = {}
                  
                  # Use the specific Roleplay 1 selection template
                  return render_template(
                      'roleplay/roleplay-1-selection.html',  # FIXED: Correct template path
                      user_progress=user_progress,
                      page_title="Roleplay 1: Choose Your Mode"
                  )
              
              # For other roleplays, use generic template (when you create them later)
              else:
                  return render_template(
                      'roleplay/roleplay-1-selection.html',  # Generic template for other roleplays
                      main_roleplay_id=main_roleplay_id,
                      roleplay_info=roleplay_info,
                      user_profile=profile,
                      page_title=f"{roleplay_info['name']} - Choose Mode"
                  )
              
          except Exception as e:
              logger.error(f"Error rendering roleplay selection: {e}")
              return redirect(url_for('dashboard_page'))
      
      
      @app.route('/roleplay/<roleplay_id>')
      def roleplay_page(roleplay_id):
          """Handle hierarchical roleplay routing - COMPLETE FIX"""
          try:
              # Check authentication
              if 'user_id' not in session:
                  logger.warning("Unauthenticated access to roleplay page")
                  return redirect(url_for('login_page'))
              
              user_id = session.get('user_id')
              logger.info(f"ðŸŽ¯ User {user_id} accessing roleplay {roleplay_id}")
              
              # Handle different roleplay ID formats
              if roleplay_id == '1':
                  # Roleplay 1 - show selection page with modes 1.1, 1.2, 1.3
                  logger.info("ðŸ“‹ Showing Roleplay 1 selection page")
                  return render_roleplay_1_selection(user_id)
              
              elif roleplay_id == '2':
                  # Roleplay 2 - show selection page with modes 2.1, 2.2
                  logger.info("ðŸ“‹ Showing Roleplay 2 selection page")
                  return render_roleplay_2_selection(user_id)
              
              elif roleplay_id in ['3', '4', '5']:
                  # Roleplays 3, 4, 5 - go directly to training (no selection)
                  logger.info(f"ðŸŽ® Going directly to roleplay {roleplay_id}")
                  return render_specific_roleplay(roleplay_id, user_id)
              
              elif roleplay_id in ['1.1', '1.2', '1.3']:
                  # Roleplay 1 specific modes - go to training
                  logger.info(f"ðŸŽ® Starting Roleplay 1 mode: {roleplay_id}")
                  return render_specific_roleplay(roleplay_id, user_id)
              
              elif roleplay_id in ['2.1', '2.2']:
                  # Roleplay 2 specific modes - go to training
                  logger.info(f"ðŸŽ® Starting Roleplay 2 mode: {roleplay_id}")
                  return render_specific_roleplay(roleplay_id, user_id)
              
              else:
                  # Invalid roleplay ID
                  logger.warning(f"âŒ Invalid roleplay ID: {roleplay_id}")
                  return redirect(url_for('dashboard_page'))
                  
          except Exception as e:
              logger.error(f"âŒ Error in roleplay_page: {e}")
              return redirect(url_for('dashboard_page'))
      
      def render_roleplay_1_selection(user_id):
          """Render Roleplay 1 selection page - FIXED with all variables"""
          try:
              logger.info(f"ðŸŽ® Rendering Roleplay 1 selection for user {user_id}")
              
              # Get user profile
              profile = get_user_profile_safe(user_id)
              
              # Create roleplay info for Roleplay 1
              roleplay_info = {
                  'id': '1',
                  'name': 'Roleplay 1: Opener & Early Objections',
                  'description': 'Master call openings and handle early objections with confidence'
              }
              
              # Get user progress for Roleplay 1 modes
              try:
                  from services.user_progress_service import UserProgressService
                  progress_service = UserProgressService()
                  user_progress = progress_service.get_user_roleplay_progress(user_id, ['1.1', '1.2', '1.3'])
                  logger.info(f"ðŸ“Š Loaded progress for 1.1, 1.2, 1.3: {user_progress}")
              except Exception as e:
                  logger.warning(f"âš ï¸ Could not load user progress: {e}")
                  user_progress = {}
              
              # Use your custom template for Roleplay 1
              logger.info("ðŸ“„ Rendering roleplay/roleplay-1-selection.html")
              return render_template(
                  'roleplay/roleplay-1-selection.html',
                  roleplay_info=roleplay_info,  # ADDED: Include roleplay_info
                  user_progress=user_progress,
                  user_profile=profile,
                  main_roleplay_id='1',  # ADDED: Include main_roleplay_id
                  page_title="Roleplay 1: Choose Your Mode"
              )
              
          except Exception as e:
              logger.error(f"âŒ Error rendering Roleplay 1 selection: {e}")
              return redirect(url_for('dashboard_page'))
      
      def render_roleplay_2_selection(user_id):
          """Render Roleplay 2 selection page - FIXED with all variables"""
          try:
              logger.info(f"ðŸŽ® Rendering Roleplay 2 selection for user {user_id}")
              
              # Get user profile
              profile = get_user_profile_safe(user_id)
              
              # Get roleplay info for Roleplay 2
              roleplay_info = {
                  'id': '2',
                  'name': 'Roleplay 2: Pitch + Objections + Close',
                  'description': 'Perfect your pitch and close more meetings'
              }
              
              # Get user progress for Roleplay 2 modes  
              try:
                  from services.user_progress_service import UserProgressService
                  progress_service = UserProgressService()
                  user_progress = progress_service.get_user_roleplay_progress(user_id, ['2.1', '2.2'])
                  # Also get Roleplay 1 progress to check unlock status
                  rp1_progress = progress_service.get_user_roleplay_progress(user_id, ['1.3'])
                  user_progress.update(rp1_progress)  # Merge progress data
                  logger.info(f"ðŸ“Š Loaded progress for 2.1, 2.2: {user_progress}")
              except Exception as e:
                  logger.warning(f"âš ï¸ Could not load user progress: {e}")
                  user_progress = {}
              
              # Use the generic template for Roleplay 2
              logger.info("ðŸ“„ Rendering roleplay/roleplay-selection.html for Roleplay 2")
              return render_template(
                  'roleplay/roleplay-selection.html',
                  main_roleplay_id='2',
                  roleplay_info=roleplay_info,
                  user_profile=profile,
                  user_progress=user_progress,
                  page_title="Roleplay 2: Choose Your Mode"
              )
              
          except Exception as e:
              logger.error(f"âŒ Error rendering Roleplay 2 selection: {e}")
              return redirect(url_for('dashboard_page'))
      
      def render_specific_roleplay(roleplay_id, user_id):
          """Render specific roleplay training page - FIXED"""
          try:
              # Get user profile
              profile = get_user_profile_safe(user_id)
              
              # Check roleplay access first
              try:
                  from services.user_progress_service import UserProgressService
                  progress_service = UserProgressService()
                  access_check = progress_service.check_roleplay_access(user_id, roleplay_id)
                  
                  if not access_check['allowed']:
                      logger.warning(f"âŒ User {user_id} doesn't have access to {roleplay_id}: {access_check['reason']}")
                      # Redirect back to selection or dashboard with error message
                      if roleplay_id.startswith('1.'):
                          return redirect(url_for('roleplay_page', roleplay_id='1'))
                      elif roleplay_id.startswith('2.'):
                          return redirect(url_for('roleplay_page', roleplay_id='2'))
                      else:
                          return redirect(url_for('dashboard_page'))
              except Exception as e:
                  logger.warning(f"âš ï¸ Could not check access: {e}")
              
              # Get roleplay info from structure or create default
              roleplay_info = get_roleplay_info_from_structure(roleplay_id)
              
              if not roleplay_info:
                  logger.warning(f"No info found for roleplay {roleplay_id}")
                  # Create default info based on roleplay_id
                  roleplay_names = {
                      '1.1': 'Practice Mode',
                      '1.2': 'Marathon Mode', 
                      '1.3': 'Legend Mode',
                      '2.1': 'Advanced Practice',
                      '2.2': 'Advanced Marathon',
                      '3': 'Warm-up Challenge',
                      '4': 'Full Cold Call Simulation',
                      '5': 'Power Hour Challenge'
                  }
                  
                  roleplay_info = {
                      'id': roleplay_id,
                      'name': roleplay_names.get(roleplay_id, f'Roleplay {roleplay_id}'),
                      'description': 'Cold calling training',
                      'icon': 'phone'
                  }
              
              logger.info(f"ðŸŽ® Rendering training page for {roleplay_id}")
              
              # Use the main roleplay training template
              return render_template(
                  'roleplay.html',
                  roleplay_id=roleplay_id,
                  roleplay_info=roleplay_info,
                  user_profile=profile,
                  page_title=f"{roleplay_info['name']} - Cold Calling Coach"
              )
              
          except Exception as e:
              logger.error(f"âŒ Error rendering specific roleplay: {e}")
              return redirect(url_for('dashboard_page'))
      
      @app.template_global()
      def get_file_version(filename):
          """Get file modification time for cache busting"""
          try:
              file_path = os.path.join(app.static_folder, filename)
              if os.path.exists(file_path):
                  mtime = os.path.getmtime(file_path)
                  return str(int(mtime))
              return str(int(datetime.now().timestamp()))
          except:
              return str(int(datetime.now().timestamp()))
      
      @app.template_global()
      def current_year():
          return datetime.now().year
      
      @app.template_global()
      def get_roleplay_structure():
          """Make roleplay structure available in templates"""
          return ROLEPLAY_STRUCTURE
      
      # ===== MAIN ROUTES =====
      
      @app.route('/')
      def home():
          """Home page"""
          return render_template('index.html')
      
      @app.route('/register')
      def register_page():
          """Registration page"""
          return render_template('register.html')
      
      @app.route('/login')
      def login_page():
          """Login page"""
          return render_template('login.html')
      
      @app.route('/dashboard')
      def dashboard_page():
          """Dashboard page"""
          return render_template('dashboard.html')
      
      @app.route('/api/roleplay/info/<roleplay_id>', methods=['GET'])
      def get_roleplay_info_api(roleplay_id):
          """Get roleplay information - FIXED VERSION"""
          try:
              # CRITICAL FIX: Handle parent categories first
              original_id = roleplay_id
              if roleplay_id == '1':
                  roleplay_id = '1.1'
              elif roleplay_id == '2':
                  roleplay_id = '2.1'
              
              logger.info(f"API request for roleplay info: {original_id} -> {roleplay_id}")
              
              # Simple roleplay info
              roleplay_configs = {
                  '1.1': {
                      'id': '1.1', 
                      'name': 'Practice Mode', 
                      'description': 'Single call with detailed coaching', 
                      'icon': 'user-graduate', 
                      'available': True
                  },
                  '1.2': {
                      'id': '1.2', 
                      'name': 'Marathon Mode', 
                      'description': '10 calls, need 6 to pass', 
                      'icon': 'running', 
                      'available': True
                  },
                  '1.3': {
                      'id': '1.3', 
                      'name': 'Legend Mode', 
                      'description': '6 perfect calls in a row', 
                      'icon': 'crown', 
                      'available': False
                  },
                  '2.1': {
                      'id': '2.1', 
                      'name': 'Pitch Practice', 
                      'description': 'Advanced pitch training', 
                      'icon': 'bullhorn', 
                      'available': False
                  },
                  '2.2': {
                      'id': '2.2', 
                      'name': 'Pitch Marathon', 
                      'description': '10 advanced calls', 
                      'icon': 'running', 
                      'available': False
                  },
                  '3': {
                      'id': '3', 
                      'name': 'Warm-up Challenge', 
                      'description': '25 rapid-fire questions', 
                      'icon': 'fire', 
                      'available': True
                  },
                  '4': {
                      'id': '4', 
                      'name': 'Full Cold Call', 
                      'description': 'Complete simulation', 
                      'icon': 'headset', 
                      'available': True
                  },
                  '5': {
                      'id': '5', 
                      'name': 'Power Hour', 
                      'description': '10 consecutive calls', 
                      'icon': 'bolt', 
                      'available': True
                  }
              }
              
              if roleplay_id not in roleplay_configs:
                  logger.warning(f"Invalid roleplay ID: {roleplay_id}")
                  return jsonify({'error': f'Invalid roleplay ID: {roleplay_id}'}), 404
              
              result = roleplay_configs[roleplay_id]
              logger.info(f"Returning roleplay info for {original_id}: {result['name']}")
              return jsonify(result)
              
          except Exception as e:
              logger.error(f"Error getting roleplay info: {e}")
              return jsonify({'error': 'Internal server error'}), 500
      
      @app.route('/api/test/simple-start', methods=['POST'])
      def test_simple_start():

📄 migrate_existing_data.py (6.5KB)
    Content:
      # ===== migrate_existing_data.py =====
      # Script to migrate existing voice_sessions to new roleplay_completions table
      
      from services.supabase_client import SupabaseService
      from datetime import datetime, timezone
      import uuid
      
      def migrate_voice_sessions_to_completions():
          """Migrate existing voice_sessions to new roleplay_completions table"""
          
          supabase_service = SupabaseService()
          client = supabase_service.get_service_client()
          
          print("ðŸ”„ Starting migration of voice_sessions to roleplay_completions...")
          
          try:
              # Get all existing voice sessions
              sessions_result = client.table('voice_sessions').select('*').execute()
              
              if not sessions_result.data:
                  print("ðŸ“­ No voice sessions found to migrate")
                  return
              
              migrated_count = 0
              
              for session in sessions_result.data:
                  try:
                      # Create completion record from voice session
                      completion_data = {
                          'user_id': session['user_id'],
                          'roleplay_id': str(session['roleplay_id']),  # Convert to string
                          'session_id': session.get('id', str(uuid.uuid4())),
                          'mode': 'practice',  # Default mode for migrated sessions
                          'score': session.get('score', 0),
                          'success': session.get('score', 0) >= 70,  # Consider 70+ as success
                          'duration_minutes': session.get('duration_minutes', 0),
                          'started_at': session.get('created_at', datetime.now(timezone.utc).isoformat()),
                          'completed_at': session.get('ended_at', session.get('created_at', datetime.now(timezone.utc).isoformat())),
                          'conversation_data': session.get('conversation_data', {}),
                          'coaching_feedback': session.get('coaching_feedback', {}),
                          'ai_evaluation': session.get('ai_evaluation'),
                          'rubric_scores': session.get('rubric_scores', {}),
                          'forced_end': session.get('forced_end', False),
                          'migrated_from_voice_session': True  # Mark as migrated
                      }
                      
                      # Insert into roleplay_completions
                      result = client.table('roleplay_completions').insert(completion_data).execute()
                      
                      if result.data:
                          migrated_count += 1
                          print(f"âœ… Migrated session {session.get('id', 'unknown')} for user {session['user_id']}")
                      else:
                          print(f"âŒ Failed to migrate session {session.get('id', 'unknown')}")
                          
                  except Exception as e:
                      print(f"âŒ Error migrating session {session.get('id', 'unknown')}: {e}")
                      continue
              
              print(f"\nðŸŽ‰ Migration completed: {migrated_count}/{len(sessions_result.data)} sessions migrated")
              
              # Update user stats based on migrated data
              print("\nðŸ”„ Updating user stats...")
              update_user_stats_from_completions()
              
          except Exception as e:
              print(f"âŒ Migration failed: {e}")
      
      def update_user_stats_from_completions():
          """Update user_roleplay_stats table based on roleplay_completions"""
          
          supabase_service = SupabaseService()
          client = supabase_service.get_service_client()
          
          try:
              # Get all unique user-roleplay combinations
              completions = client.table('roleplay_completions').select(
                  'user_id, roleplay_id, score, completed_at'
              ).execute()
              
              # Group by user and roleplay
              user_stats = {}
              
              for completion in completions.data:
                  user_id = completion['user_id']
                  roleplay_id = completion['roleplay_id']
                  key = f"{user_id}_{roleplay_id}"
                  
                  if key not in user_stats:
                      user_stats[key] = {
                          'user_id': user_id,
                          'roleplay_id': roleplay_id,
                          'total_attempts': 0,
                          'best_score': 0,
                          'scores': [],
                          'completed_dates': []
                      }
                  
                  user_stats[key]['total_attempts'] += 1
                  user_stats[key]['scores'].append(completion['score'])
                  user_stats[key]['completed_dates'].append(completion['completed_at'])
                  
                  if completion['score'] > user_stats[key]['best_score']:
                      user_stats[key]['best_score'] = completion['score']
              
              # Insert/update user_roleplay_stats
              for stats in user_stats.values():
                  # Check if record exists
                  existing = client.table('user_roleplay_stats').select('*').eq(
                      'user_id', stats['user_id']
                  ).eq('roleplay_id', stats['roleplay_id']).execute()
                  
                  stats_data = {
                      'user_id': stats['user_id'],
                      'roleplay_id': stats['roleplay_id'],
                      'total_attempts': stats['total_attempts'],
                      'best_score': stats['best_score'],
                      'last_score': stats['scores'][-1],
                      'completed': stats['best_score'] >= 70,
                      'last_attempt_at': max(stats['completed_dates']),
                      'best_score_at': stats['completed_dates'][stats['scores'].index(stats['best_score'])],
                      'completed_at': max(stats['completed_dates']) if stats['best_score'] >= 70 else None
                  }
                  
                  if existing.data:
                      # Update existing
                      client.table('user_roleplay_stats').update(stats_data).eq(
                          'user_id', stats['user_id']
                      ).eq('roleplay_id', stats['roleplay_id']).execute()
                  else:
                      # Insert new
                      client.table('user_roleplay_stats').insert(stats_data).execute()
              
              print(f"âœ… Updated stats for {len(user_stats)} user-roleplay combinations")
              
          except Exception as e:
              print(f"âŒ Error updating user stats: {e}")
      
      if __name__ == "__main__":
          print("ðŸš€ Voice Session Migration Script")
          print("=" * 40)
          
          # Confirm before running
          confirm = input("This will migrate existing voice_sessions to the new system. Continue? (y/n): ")
          
          if confirm.lower() == 'y':
              migrate_voice_sessions_to_completions()
          else:
              print("Migration cancelled")

📄 test_database_setup.py (9KB)
    Content:
      # ===== FIXED: test_database_setup.py - UUID Compatible =====
      
      import os
      import uuid
      from services.supabase_client import SupabaseService
      from services.user_progress_service import UserProgressService
      
      def test_database_setup():
          """Test that the new database tables and service are working"""
          
          print("ðŸ§ª Testing Database Setup...")
          
          try:
              # Initialize services
              supabase_service = SupabaseService()
              progress_service = UserProgressService()
              
              print("âœ… Services initialized successfully")
              
              # Test 1: Check if new tables exist
              print("\nðŸ“‹ Test 1: Checking if new tables exist...")
              
              tables_to_check = [
                  'roleplay_completions',
                  'user_roleplay_stats', 
                  'roleplay_attempts',
                  'user_achievements',
                  'roleplay_configs'
              ]
              
              for table in tables_to_check:
                  try:
                      result = supabase_service.get_service_client().table(table).select('id').limit(1).execute()
                      print(f"âœ… Table '{table}' exists and is accessible")
                  except Exception as e:
                      print(f"âŒ Table '{table}' error: {e}")
                      return False
              
              # Test 2: Check roleplay configs were inserted
              print("\nâš™ï¸ Test 2: Checking roleplay configurations...")
              
              configs = supabase_service.get_service_client().table('roleplay_configs').select('roleplay_id, name').execute()
              
              if configs.data:
                  print(f"âœ… Found {len(configs.data)} roleplay configurations:")
                  for config in configs.data:
                      print(f"   - {config['roleplay_id']}: {config['name']}")
              else:
                  print("âŒ No roleplay configurations found")
                  return False
              
              # Test 3: Test progress service methods with VALID UUID
              print("\nðŸ”§ Test 3: Testing progress service methods...")
              
              # Use a properly formatted UUID for testing
              test_user_id = str(uuid.uuid4())  # Generate valid UUID
              print(f"   Using test UUID: {test_user_id}")
              
              try:
                  # Test getting progress (should return empty for new user)
                  progress = progress_service.get_user_roleplay_progress(test_user_id)
                  print(f"âœ… get_user_roleplay_progress works: {type(progress)} (empty as expected)")
                  
                  # Test checking access
                  access = progress_service.check_roleplay_access(test_user_id, '1.1')
                  print(f"âœ… check_roleplay_access works: {access.get('allowed', 'Unknown')}")
                  
                  # Test getting available roleplays
                  available = progress_service.get_available_roleplays(test_user_id)
                  print(f"âœ… get_available_roleplays works: {available}")
                  
                  # Test getting completion stats
                  stats = progress_service.get_completion_stats(test_user_id)
                  print(f"âœ… get_completion_stats works: {type(stats)}")
                  
              except Exception as e:
                  print(f"âŒ Progress service error: {e}")
                  return False
              
              # Test 4: Test with real user (if you have existing users)
              print("\nðŸ‘¤ Test 4: Testing with existing users...")
              
              try:
                  # Get first user from user_profiles
                  users = supabase_service.get_service_client().table('user_profiles').select('id, first_name').limit(1).execute()
                  
                  if users.data:
                      real_user_id = users.data[0]['id']
                      user_name = users.data[0]['first_name']
                      
                      print(f"âœ… Found user: {user_name} ({real_user_id})")
                      
                      # Test with real user
                      real_progress = progress_service.get_user_roleplay_progress(real_user_id)
                      real_recommendations = progress_service.get_next_recommendations(real_user_id)
                      
                      print(f"âœ… Real user progress: {len(real_progress)} roleplay(s)")
                      print(f"âœ… Real user recommendations: {len(real_recommendations)} recommendation(s)")
                      
                      if real_recommendations:
                          print(f"   First recommendation: {real_recommendations[0].get('message', 'N/A')}")
                      
                  else:
                      print("âš ï¸ No existing users found in user_profiles table")
              
              except Exception as e:
                  print(f"âŒ Real user test error: {e}")
                  # This is not critical, continue
              
              # Test 5: Test data insertion capability (simulation)
              print("\nðŸ’¾ Test 5: Testing data insertion capability...")
              
              try:
                  # Generate unique session ID
                  test_session_id = f"test-session-{uuid.uuid4()}"
                  
                  # Test logging an attempt (should work without error)
                  progress_service.log_roleplay_attempt(test_user_id, '1.1', test_session_id)
                  print("âœ… log_roleplay_attempt works")
                  
                  # Clean up test data
                  supabase_service.get_service_client().table('roleplay_attempts').delete().eq('session_id', test_session_id).execute()
                  print("âœ… Test data cleaned up")
                  
              except Exception as e:
                  print(f"âŒ Data insertion test error: {e}")
                  return False
              
              print("\nðŸŽ‰ All tests passed! Database setup is working correctly.")
              print("\nðŸ“‹ Summary:")
              print("âœ… All required tables created")
              print("âœ… Roleplay configurations loaded")
              print("âœ… Progress service working")
              print("âœ… Data insertion/retrieval working")
              print("âœ… User integration working")
              print("âœ… UUID validation fixed")
              
              print("\nðŸš€ Next steps:")
              print("1. âœ… Database setup complete")
              print("2. ðŸ”„ Test your roleplay flow end-to-end")
              print("3. ðŸŽ¯ Verify AI scoring and progress tracking")
              print("4. ðŸš€ Deploy and test with real users")
              
              return True
              
          except Exception as e:
              print(f"âŒ Critical error during setup test: {e}")
              print("\nðŸ”§ Troubleshooting:")
              print("1. Check that you ran the database schema in Supabase")
              print("2. Verify your SUPABASE_URL and SUPABASE_SERVICE_KEY are set")
              print("3. Check that your supabase_client.py is working")
              print("4. Ensure you have proper database permissions")
              return False
      
      def check_existing_data():
          """Check what existing data you have"""
          
          print("\nðŸ” Checking existing data...")
          
          try:
              supabase_service = SupabaseService()
              
              # Check existing users
              users = supabase_service.get_service_client().table('user_profiles').select('id, first_name, created_at, access_level').limit(5).execute()
              print(f"ðŸ“Š Found {len(users.data) if users.data else 0} users in user_profiles")
              
              if users.data:
                  print("   Sample users:")
                  for user in users.data[:3]:
                      access_level = user.get('access_level', 'unknown')
                      print(f"   - {user['first_name']} ({access_level})")
              
              # Check existing voice sessions (legacy)
              sessions = supabase_service.get_service_client().table('voice_sessions').select('id, user_id, roleplay_id, score').limit(5).execute()
              print(f"ðŸ“Š Found {len(sessions.data) if sessions.data else 0} existing voice sessions")
              
              # Check new progress system
              completions = supabase_service.get_service_client().table('roleplay_completions').select('id, user_id, roleplay_id, score').limit(5).execute()
              print(f"ðŸ“Š Found {len(completions.data) if completions.data else 0} roleplay completions")
              
              if sessions.data and len(sessions.data) > 0:
                  print("\nðŸ’¡ Migration Opportunity:")
                  print("   You have existing voice_sessions data that could be migrated")
                  print("   to the new roleplay_completions table for better tracking")
              
          except Exception as e:
              print(f"âŒ Error checking existing data: {e}")
      
      if __name__ == "__main__":
          print("ðŸ Starting Database Setup Test...")
          print("=" * 50)
          
          # Check existing data first
          check_existing_data()
          
          # Run main test
          success = test_database_setup()
          
          print("=" * 50)
          if success:
              print("âœ… Setup test completed successfully!")
              print("\nðŸŽ¯ Your system is ready for:")
              print("   â€¢ User registration and authentication")
              print("   â€¢ Roleplay progress tracking")
              print("   â€¢ AI-powered coaching and feedback")
              print("   â€¢ Achievement system")
              print("   â€¢ Leaderboards and stats")
          else:
              print("âŒ Setup test failed. Please check the errors above.")
          
          print("\nðŸ“ž Need help? Check the errors above for debugging guidance.")

📄 __init__.py (0KB)
    (Empty file)

📁 models/
  📄 roleplay.py (0KB)
      (Empty file)

  📄 session.py (0KB)
      (Empty file)

  📄 user.py (0KB)
      (Empty file)

  📄 __init__.py (0KB)
      (Empty file)

📁 routes/
  📄 admin.py (7.9KB)
      Content:
        # ===== CORRECTED FILE: routes/admin.py =====
        # Fix: Removed the redundant and error-prone `user_id = request.view_args['user_id']` line.
        
        from flask import Blueprint, request, jsonify, session
        from services.supabase_client import SupabaseService
        import logging
        from utils.helpers import require_admin
        from datetime import datetime, timezone, timedelta
        
        logger = logging.getLogger(__name__)
        admin_bp = Blueprint('admin', __name__)
        
        supabase_service = SupabaseService()
        
        @admin_bp.route('/users', methods=['GET'])
        @require_admin
        def get_all_users():
            """Get all users for admin panel"""
            try:
                page = request.args.get('page', 1, type=int)
                limit = request.args.get('limit', 50, type=int)
                search = request.args.get('search', '').strip()
                
                offset = (page - 1) * limit
                
                # Use service client to bypass RLS for admin operations
                service_client = supabase_service.get_service_client()
                
                logger.info(f"Admin users request: page={page}, limit={limit}, search='{search}'")
                
                # Use the view that includes emails
                query = service_client.table('admin_users_view').select('*')
                
                # Apply search filter (can now search email too!)
                if search:
                    query = query.or_(f'first_name.ilike.%{search}%,email.ilike.%{search}%')
                
                # Execute query with pagination
                response = query.order('created_at', desc=True)\
                    .range(offset, offset + limit - 1)\
                    .execute()
                
                users = response.data or []
                logger.info(f"Query returned {len(users)} users with emails")
                
                # Emails are now included in the response from the view!
                for user in users:
                    if not user.get('email'):
                        user['email'] = 'N/A'
                
                # Get total count using the view
                count_query = service_client.table('admin_users_view').select('id', count='exact')
                if search:
                    count_query = count_query.or_(f'first_name.ilike.%{search}%,email.ilike.%{search}%')
                
                count_response = count_query.execute()
                total_count = count_response.count or 0
                
                logger.info(f"Total count: {total_count}")
                
                return jsonify({
                    'users': users,
                    'total_count': total_count,
                    'page': page,
                    'limit': limit,
                    'total_pages': (total_count + limit - 1) // limit if total_count > 0 else 1
                })
                
            except Exception as e:
                logger.error(f"Error getting all users: {e}")
                return jsonify({'error': 'Internal server error', 'details': str(e)}), 500
        
        @admin_bp.route('/users/<user_id>/access-level', methods=['PUT'])
        @require_admin
        def update_user_access_level(user_id):
            """Update user's access level"""
            try:
                data = request.get_json()
                new_access_level = data.get('access_level')
                
                if new_access_level not in ['limited_trial', 'unlimited_basic', 'unlimited_pro', 'admin']:
                    return jsonify({'error': 'Invalid access level'}), 400
                
                # Use service client to update admin users
                if supabase_service.update_user_profile_by_service(user_id, {'access_level': new_access_level}):
                    logger.info(f"Updated access level for user {user_id} to {new_access_level}")
                    return jsonify({'message': 'Access level updated successfully'})
                else:
                    return jsonify({'error': 'Failed to update access level'}), 500
                    
            except Exception as e:
                logger.error(f"Error updating access level: {e}")
                return jsonify({'error': 'Internal server error'}), 500
        
        @admin_bp.route('/stats', methods=['GET'])
        @require_admin
        def get_admin_stats():
            """Get overall platform statistics"""
            try:
                # Use service client to bypass RLS
                service_client = supabase_service.get_service_client()
                
                # Get user stats
                users_response = service_client.table('user_profiles')\
                    .select('access_level,created_at')\
                    .execute()
                
                users = users_response.data or []
                
                # Get session stats
                sessions_response = service_client.table('voice_sessions')\
                    .select('duration_minutes,success,created_at')\
                    .execute()
                
                sessions = sessions_response.data or []
                
                # Calculate stats - USE TIMEZONE-AWARE DATETIME
                now = datetime.now(timezone.utc)  # This is timezone-aware
                week_ago = now - timedelta(days=7)
                month_ago = now - timedelta(days=30)
                
                stats = {
                    'total_users': len(users),
                    'trial_users': sum(1 for u in users if u['access_level'] == 'limited_trial'),
                    'basic_users': sum(1 for u in users if u['access_level'] == 'unlimited_basic'),
                    'pro_users': sum(1 for u in users if u['access_level'] == 'unlimited_pro'),
                    'admin_users': sum(1 for u in users if u['access_level'] == 'admin'),
                    'new_users_this_week': 0,
                    'new_users_this_month': 0,
                    'total_sessions': len(sessions),
                    'successful_sessions': sum(1 for s in sessions if s.get('success')),
                    'total_minutes': sum(s.get('duration_minutes', 0) for s in sessions if s.get('duration_minutes')),
                    'sessions_this_week': 0,
                    'sessions_this_month': 0
                }
                
                # Helper function to parse datetime strings consistently
                def parse_datetime_string(date_string):
                    """Parse datetime string to timezone-aware datetime"""
                    if not date_string:
                        return None
                    try:
                        # Handle different datetime formats from Supabase
                        if date_string.endswith('Z'):
                            # Convert 'Z' to '+00:00'
                            return datetime.fromisoformat(date_string.replace('Z', '+00:00'))
                        elif '+' in date_string and date_string.count('+') == 1:
                            # Already has timezone info
                            return datetime.fromisoformat(date_string)
                        elif 'T' in date_string:
                            # No timezone info, assume UTC
                            return datetime.fromisoformat(date_string + '+00:00')
                        else:
                            # Legacy format without timezone
                            dt = datetime.strptime(date_string, '%Y-%m-%d %H:%M:%S')
                            return dt.replace(tzinfo=timezone.utc)
                    except (ValueError, TypeError) as e:
                        logger.warning(f"Could not parse datetime '{date_string}': {e}")
                        return None
                
                # Calculate time-based stats for users
                for user in users:
                    user_date = parse_datetime_string(user.get('created_at'))
                    if user_date:
                        if user_date >= week_ago:
                            stats['new_users_this_week'] += 1
                        if user_date >= month_ago:
                            stats['new_users_this_month'] += 1
                
                # Calculate time-based stats for sessions
                for session in sessions:
                    session_date = parse_datetime_string(session.get('created_at'))
                    if session_date:
                        if session_date >= week_ago:
                            stats['sessions_this_week'] += 1
                        if session_date >= month_ago:
                            stats['sessions_this_month'] += 1
                
                # Calculate success rate
                if stats['total_sessions'] > 0:
                    stats['success_rate'] = round((stats['successful_sessions'] / stats['total_sessions']) * 100, 1)
                else:
                    stats['success_rate'] = 0
                
                logger.info(f"Admin stats calculated successfully: {stats}")
                return jsonify(stats)
                
            except Exception as e:
                logger.error(f"Error getting admin stats: {e}")
                return jsonify({'error': 'Internal server error', 'details': str(e)}), 500

  📄 auth.py (15.8KB)
      Content:
        # ===== IMPROVED API/ROUTES/AUTH.PY =====
        from flask import Blueprint, request, jsonify, session
        from services.supabase_client import SupabaseService
        from services.resend_service import ResendService
        from utils.constants import JOB_TITLES, INDUSTRIES
        import logging
        import json
        import re
        
        logger = logging.getLogger(__name__)
        auth_bp = Blueprint('auth', __name__)
        
        supabase_service = SupabaseService()
        resend_service = ResendService()
        
        def validate_email(email):
            """Validate email format"""
            pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            return re.match(pattern, email) is not None
        
        def validate_password(password):
            """Validate password requirements"""
            return password and len(password) >= 6
        
        @auth_bp.route('/send-verification', methods=['POST'])
        def send_verification():
            """Send verification code and store user data for later registration"""
            try:
                data = request.get_json()
                if not data:
                    return jsonify({'error': 'No data provided'}), 400
                    
                # Extract and validate data
                email = data.get('email', '').strip().lower()
                first_name = data.get('first_name', '').strip()
                password = data.get('password', '')
                prospect_job_title = data.get('prospect_job_title', '')
                prospect_industry = data.get('prospect_industry', '')
                custom_ai_notes = data.get('custom_ai_notes', '').strip()
                
                # Validate required fields
                if not email:
                    return jsonify({'error': 'Email is required'}), 400
                if not validate_email(email):
                    return jsonify({'error': 'Invalid email format'}), 400
                if not first_name:
                    return jsonify({'error': 'First name is required'}), 400
                if not validate_password(password):
                    return jsonify({'error': 'Password must be at least 6 characters long'}), 400
                if not prospect_job_title:
                    return jsonify({'error': 'Job title is required'}), 400
                if not prospect_industry:
                    return jsonify({'error': 'Industry is required'}), 400
                
                # Validate job title and industry against allowed values
                if prospect_job_title not in JOB_TITLES:
                    return jsonify({'error': 'Invalid job title selected'}), 400
                
                if prospect_industry not in INDUSTRIES:
                    return jsonify({'error': 'Invalid industry selected'}), 400
                
                # Check if user already exists in a better way
                client = supabase_service.get_client()
                try:
                    # Check if email is already registered by looking at existing profiles
                    existing_profile = client.table('user_profiles').select('id').eq('id', 
                        client.table('user_profiles').select('id').execute().data
                    ).execute()
                    
                    # Alternative: check auth users via API (this is safer)
                    # For now, we'll proceed and let Supabase handle duplicate email errors
                    
                except Exception as e:
                    logger.warning(f"Could not check existing user: {e}")
                    # Continue with registration process
                
                # Generate verification code
                code = resend_service.generate_verification_code()
                
                # Store user data temporarily with the verification code
                user_data = {
                    'email': email,
                    'password': password,
                    'first_name': first_name,
                    'prospect_job_title': prospect_job_title,
                    'prospect_industry': prospect_industry,
                    'custom_ai_notes': custom_ai_notes
                }
                
                # Store verification code with user data
                if not supabase_service.create_verification_code_with_data(email, code, user_data):
                    return jsonify({'error': 'Failed to create verification code. Please try again.'}), 500
                
                # Send email
                if not resend_service.send_verification_email(email, code, first_name):
                    return jsonify({'error': 'Failed to send verification email. Please check your email address.'}), 500
                
                logger.info(f"Verification code sent successfully to {email}")
                return jsonify({'message': 'Verification code sent successfully'})
                
            except Exception as e:
                logger.error(f"Error sending verification: {e}")
                return jsonify({'error': 'Internal server error. Please try again.'}), 500
        
        @auth_bp.route('/verify-and-register', methods=['POST'])
        def verify_and_register():
            """Verify email code and automatically create user account"""
            try:
                data = request.get_json()
                if not data:
                    return jsonify({'error': 'No data provided'}), 400
                    
                email = data.get('email', '').strip().lower()
                code = data.get('code', '').strip()
                
                if not email:
                    return jsonify({'error': 'Email is required'}), 400
                if not code:
                    return jsonify({'error': 'Verification code is required'}), 400
                if len(code) != 6 or not code.isdigit():
                    return jsonify({'error': 'Verification code must be 6 digits'}), 400
                
                # Verify code and get stored user data
                user_data = supabase_service.verify_code_and_get_data(email, code)
                if not user_data:
                    return jsonify({'error': 'Invalid or expired verification code'}), 400
                
                # Extract user data
                password = user_data.get('password')
                first_name = user_data.get('first_name')
                prospect_job_title = user_data.get('prospect_job_title')
                prospect_industry = user_data.get('prospect_industry')
                custom_ai_notes = user_data.get('custom_ai_notes', '')
                
                # Double-check we have all required data
                if not all([password, first_name, prospect_job_title, prospect_industry]):
                    return jsonify({'error': 'Registration data incomplete. Please start over.'}), 400
                
                # Create user in Supabase Auth
                client = supabase_service.get_client()
                try:
                    auth_response = client.auth.sign_up({
                        "email": email,
                        "password": password
                    })
                except Exception as auth_error:
                    logger.error(f"Supabase auth error during signup: {auth_error}")
                    error_msg = str(auth_error).lower()
                    if "already registered" in error_msg or "already exists" in error_msg:
                        return jsonify({'error': 'An account with this email already exists. Please log in instead.'}), 409
                    else:
                        return jsonify({'error': 'Failed to create account. Please try again.'}), 500
                
                if not auth_response.user:
                    return jsonify({'error': 'Failed to create user account'}), 500
                
                user_id = auth_response.user.id
                
                # Create user profile with limited_trial access level (controlled by admin)
                profile_data = {
                    'id': user_id,
                    'first_name': first_name,
                    'prospect_job_title': prospect_job_title,
                    'prospect_industry': prospect_industry,
                    'custom_ai_notes': custom_ai_notes,
                    'access_level': 'limited_trial'  # Default access level - admin can upgrade
                }
                
                if not supabase_service.create_user_profile(profile_data):
                    # If profile creation fails, we should clean up the auth user
                    try:
                        client.auth.admin.delete_user(user_id)
                    except:
                        logger.error(f"Failed to cleanup auth user {user_id} after profile creation failure")
                    return jsonify({'error': 'Failed to create user profile'}), 500
                
                # Initialize progress for Roleplay 1 (always unlocked)
                supabase_service.update_user_progress(user_id, 1, {
                    'unlocked_at': 'NOW()'
                })
                
                # Send welcome email
                try:
                    resend_service.send_welcome_email(email, first_name)
                except Exception as e:
                    logger.warning(f"Failed to send welcome email: {e}")
                    # Don't fail registration if welcome email fails
                
                logger.info(f"User {email} registered successfully with limited_trial access")
                return jsonify({
                    'message': 'Account created successfully! You can now log in.',
                    'user': {
                        'id': user_id,
                        'email': email,
                        'first_name': first_name,
                        'access_level': 'limited_trial'
                    }
                })
                
            except Exception as e:
                logger.error(f"Error in verify-and-register: {e}")
                return jsonify({'error': 'Internal server error. Please try again.'}), 500
        
        # Keep the old routes for backward compatibility
        @auth_bp.route('/verify-email', methods=['POST'])
        def verify_email():
            """Legacy verify email endpoint - redirects to new flow"""
            return verify_and_register()
        
        @auth_bp.route('/register', methods=['POST'])
        def register():
            """Legacy register endpoint - redirects to new flow"""
            return send_verification()
        
        @auth_bp.route('/login', methods=['POST'])
        def login():
            """Login user with enhanced error handling"""
            try:
                data = request.get_json()
                if not data:
                    return jsonify({'error': 'No data provided'}), 400
                    
                email = data.get('email', '').strip().lower()
                password = data.get('password', '')
                
                if not email:
                    return jsonify({'error': 'Email is required'}), 400
                if not password:
                    return jsonify({'error': 'Password is required'}), 400
                if not validate_email(email):
                    return jsonify({'error': 'Invalid email format'}), 400
                
                # Authenticate with Supabase
                client = supabase_service.get_client()
                
                try:
                    auth_response = client.auth.sign_in_with_password({
                        "email": email,
                        "password": password
                    })
                except Exception as auth_error:
                    logger.error(f"Supabase auth error: {auth_error}")
                    
                    # Parse specific error messages
                    error_msg = str(auth_error).lower()
                    if "invalid login credentials" in error_msg or "invalid" in error_msg:
                        return jsonify({'error': 'Invalid email or password'}), 401
                    elif "email not confirmed" in error_msg:
                        return jsonify({'error': 'Please verify your email first'}), 401
                    else:
                        return jsonify({'error': 'Login failed. Please try again.'}), 401
                
                if not auth_response.user or not auth_response.session:
                    return jsonify({'error': 'Invalid email or password'}), 401
                
                user = auth_response.user
                session_token = auth_response.session.access_token
                
                # Get user profile with better error handling
                profile = supabase_service.get_user_profile_by_service(user.id)
                if not profile:
                    logger.error(f"User profile not found for user_id: {user.id}")
                    return jsonify({
                        'error': 'Account setup incomplete. Please register again.',
                        'code': 'profile_not_found'
                    }), 404
                
                # Store session
                session['user_id'] = user.id
                session['access_token'] = session_token
                
                logger.info(f"User {email} logged in successfully")
                return jsonify({
                    'message': 'Login successful',
                    'user': {
                        'id': user.id,
                        'email': user.email,
                        'first_name': profile['first_name'],
                        'access_level': profile['access_level'],
                        'trial_signup_date': profile.get('trial_signup_date'),
                        'lifetime_usage_minutes': profile.get('lifetime_usage_minutes', 0)
                    },
                    'access_token': session_token
                })
                
            except Exception as e:
                logger.error(f"Error logging in: {e}")
                return jsonify({'error': 'Internal server error. Please try again.'}), 500
        
        @auth_bp.route('/logout', methods=['POST'])
        def logout():
            """Logout user"""
            try:
                # Clear session
                session.clear()
                
                return jsonify({'message': 'Logout successful'})
                
            except Exception as e:
                logger.error(f"Error logging out: {e}")
                return jsonify({'error': 'Internal server error'}), 500
        
        @auth_bp.route('/me', methods=['GET'])
        def get_current_user():
            """Get current user info"""
            try:
                access_token = request.headers.get('Authorization', '').replace('Bearer ', '')
                if not access_token:
                    access_token = session.get('access_token')
                
                if not access_token:
                    return jsonify({'error': 'No access token provided'}), 401
                
                # Verify token and get user
                user = supabase_service.authenticate_user(access_token)
                if not user:
                    return jsonify({'error': 'Invalid or expired token'}), 401
                
                # Handle both dict and object types for user
                try:
                    if hasattr(user, 'id'):
                        user_id = user.id
                        user_email = user.email
                    elif isinstance(user, dict):
                        user_id = user['id']
                        user_email = user['email']
                    else:
                        return jsonify({'error': 'Invalid user object format'}), 401
                except (AttributeError, KeyError) as e:
                    logger.error(f"Error extracting user data: {e}")
                    return jsonify({'error': 'Invalid user object format'}), 401
                
                # Get user profile
                profile = supabase_service.get_user_profile_by_service(user_id)
                if not profile:
                    return jsonify({'error': 'User profile not found'}), 404
                
                # Get user progress
                progress = supabase_service.get_user_progress(user_id)
                
                return jsonify({
                    'user': {
                        'id': user_id,
                        'email': user_email,
                        'first_name': profile['first_name'],
                        'prospect_job_title': profile['prospect_job_title'],
                        'prospect_industry': profile['prospect_industry'],
                        'access_level': profile['access_level'],
                        'monthly_usage_minutes': profile['monthly_usage_minutes'],
                        'lifetime_usage_minutes': profile['lifetime_usage_minutes'],
                        'trial_signup_date': profile.get('trial_signup_date')
                    },
                    'progress': progress
                })
                
            except Exception as e:
                logger.error(f"Error getting current user: {e}")
                return jsonify({'error': 'Internal server error'}), 500
            
        # ===== API/ROUTES/DASHBOARD.PY =====
        from flask import Blueprint, render_template, session, redirect, url_for
        from utils.decorators import require_auth
        import logging
        
        logger = logging.getLogger(__name__)
        dashboard_bp = Blueprint('dashboard', __name__)
        
        @dashboard_bp.route('/dashboard')
        @require_auth
        def dashboard():
            """Dashboard page"""
            try:
                return render_template('dashboard.html')
            except Exception as e:
                logger.error(f"Error rendering dashboard: {e}")
                return redirect(url_for('home'))
        
        @dashboard_bp.route('/roleplay/<int:roleplay_id>')
        @require_auth
        def roleplay(roleplay_id):
            """Roleplay page"""
            try:
                # Validate roleplay ID
                if roleplay_id not in [1, 2, 3, 4, 5]:
                    return redirect(url_for('dashboard'))
                
                # Here you would check if user has access to this roleplay
                # For now, just render a placeholder
                return render_template('roleplay.html', roleplay_id=roleplay_id)
            except Exception as e:
                logger.error(f"Error rendering roleplay {roleplay_id}: {e}")
                return redirect(url_for('dashboard'))

  📄 dashboard.py (0.6KB)
      Content:
        # ===== FIXED API/ROUTES/DASHBOARD.PY =====
        from flask import Blueprint, render_template, session, redirect, url_for, request
        from utils.decorators import require_auth
        import logging
        
        logger = logging.getLogger(__name__)
        dashboard_bp = Blueprint('dashboard', __name__)
        
        @dashboard_bp.route('/dashboard')
        @require_auth
        def dashboard():
            """Dashboard page"""
            try:
                logger.info(f"Dashboard accessed by user {session.get('user_id')}")
                return render_template('dashboard.html')
            except Exception as e:
                logger.error(f"Error rendering dashboard: {e}")
                return redirect(url_for('home'))
        

  📄 DEBUG.PY (5.1KB)
      Content:
        # ===== API/ROUTES/DEBUG.PY (FOR TESTING ONLY) =====
        from flask import Blueprint, request, jsonify
        from services.supabase_client import SupabaseService
        import logging
        import os
        
        logger = logging.getLogger(__name__)
        debug_bp = Blueprint('debug', __name__)
        
        supabase_service = SupabaseService()
        
        # Only enable debug routes in development
        DEBUG_ENABLED = os.getenv('FLASK_ENV') == 'development' or os.getenv('DEBUG') == 'true'
        
        @debug_bp.route('/health', methods=['GET'])
        def health_check():
            """Health check endpoint"""
            return jsonify({
                'status': 'ok',
                'message': 'Cold Calling Coach API is running'
            })
        
        @debug_bp.route('/test-db', methods=['GET'])
        def test_database():
            """Test database connection"""
            if not DEBUG_ENABLED:
                return jsonify({'error': 'Debug routes disabled'}), 403
            
            try:
                client = supabase_service.get_client()
                
                # Test basic query
                response = client.table('user_profiles').select('count').execute()
                
                return jsonify({
                    'status': 'success',
                    'message': 'Database connection successful',
                    'user_count': len(response.data) if response.data else 0
                })
                
            except Exception as e:
                logger.error(f"Database test failed: {e}")
                return jsonify({
                    'status': 'error',
                    'message': f'Database connection failed: {str(e)}'
                }), 500
        
        @debug_bp.route('/check-verification/<email>', methods=['GET'])
        def check_verification_codes(email):
            """Check verification codes for an email (development only)"""
            if not DEBUG_ENABLED:
                return jsonify({'error': 'Debug routes disabled'}), 403
            
            try:
                client = supabase_service.get_client()
                
                # Get all verification codes for this email
                response = client.table('verification_codes')\
                    .select('*')\
                    .eq('email', email.lower())\
                    .order('created_at', desc=True)\
                    .execute()
                
                codes = []
                for record in response.data:
                    codes.append({
                        'code': record['code'],
                        'used': record['used'],
                        'expires_at': record['expires_at'],
                        'created_at': record['created_at'],
                        'has_user_data': bool(record.get('user_data', '{}') != '{}')
                    })
                
                return jsonify({
                    'email': email,
                    'codes': codes,
                    'total_codes': len(codes)
                })
                
            except Exception as e:
                logger.error(f"Error checking verification codes: {e}")
                return jsonify({'error': str(e)}), 500
        
        @debug_bp.route('/cleanup-verification', methods=['POST'])
        def cleanup_verification_codes():
            """Clean up expired verification codes (development only)"""
            if not DEBUG_ENABLED:
                return jsonify({'error': 'Debug routes disabled'}), 403
            
            try:
                client = supabase_service.get_client()
                
                # Delete expired codes
                response = client.table('verification_codes')\
                    .delete()\
                    .lt('expires_at', 'NOW()')\
                    .execute()
                
                return jsonify({
                    'status': 'success',
                    'message': 'Expired verification codes cleaned up'
                })
                
            except Exception as e:
                logger.error(f"Error cleaning up verification codes: {e}")
                return jsonify({'error': str(e)}), 500
        
        @debug_bp.route('/validate-constants', methods=['GET'])
        def validate_constants():
            """Validate job titles and industries constants"""
            from utils.constants import JOB_TITLES, INDUSTRIES
            
            return jsonify({
                'job_titles': {
                    'count': len(JOB_TITLES),
                    'first_5': JOB_TITLES[:5],
                    'last_5': JOB_TITLES[-5:]
                },
                'industries': {
                    'count': len(INDUSTRIES),
                    'first_5': INDUSTRIES[:5],
                    'last_5': INDUSTRIES[-5:]
                }
            })
        
        @debug_bp.route('/test-email-service', methods=['POST'])
        def test_email_service():
            """Test email service (development only)"""
            if not DEBUG_ENABLED:
                return jsonify({'error': 'Debug routes disabled'}), 403
            
            try:
                data = request.get_json()
                email = data.get('email')
                
                if not email:
                    return jsonify({'error': 'Email required'}), 400
                
                from services.resend_service import ResendService
                resend_service = ResendService()
                
                # Generate test code
                code = resend_service.generate_verification_code()
                
                # Try to send email
                success = resend_service.send_verification_email(email, code, 'Test User')
                
                return jsonify({
                    'status': 'success' if success else 'failed',
                    'code': code,  # Only in debug mode
                    'message': 'Test email sent' if success else 'Failed to send email'
                })
                
            except Exception as e:
                logger.error(f"Error testing email service: {e}")
                return jsonify({'error': str(e)}), 500

  📄 roleplay.py (29.6KB)
      Content:
        # ===== FIXED: api/routes/roleplay.py =====
        
        from flask import Blueprint, request, jsonify, session, Response, redirect, render_template, url_for
        import logging
        import uuid
        from datetime import datetime, timezone
        from typing import Dict, List, Any, Optional
        
        logger = logging.getLogger(__name__)
        
        # Import services with error handling
        try:
            from services.supabase_client import SupabaseService
            from services.elevenlabs_service import ElevenLabsService  
            from services.roleplay_engine import RoleplayEngine
            from services.user_progress_service import UserProgressService 
        except ImportError as e:
            logger.error(f"Service import error: {e}")
            # Create placeholder classes if needed
        
        # Import utilities with error handling  
        try:
            from utils.decorators import require_auth, check_usage_limits, validate_json_input, log_api_call
            from utils.helpers import log_user_action, format_duration
            from utils.constants import ROLEPLAY_CONFIG
        except ImportError as e:
            logger.error(f"Utils import error: {e}")
            # Create placeholder functions if needed
        
        # Create blueprint
        roleplay_bp = Blueprint('roleplay', __name__, url_prefix='/api/roleplay')
        
        # Initialize services
        try:
            supabase_service = SupabaseService()
            elevenlabs_service = ElevenLabsService()
            roleplay_engine = RoleplayEngine()
            progress_service = UserProgressService()
            logger.info("âœ… Roleplay services initialized successfully")
        except Exception as e:
            logger.error(f"âŒ Error initializing services: {e}")
            # Initialize with fallbacks
            supabase_service = None
            elevenlabs_service = None
            roleplay_engine = None
            progress_service = None
        
        # ===== FIXED SESSION STORAGE =====
        session_storage = {}  # In-memory backup
        DATABASE_SESSION_STORAGE = True  # Flag to use database storage
        
        def store_session_reliably(session_id: str, user_id: str, session_data: Dict) -> bool:
            """Store session in multiple places for reliability"""
            try:
                # Store in Flask session
                session['current_roleplay_session'] = session_id
                session['roleplay_user_id'] = user_id
                session['session_data'] = {
                    'session_id': session_id,
                    'user_id': user_id,
                    'roleplay_id': session_data.get('roleplay_id'),
                    'started_at': session_data.get('started_at'),
                    'current_stage': session_data.get('current_stage', 'phone_pickup')
                }
                
                # Store in memory backup
                session_storage[session_id] = {
                    'user_id': user_id,
                    'session_data': session_data,
                    'stored_at': datetime.now(timezone.utc).isoformat()
                }
                
                # Store in database for persistence (if available)
                if DATABASE_SESSION_STORAGE and supabase_service:
                    try:
                        supabase_service.upsert_data('active_roleplay_sessions', {
                            'session_id': session_id,
                            'user_id': user_id,
                            'session_data': session_data,
                            'created_at': datetime.now(timezone.utc).isoformat(),
                            'last_activity': datetime.now(timezone.utc).isoformat(),
                            'is_active': True
                        })
                        logger.info(f"Session {session_id} stored in database")
                    except Exception as db_error:
                        logger.warning(f"Failed to store session in database: {db_error}")
                
                logger.info(f"Session {session_id} stored reliably for user {user_id}")
                return True
                
            except Exception as e:
                logger.error(f"Failed to store session reliably: {e}")
                return False
        
        def retrieve_session_reliably(session_id: str, user_id: str) -> Optional[Dict]:
            """Retrieve session from multiple sources"""
            try:
                # First check roleplay engine (primary source)
                if roleplay_engine and session_id in roleplay_engine.active_sessions:
                    session_data = roleplay_engine.active_sessions[session_id]
                    logger.info(f"Session {session_id} found in roleplay engine")
                    return session_data
                
                # Check memory backup
                if session_id in session_storage:
                    stored_data = session_storage[session_id]
                    if stored_data['user_id'] == user_id:
                        logger.info(f"Session {session_id} found in memory backup")
                        # Restore to roleplay engine
                        if roleplay_engine:
                            roleplay_engine.active_sessions[session_id] = stored_data['session_data']
                        return stored_data['session_data']
                
                # Check database (if available)
                if DATABASE_SESSION_STORAGE and supabase_service:
                    try:
                        db_sessions = supabase_service.get_data_with_filter(
                            'active_roleplay_sessions',
                            'session_id',
                            session_id
                        )
                        if db_sessions and len(db_sessions) > 0:
                            db_session = db_sessions[0]
                            if db_session['user_id'] == user_id and db_session.get('is_active'):
                                session_data = db_session['session_data']
                                logger.info(f"Session {session_id} restored from database")
                                # Restore to roleplay engine
                                if roleplay_engine:
                                    roleplay_engine.active_sessions[session_id] = session_data
                                return session_data
                    except Exception as db_error:
                        logger.warning(f"Failed to retrieve session from database: {db_error}")
                
                logger.warning(f"Session {session_id} not found in any storage")
                return None
                
            except Exception as e:
                logger.error(f"Error retrieving session: {e}")
                return None
        
        def update_session_activity(session_id: str) -> None:
            """Update session last activity timestamp"""
            try:
                if DATABASE_SESSION_STORAGE and supabase_service:
                    supabase_service.update_data_by_id(
                        'active_roleplay_sessions',
                        {'session_id': session_id},
                        {'last_activity': datetime.now(timezone.utc).isoformat()}
                    )
            except Exception as e:
                logger.warning(f"Failed to update session activity: {e}")
        
        def cleanup_session(session_id: str) -> None:
            """Clean up session from all storage locations"""
            try:
                # Remove from memory
                session_storage.pop(session_id, None)
                
                # Remove from database (if available)
                if DATABASE_SESSION_STORAGE and supabase_service:
                    try:
                        supabase_service.update_data_by_id(
                            'active_roleplay_sessions',
                            {'session_id': session_id},
                            {'is_active': False, 'ended_at': datetime.now(timezone.utc).isoformat()}
                        )
                    except Exception as db_error:
                        logger.warning(f"Failed to cleanup session in database: {db_error}")
                
                # Clear from Flask session if it matches
                if session.get('current_roleplay_session') == session_id:
                    session.pop('current_roleplay_session', None)
                    session.pop('roleplay_user_id', None)
                    session.pop('session_data', None)
                
                logger.info(f"Session {session_id} cleaned up")
                
            except Exception as e:
                logger.error(f"Error cleaning up session: {e}")
        
        @roleplay_bp.route('/start', methods=['POST'])
        def start_roleplay():
            """FIXED: Start roleplay session with robust session management"""
            try:
                data = request.get_json()
                user_id = session.get('user_id')
                
                if not user_id:
                    return jsonify({'error': 'User not authenticated'}), 401
                
                roleplay_id = data.get('roleplay_id')
                mode = data.get('mode', 'practice')
                
                logger.info(f"ðŸš€ Starting roleplay: {roleplay_id}, mode={mode}, user={user_id}")
                
                # CRITICAL: Check if roleplay engine is available
                if not roleplay_engine:
                    logger.error("âŒ Roleplay engine not available")
                    return jsonify({'error': 'Roleplay service unavailable'}), 503
                
                # Clean up any existing sessions for this user
                existing_session_id = session.get('current_roleplay_session')
                if existing_session_id:
                    logger.info(f"ðŸ§¹ Cleaning up existing session: {existing_session_id}")
                    try:
                        roleplay_engine.end_session(existing_session_id, forced_end=True)
                        cleanup_session(existing_session_id)
                    except Exception as cleanup_error:
                        logger.warning(f"Error cleaning up existing session: {cleanup_error}")
                
                # Get user profile and context
                try:
                    if supabase_service:
                        profile = supabase_service.get_user_profile_by_service(user_id)
                    else:
                        profile = None
                except Exception as profile_error:
                    logger.warning(f"Failed to get user profile: {profile_error}")
                    profile = None
                    
                if not profile:
                    profile = {
                        'first_name': 'User',
                        'prospect_job_title': 'CTO',
                        'prospect_industry': 'Technology'
                    }
                
                user_context = {
                    'first_name': profile.get('first_name', 'User'),
                    'prospect_job_title': profile.get('prospect_job_title', 'CTO'),
                    'prospect_industry': profile.get('prospect_industry', 'Technology'),
                    'access_level': profile.get('access_level', 'limited_trial'),
                    'roleplay_version': roleplay_id
                }
                
                # CRITICAL: Create roleplay session with enhanced error handling
                try:
                    logger.info(f"ðŸ“ž Creating roleplay session: {roleplay_id}")
                    session_result = roleplay_engine.create_session(
                        user_id=user_id,
                        roleplay_id=roleplay_id,
                        mode=mode,
                        user_context=user_context
                    )
                    logger.info(f"ðŸ“ž Session creation result: {session_result.get('success', False)}")
                except Exception as engine_error:
                    logger.error(f"âŒ Roleplay engine error: {engine_error}")
                    return jsonify({'error': f'Failed to create session: {str(engine_error)}'}), 500
                
                if not session_result.get('success'):
                    error_msg = session_result.get('error', 'Failed to create session')
                    logger.error(f"âŒ Session creation failed: {error_msg}")
                    return jsonify({'error': error_msg}), 500
                
                session_id = session_result['session_id']
                logger.info(f"âœ… Session created successfully: {session_id}")
                
                # Store session reliably
                session_data = roleplay_engine.active_sessions.get(session_id, {})
                success = store_session_reliably(session_id, user_id, session_data)
                
                if not success:
                    logger.error("âŒ Failed to store session reliably")
                    return jsonify({'error': 'Failed to initialize session storage'}), 500
                
                # Prepare response data
                response_data = {
                    'message': f'Roleplay {roleplay_id} session started successfully',
                    'session_id': session_id,
                    'roleplay_id': roleplay_id,
                    'mode': mode,
                    'initial_response': session_result.get('initial_response', 'Hello?'),
                    'roleplay_info': session_result.get('roleplay_info', {}),
                    'tts_available': elevenlabs_service.is_available() if elevenlabs_service and hasattr(elevenlabs_service, 'is_available') else False,
                    'session_stored': True,
                    'user_context': user_context
                }
                
                logger.info(f"âœ… Roleplay {roleplay_id} session started successfully: {session_id}")
                return jsonify(response_data)
                
            except Exception as e:
                logger.error(f"âŒ Critical error starting roleplay: {e}")
                return jsonify({'error': 'Internal server error during session creation'}), 500
        
        @roleplay_bp.route('/respond', methods=['POST'])
        def handle_user_response():
            """FIXED: Handle user input with robust session recovery"""
            try:
                data = request.get_json()
                user_input = data.get('user_input', '').strip()
                user_id = session.get('user_id')
                
                if not user_id:
                    return jsonify({'error': 'User not authenticated'}), 401
                
                if not user_input:
                    return jsonify({'error': 'User input is required'}), 400
                
                # CRITICAL: Check if roleplay engine is available
                if not roleplay_engine:
                    logger.error("âŒ Roleplay engine not available")
                    return jsonify({'error': 'Roleplay service unavailable'}), 503
                
                # Get session ID with fallback logic
                session_id = session.get('current_roleplay_session')
                
                if not session_id:
                    logger.error("âŒ No session ID found in Flask session")
                    return jsonify({'error': 'No active roleplay session found. Please start a new call.'}), 400
                
                logger.info(f"ðŸ’¬ Processing user input for session {session_id}: '{user_input[:50]}...'")
                
                # Retrieve session with robust recovery
                session_data = retrieve_session_reliably(session_id, user_id)
                
                if not session_data:
                    logger.error(f"âŒ Session {session_id} not found in any storage location")
                    return jsonify({
                        'error': 'Session not found. Please start a new call.',
                        'session_expired': True,
                        'action_required': 'restart_call'
                    }), 404
                
                # Update session activity
                update_session_activity(session_id)
                
                # Validate session belongs to user
                if session_data.get('user_id') != user_id:
                    logger.error(f"âŒ Session {session_id} belongs to different user")
                    return jsonify({'error': 'Session access denied'}), 403
                
                # Check if session is still active
                if not session_data.get('session_active', True):
                    logger.error(f"âŒ Session {session_id} is no longer active")
                    return jsonify({
                        'error': 'Session has ended. Please start a new call.',
                        'session_expired': True,
                        'action_required': 'restart_call'
                    }), 400
                
                # CRITICAL: Process input through roleplay engine
                try:
                    logger.info(f"ðŸ”„ Processing through roleplay engine...")
                    response_result = roleplay_engine.process_user_input(session_id, user_input)
                    logger.info(f"ðŸ”„ Engine response success: {response_result.get('success', False)}")
                except Exception as processing_error:
                    logger.error(f"âŒ Input processing error: {processing_error}")
                    return jsonify({
                        'error': 'Failed to process your response. Please try again.',
                        'technical_error': str(processing_error)
                    }), 500
                
                if not response_result.get('success'):
                    error_msg = response_result.get('error', 'Failed to process input')
                    logger.error(f"âŒ Input processing failed: {error_msg}")
                    return jsonify({'error': error_msg}), 500
                
                # Prepare response
                response_data = {
                    'ai_response': response_result.get('ai_response', 'I see.'),
                    'call_continues': response_result.get('call_continues', True),
                    'session_state': response_result.get('session_state', 'in_progress'),
                    'evaluation': response_result.get('evaluation', {}),
                    'session_id': session_id,  # Include for verification
                    'turn_count': response_result.get('turn_count'),
                    'conversation_quality': response_result.get('conversation_quality')
                }
                
                logger.info(f"âœ… Response sent: '{response_data['ai_response'][:50]}...' | Continues: {response_data['call_continues']}")
                return jsonify(response_data)
                
            except Exception as e:
                logger.error(f"âŒ Critical error handling user response: {e}")
                return jsonify({
                    'error': 'Internal server error',
                    'action_required': 'restart_call',
                    'technical_details': str(e)
                }), 500
        
        @roleplay_bp.route('/end', methods=['POST'])
        def end_roleplay():
            """FIXED: End roleplay session with comprehensive cleanup"""
            try:
                data = request.get_json() or {}
                user_id = session.get('user_id')
                
                if not user_id:
                    return jsonify({'error': 'User not authenticated'}), 401
                
                forced_end = data.get('forced_end', False)
                session_id = session.get('current_roleplay_session')
                
                if not session_id:
                    logger.warning("âš ï¸ No active session to end")
                    return jsonify({'message': 'No active session found'}), 200
                
                logger.info(f"ðŸ“ž Ending roleplay session {session_id} for user {user_id}")
                
                # CRITICAL: Check if roleplay engine is available
                if not roleplay_engine:
                    logger.error("âŒ Roleplay engine not available for session end")
                    # Still clean up what we can
                    cleanup_session(session_id)
                    return jsonify({
                        'message': 'Session ended (service unavailable)',
                        'overall_score': 50,
                        'coaching': {'error': 'Service unavailable'},
                        'session_cleaned': True
                    })
                
                # End session through engine
                try:
                    end_result = roleplay_engine.end_session(session_id, forced_end)
                except Exception as engine_error:
                    logger.error(f"âŒ Roleplay engine end error: {engine_error}")
                    # Continue with cleanup even if engine fails
                    end_result = {
                        'success': True,
                        'duration_minutes': 1,
                        'session_success': False,
                        'coaching': {'error': 'Session ended with errors'},
                        'overall_score': 50
                    }
                
                if not end_result.get('success'):
                    logger.error(f"âŒ Failed to end session properly: {end_result}")
                    # Continue with cleanup
                
                # Clean up session completely
                cleanup_session(session_id)
                
                # Prepare response
                response_data = {
                    'message': 'Roleplay session ended successfully',
                    'duration_minutes': end_result.get('duration_minutes', 1),
                    'session_success': end_result.get('session_success', False),
                    'coaching': end_result.get('coaching', {}),
                    'overall_score': end_result.get('overall_score', 50),
                    'completion_message': f"Session complete! Score: {end_result.get('overall_score', 50)}/100",
                    'roleplay_type': end_result.get('roleplay_type', 'practice'),
                    'session_cleaned': True
                }
                
                logger.info(f"âœ… Roleplay session ended successfully. Score: {end_result.get('overall_score', 50)}")
                return jsonify(response_data)
                
            except Exception as e:
                logger.error(f"âŒ Critical error ending roleplay: {e}")
                
                # Emergency cleanup
                try:
                    session_id = session.get('current_roleplay_session')
                    if session_id:
                        cleanup_session(session_id)
                except Exception as cleanup_error:
                    logger.error(f"âŒ Emergency cleanup failed: {cleanup_error}")
                
                return jsonify({
                    'error': 'Internal server error during session end',
                    'message': 'Session has been cleaned up',
                    'technical_details': str(e)
                }), 500
        
        @roleplay_bp.route('/info/<roleplay_id>', methods=['GET'])
        def get_roleplay_info(roleplay_id):
            """Get roleplay information"""
            try:
                user_id = session.get('user_id')
                if not user_id:
                    return jsonify({'error': 'User not authenticated'}), 401
                
                # CRITICAL: Check if roleplay engine is available
                if not roleplay_engine:
                    logger.error("âŒ Roleplay engine not available")
                    # Return fallback info
                    return jsonify({
                        'id': roleplay_id,
                        'name': f'Roleplay {roleplay_id}',
                        'description': 'Cold calling training',
                        'type': 'practice',
                        'features': {'ai_evaluation': False, 'basic_coaching': True}
                    })
                
                # Get info from engine
                roleplay_info = roleplay_engine.get_roleplay_info(roleplay_id)
                
                if 'error' in roleplay_info:
                    return jsonify({'error': f'Invalid roleplay ID: {roleplay_id}'}), 404
                
                logger.info(f"âœ… Roleplay info retrieved for {roleplay_id}")
                return jsonify(roleplay_info)
                
            except Exception as e:
                logger.error(f"âŒ Error getting roleplay info: {e}")
                return jsonify({'error': 'Internal server error'}), 500
        
        @roleplay_bp.route('/available', methods=['GET'])
        def get_available_roleplays():
            """Get list of available roleplay types"""
            try:

  📄 user.py (24.1KB)
      Content:
        # ===== API/ROUTES/USER.PY (COMPLETELY FIXED) =====
        from flask import Blueprint, request, jsonify, session
        from services.supabase_client import SupabaseService
        from services.user_progress_service import UserProgressService
        from utils.decorators import require_auth
        from utils.constants import ROLEPLAY_CONFIG
        from datetime import datetime, timedelta, timezone
        import logging
        
        logger = logging.getLogger(__name__)
        user_bp = Blueprint('user', __name__)
        
        supabase_service = SupabaseService()
        progress_service = UserProgressService()
        
        @user_bp.route('/profile', methods=['GET'])
        @require_auth
        def get_profile():
            """Get user profile and progress"""
            try:
                user_id = session['user_id']
                logger.info(f"Getting profile for user {user_id}")
                
                # Get user profile using service client to bypass RLS
                profile = supabase_service.get_user_profile_by_service(user_id)
                if not profile:
                    logger.error(f"Profile not found for user {user_id}")
                    return jsonify({'error': 'Profile not found'}), 404
                
                # Get user progress
                progress = supabase_service.get_user_progress(user_id)
                
                # Calculate usage limits and access
                access_info = _calculate_access_info(profile)
                
                # Get roleplay unlock status
                roleplay_access = _get_roleplay_access(progress, profile['access_level'])
                
                logger.info(f"Successfully retrieved profile for user {user_id}")
                return jsonify({
                    'profile': profile,
                    'progress': progress,
                    'access_info': access_info,
                    'roleplay_access': roleplay_access
                })
                
            except Exception as e:
                logger.error(f"Error getting profile: {e}")
                return jsonify({'error': 'Internal server error'}), 500
        
        @user_bp.route('/stats', methods=['GET'])
        @require_auth
        def get_user_stats():
            """Get user statistics"""
            try:
                user_id = session['user_id']
                logger.info(f"Getting stats for user {user_id}")
                
                # Get profile for usage info using service client
                profile = supabase_service.get_user_profile_by_service(user_id)
                if not profile:
                    logger.error(f"Profile not found for user {user_id}")
                    return jsonify({'error': 'Profile not found'}), 404
                
                # Get session statistics using service client
                user_sessions = supabase_service.get_user_sessions(user_id, limit=1000)  # Get all sessions for stats
                
                # Calculate stats with better null handling
                stats = {
                    'total_sessions': len(user_sessions),
                    'total_minutes': sum(s.get('duration_minutes', 0) or 0 for s in user_sessions),
                    'successful_sessions': sum(1 for s in user_sessions if s.get('success') is True),
                    'success_rate': 0,
                    'favorite_roleplay': None,
                    'sessions_this_week': 0,
                    'sessions_this_month': 0,
                    'monthly_usage_minutes': profile.get('monthly_usage_minutes', 0) or 0,
                    'lifetime_usage_minutes': profile.get('lifetime_usage_minutes', 0) or 0
                }
                
                if stats['total_sessions'] > 0:
                    stats['success_rate'] = round((stats['successful_sessions'] / stats['total_sessions']) * 100, 1)
                
                # Calculate sessions this week/month with proper timezone handling
                now = datetime.now(timezone.utc)
                week_ago = now - timedelta(days=7)
                month_ago = now - timedelta(days=30)
                
                for user_session in user_sessions:
                    try:
                        session_date_str = user_session.get('created_at') or user_session.get('started_at')
                        if not session_date_str:
                            continue
                            
                        # Handle timezone-aware datetime strings
                        if 'T' in session_date_str:
                            if session_date_str.endswith('Z'):
                                session_date = datetime.fromisoformat(session_date_str.replace('Z', '+00:00'))
                            elif '+' in session_date_str or session_date_str.endswith('00'):
                                session_date = datetime.fromisoformat(session_date_str)
                            else:
                                session_date = datetime.fromisoformat(session_date_str + '+00:00')
                        else:
                            session_date = datetime.strptime(session_date_str, '%Y-%m-%d %H:%M:%S').replace(tzinfo=timezone.utc)
                        
                        if session_date >= week_ago:
                            stats['sessions_this_week'] += 1
                        if session_date >= month_ago:
                            stats['sessions_this_month'] += 1
                            
                    except (ValueError, TypeError) as e:
                        logger.warning(f"Could not parse session date {session_date_str}: {e}")
                        continue
                
                # Find favorite roleplay
                roleplay_counts = {}
                for user_session in user_sessions:
                    rp_id = user_session.get('roleplay_id')
                    if rp_id:
                        roleplay_counts[rp_id] = roleplay_counts.get(rp_id, 0) + 1
                
                if roleplay_counts:
                    favorite_id = max(roleplay_counts, key=roleplay_counts.get)
                    stats['favorite_roleplay'] = ROLEPLAY_CONFIG.get(favorite_id, {}).get('name', f'Roleplay {favorite_id}')
                
                logger.info(f"Successfully retrieved stats for user {user_id}")
                return jsonify(stats)
                
            except Exception as e:
                logger.error(f"Error getting user stats: {e}")
                return jsonify({'error': 'Internal server error'}), 500
        
        @user_bp.route('/sessions', methods=['GET'])
        @require_auth
        def get_user_sessions():
            """Get user's roleplay sessions"""
            try:
                user_id = session['user_id']
                page = request.args.get('page', 1, type=int)
                limit = request.args.get('limit', 20, type=int)
                
                logger.info(f"Getting sessions for user {user_id}, page {page}, limit {limit}")
                
                # Get sessions from database using service client
                offset = (page - 1) * limit
                user_sessions = supabase_service.get_user_sessions(user_id, limit=limit, offset=offset)
                
                # Get total count
                total_count = supabase_service.get_session_count(user_id)
                
                logger.info(f"Successfully retrieved {len(user_sessions)} sessions for user {user_id}")
                return jsonify({
                    'sessions': user_sessions,
                    'total_count': total_count,
                    'page': page,
                    'limit': limit,
                    'total_pages': (total_count + limit - 1) // limit if total_count > 0 else 1
                })
                
            except Exception as e:
                logger.error(f"Error getting user sessions: {e}")
                return jsonify({'error': 'Internal server error'}), 500
        
        @user_bp.route('/profile', methods=['PUT'])
        @require_auth
        def update_profile():
            """Update user profile"""
            try:
                user_id = session['user_id']
                data = request.get_json()
                
                if not data:
                    return jsonify({'error': 'No data provided'}), 400
                
                # Allow updating specific fields
                allowed_fields = ['first_name', 'prospect_job_title', 'prospect_industry', 'custom_ai_notes']
                updates = {k: v for k, v in data.items() if k in allowed_fields and v is not None}
                
                if not updates:
                    return jsonify({'error': 'No valid fields to update'}), 400
                
                logger.info(f"Updating profile for user {user_id} with fields: {list(updates.keys())}")
                
                if supabase_service.update_user_profile_by_service(user_id, updates):
                    logger.info(f"Successfully updated profile for user {user_id}")
                    return jsonify({'message': 'Profile updated successfully'})
                else:
                    logger.error(f"Failed to update profile for user {user_id}")
                    return jsonify({'error': 'Failed to update profile'}), 500
                    
            except Exception as e:
                logger.error(f"Error updating profile: {e}")
                return jsonify({'error': 'Internal server error'}), 500
        
        def _calculate_access_info(profile):
            """Calculate user's access limits and usage"""
            access_level = profile.get('access_level', 'limited_trial')
            monthly_usage = profile.get('monthly_usage_minutes', 0) or 0
            lifetime_usage = profile.get('lifetime_usage_minutes', 0) or 0
            
            result = {
                'access_level': access_level,
                'monthly_usage_minutes': monthly_usage,
                'lifetime_usage_minutes': lifetime_usage
            }
            
            if access_level == 'limited_trial':
                # 3 hours lifetime limit or 7 days from signup
                trial_limit_minutes = 180  # 3 hours
                remaining_minutes = max(0, trial_limit_minutes - lifetime_usage)
                
                # Check days remaining
                signup_date_str = profile.get('trial_signup_date') or profile.get('created_at')
                if signup_date_str:
                    try:
                        signup_date = _parse_iso_datetime(signup_date_str)
                        current_time = datetime.now(timezone.utc)
                        days_since_signup = (current_time - signup_date).days
                        days_remaining = max(0, 7 - days_since_signup)
                    except:
                        days_remaining = 7  # Default if can't parse
                else:
                    days_remaining = 7
                
                result.update({
                    'trial_minutes_remaining': remaining_minutes,
                    'trial_days_remaining': days_remaining,
                    'usage_percentage': round((lifetime_usage / trial_limit_minutes) * 100, 1) if trial_limit_minutes > 0 else 0,
                    'is_expired': remaining_minutes == 0 or days_remaining == 0,
                    'limit_type': 'trial'
                })
            
            else:  # Basic or Pro
                # 50 hours monthly limit
                monthly_limit_minutes = 3000  # 50 hours
                remaining_minutes = max(0, monthly_limit_minutes - monthly_usage)
                
                result.update({
                    'monthly_minutes_remaining': remaining_minutes,
                    'monthly_limit_minutes': monthly_limit_minutes,
                    'usage_percentage': round((monthly_usage / monthly_limit_minutes) * 100, 1) if monthly_limit_minutes > 0 else 0,
                    'is_expired': remaining_minutes == 0,
                    'limit_type': 'monthly'
                })
            
            return result
        
        def _get_roleplay_access(progress, access_level):
            """Get roleplay unlock status"""
            access = {}
            
            for roleplay_id in range(1, 6):
                config = ROLEPLAY_CONFIG.get(roleplay_id, {})
                progress_item = next((p for p in progress if p.get('roleplay_id') == roleplay_id), None)
                
                if roleplay_id == 1:
                    # Roleplay 1 always unlocked
                    access[roleplay_id] = {
                        'unlocked': True,
                        'unlock_condition': 'Always available',
                        'expires_at': None
                    }
                elif access_level == 'unlimited_pro':
                    # Pro users have everything unlocked
                    access[roleplay_id] = {
                        'unlocked': True,
                        'unlock_condition': 'Pro access',
                        'expires_at': None
                    }
                elif progress_item and progress_item.get('unlocked_at'):
                    # Check if unlock has expired (for Basic users)
                    is_unlocked = True
                    expires_at = progress_item.get('expires_at')
                    
                    if expires_at and access_level == 'unlimited_basic':
                        try:
                            expire_time = _parse_iso_datetime(expires_at)
                            current_time = datetime.now(timezone.utc)
                            is_unlocked = current_time < expire_time
                        except (ValueError, TypeError) as e:
                            logger.warning(f"Could not parse expiry date {expires_at}: {e}")
                            is_unlocked = True  # Default to unlocked if can't parse
                    
                    access[roleplay_id] = {
                        'unlocked': is_unlocked,
                        'unlock_condition': config.get('unlock_condition', 'Unknown'),
                        'expires_at': expires_at
                    }
                else:
                    # Not unlocked
                    access[roleplay_id] = {
                        'unlocked': False,
                        'unlock_condition': config.get('unlock_condition', 'Unknown'),
                        'expires_at': None
                    }
            
            return access
        
        def _parse_iso_datetime(date_string: str) -> datetime:
            """Parse ISO datetime string with timezone handling"""
            if not date_string:
                return datetime.now(timezone.utc)
            
            try:
                # Handle various datetime formats
                if 'T' in date_string:
                    if date_string.endswith('Z'):
                        return datetime.fromisoformat(date_string.replace('Z', '+00:00'))
                    elif '+' in date_string or date_string.endswith('00'):
                        return datetime.fromisoformat(date_string)
                    else:
                        return datetime.fromisoformat(date_string + '+00:00')
                else:
                    # Legacy format
                    return datetime.strptime(date_string, '%Y-%m-%d %H:%M:%S').replace(tzinfo=timezone.utc)
            except (ValueError, TypeError) as e:
                logger.warning(f"Could not parse datetime {date_string}: {e}")
                return datetime.now(timezone.utc)
        
        # ===== COMPLETE FIX: Replace these functions in routes/user.py =====
        
        @user_bp.route('/roleplay-progress', methods=['GET'])
        @require_auth
        def get_user_roleplay_progress():
            """Get comprehensive user roleplay progress - FIXED"""
            try:
                user_id = session.get('user_id')
                
                # Get progress data
                progress = progress_service.get_user_roleplay_progress(user_id)
                available_roleplays = progress_service.get_available_roleplays(user_id)
                completion_stats = progress_service.get_completion_stats(user_id)
                recommendations = progress_service.get_next_recommendations(user_id)
                
                # Get recent activity
                recent_completions = get_recent_completions(user_id, limit=5)
                
                # Get achievements - FIXED: Call helper function
                achievements = get_user_achievements_helper(user_id)
                
                response_data = {
                    'user_id': user_id,
                    'progress': progress,
                    'available_roleplays': available_roleplays,
                    'completion_stats': completion_stats,
                    'recommendations': recommendations,
                    'recent_activity': recent_completions,
                    'achievements': achievements,
                    'last_updated': datetime.now(timezone.utc).isoformat()
                }
                
                return jsonify(response_data)
                
            except Exception as e:
                logger.error(f"Error getting user progress: {e}")
                return jsonify({'error': 'Failed to load progress data'}), 500
        
        # ADD this new helper function:
        def get_user_achievements_helper(user_id: str):
            """Helper function to get user achievements (not a route)"""
            try:
                result = supabase_service.get_service_client().table('user_achievements').select(
                    '*'
                ).eq('user_id', user_id).order('earned_at', desc=True).execute()
                
                achievements = result.data if result.data else []
                
                return {
                    'achievements': achievements,
                    'total_points': sum(a.get('points', 0) for a in achievements),
                    'total_count': len(achievements)
                }
                
            except Exception as e:
                logger.error(f"Error getting achievements for user {user_id}: {e}")
                return {'achievements': [], 'total_points': 0, 'total_count': 0}
        
        # UPDATE the existing route function:
        @user_bp.route('/achievements', methods=['GET'])
        @require_auth  
        def get_user_achievements():
            """Get user's achievements (route function) - UPDATED"""
            try:
                user_id = session.get('user_id')
                
                # Call the helper function
                return jsonify(get_user_achievements_helper(user_id))
                
            except Exception as e:
                logger.error(f"Error getting achievements: {e}")
                return jsonify({'achievements': [], 'total_points': 0, 'total_count': 0})
        
        @user_bp.route('/leaderboard/<roleplay_id>', methods=['GET'])
        @require_auth
        def get_roleplay_leaderboard(roleplay_id):
            """Get leaderboard for specific roleplay"""
            try:
                limit = min(int(request.args.get('limit', 10)), 50)
                user_id = session.get('user_id')
                
                leaderboard = progress_service.get_leaderboard(roleplay_id, limit)
                
                # Find user's rank
                user_rank = None
                user_score = None
                for entry in leaderboard:
                    if entry['user_id'] == user_id:
                        user_rank = entry['rank']
                        user_score = entry['score']
                        break
                
                # If user not in top, find their rank
                if user_rank is None:
                    user_stats = supabase_service.get_service_client().table('user_roleplay_stats').select(
                        'best_score'
                    ).eq('user_id', user_id).eq('roleplay_id', roleplay_id).execute()
                    
                    if user_stats.data and user_stats.data[0]['best_score']:
                        user_score = user_stats.data[0]['best_score']
                        
                        # Count how many users have higher scores
                        higher_scores = supabase_service.get_service_client().table('user_roleplay_stats').select(
                            'user_id', count='exact'
                        ).eq('roleplay_id', roleplay_id).gt('best_score', user_score).execute()
                        
                        user_rank = (higher_scores.count or 0) + 1
                
                return jsonify({
                    'roleplay_id': roleplay_id,
                    'leaderboard': leaderboard,
                    'user_rank': user_rank,
                    'user_score': user_score,
                    'total_participants': len(leaderboard)
                })
                
            except Exception as e:
                logger.error(f"Error getting leaderboard: {e}")
                return jsonify({'error': 'Failed to load leaderboard'}), 500
            
        @user_bp.route('/export-progress', methods=['GET'])
        @require_auth
        def export_user_progress():
            """Export user's complete progress data"""
            try:
                user_id = session.get('user_id')
                format_type = request.args.get('format', 'json')  # json, csv
                
                # Get all user data
                progress = progress_service.get_user_roleplay_progress(user_id)
                completions = get_all_completions(user_id)
                achievements = get_user_achievements(user_id)
                
                export_data = {
                    'user_id': user_id,
                    'exported_at': datetime.now(timezone.utc).isoformat(),
                    'progress_summary': progress,
                    'all_completions': completions,
                    'achievements': achievements['achievements'],
                    'statistics': progress_service.get_completion_stats(user_id)
                }
                
                if format_type == 'csv':
                    # Convert to CSV format
                    return export_to_csv(export_data)
                else:
                    # Return JSON
                    return jsonify(export_data)
                
            except Exception as e:
                logger.error(f"Error exporting progress: {e}")
                return jsonify({'error': 'Failed to export data'}), 500
        
        # ===== Helper Functions =====
        
        def get_recent_completions(user_id: str, limit: int = 5):
            """Get recent roleplay completions"""
            try:
                result = supabase_service.get_service_client().table('roleplay_completions').select(
                    'roleplay_id, score, completed_at, duration_minutes, success'
                ).eq('user_id', user_id).order('completed_at', desc=True).limit(limit).execute()
                
                return result.data if result.data else []
                
            except Exception as e:
                logger.error(f"Error getting recent completions: {e}")
                return []
        
        def get_all_completions(user_id: str):
            """Get all user completions for export"""
            try:
                result = supabase_service.get_service_client().table('roleplay_completions').select(
                    '*'
                ).eq('user_id', user_id).order('completed_at', desc=True).execute()
                
                return result.data if result.data else []
                
            except Exception as e:
                logger.error(f"Error getting all completions: {e}")
                return []
        
        def calculate_improvement_trend(user_id: str):

  📄 __init__.py (0KB)
      (Empty file)

📁 services/
  📄 elevenlabs_service.py (21.4KB)
      Content:
        # ===== UPDATED API/SERVICES/ELEVENLABS_SERVICE.PY - ROLEPLAY 1.1 ENHANCED =====
        
        import os
        import io
        import requests
        import logging
        import wave
        import struct
        from typing import Optional, Dict, Any, BinaryIO, List
        from datetime import datetime
        
        logger = logging.getLogger(__name__)
        
        class ElevenLabsService:
            def __init__(self):
                self.api_key = os.getenv('REACT_APP_ELEVENLABS_API_KEY')
                self.base_url = "https://api.elevenlabs.io/v1"
                self.is_enabled = bool(self.api_key)
                
                # Enhanced voice configurations for Roleplay 1.1
                self.voice_configs = {
                    # Default prospect voice
                    'default_prospect': {
                        'voice_id': 'EXAVITQu4vr4xnSDxMaL',  # Bella - professional female
                        'stability': 0.5,
                        'similarity_boost': 0.75,
                        'style': 0.0,
                        'use_speaker_boost': True
                    },
                    
                    # Enhanced voices for different prospect types in Roleplay 1.1
                    'cto_tech': {
                        'voice_id': 'pNInz6obpgDQGcFmaJgB',  # Adam - confident male
                        'stability': 0.6,
                        'similarity_boost': 0.8,
                        'style': 0.2,
                        'use_speaker_boost': True
                    },
                    
                    'ceo_executive': {
                        'voice_id': 'EXAVITQu4vr4xnSDxMaL',  # Bella - authoritative female
                        'stability': 0.7,
                        'similarity_boost': 0.85,
                        'style': 0.3,
                        'use_speaker_boost': True
                    },
                    
                    'vp_sales': {
                        'voice_id': 'pNInz6obpgDQGcFmaJgB',  # Adam - sales-oriented
                        'stability': 0.5,
                        'similarity_boost': 0.7,
                        'style': 0.4,
                        'use_speaker_boost': True
                    },
                    
                    'director_operations': {
                        'voice_id': 'EXAVITQu4vr4xnSDxMaL',  # Bella - analytical
                        'stability': 0.8,
                        'similarity_boost': 0.75,
                        'style': 0.1,
                        'use_speaker_boost': True
                    },
                    
                    # Special voices for Roleplay 1.1 scenarios
                    'impatient_prospect': {
                        'voice_id': 'pNInz6obpgDQGcFmaJgB',  # Adam - more urgent
                        'stability': 0.3,
                        'similarity_boost': 0.6,
                        'style': 0.6,
                        'use_speaker_boost': True
                    },
                    
                    'busy_prospect': {
                        'voice_id': 'EXAVITQu4vr4xnSDxMaL',  # Bella - rushed
                        'stability': 0.4,
                        'similarity_boost': 0.65,
                        'style': 0.5,
                        'use_speaker_boost': True
                    }
                }
                
                # Enhanced voice settings for Roleplay 1.1 stages
                self.roleplay_11_voice_settings = {
                    'phone_pickup': {'stability': 0.6, 'style': 0.0},  # Neutral answer
                    'opener_evaluation': {'stability': 0.5, 'style': 0.2},  # Slightly skeptical
                    'early_objection': {'stability': 0.4, 'style': 0.4},  # More resistant
                    'mini_pitch': {'stability': 0.5, 'style': 0.3},  # Cautiously interested
                    'soft_discovery': {'stability': 0.6, 'style': 0.2},  # More engaged
                    'silence_impatience': {'stability': 0.3, 'style': 0.7},  # Clearly impatient
                    'silence_hangup': {'stability': 0.2, 'style': 0.8}  # Very frustrated
                }
                
                if self.is_enabled:
                    logger.info("ElevenLabs service initialized for Roleplay 1.1")
                else:
                    logger.warning("ElevenLabs API key not provided - using fallback audio")
        
            def text_to_speech(self, text: str, voice_settings: Optional[Dict] = None) -> io.BytesIO:
                """
                Convert text to speech with enhanced Roleplay 1.1 support
                This method NEVER fails - always returns audio data
                """
                try:
                    # Validate input
                    if not text or not text.strip():
                        logger.info("Empty text for TTS, generating silence")
                        return self._generate_silent_audio()
                    
                    # Use enhanced voice settings or default
                    if not voice_settings:
                        voice_settings = self.voice_configs['default_prospect']
                    
                    # If ElevenLabs is not available, use emergency fallback
                    if not self.is_enabled:
                        logger.info("ElevenLabs not available, using emergency audio for Roleplay 1.1")
                        return self._generate_emergency_audio(text)
                    
                    # Prepare request
                    voice_id = voice_settings.get('voice_id', self.voice_configs['default_prospect']['voice_id'])
                    url = f"{self.base_url}/text-to-speech/{voice_id}/stream"
                    
                    headers = {
                        "Accept": "audio/mpeg",
                        "Content-Type": "application/json",
                        "xi-api-key": self.api_key
                    }
                    
                    # Enhanced payload for Roleplay 1.1
                    data = {
                        "text": text,
                        "model_id": "eleven_monolingual_v1",
                        "voice_settings": {
                            "stability": voice_settings.get('stability', 0.5),
                            "similarity_boost": voice_settings.get('similarity_boost', 0.75),
                            "style": voice_settings.get('style', 0.0),
                            "use_speaker_boost": voice_settings.get('use_speaker_boost', True)
                        }
                    }
                    
                    logger.info(f"Generating TTS for Roleplay 1.1: {text[:50]}... with voice {voice_id}")
                    
                    # Make request with timeout
                    response = requests.post(url, json=data, headers=headers, timeout=10)
                    
                    if response.status_code == 200:
                        # Convert MP3 to WAV for better compatibility
                        audio_stream = self._convert_mp3_to_wav(response.content)
                        logger.info(f"Successfully generated Roleplay 1.1 TTS audio: {len(response.content)} bytes")
                        return audio_stream
                    else:
                        logger.warning(f"ElevenLabs request failed with status {response.status_code}: {response.text}")
                        return self._generate_emergency_audio(text)
                        
                except requests.exceptions.Timeout:
                    logger.warning("ElevenLabs request timed out, using emergency audio")
                    return self._generate_emergency_audio(text)
                except requests.exceptions.RequestException as e:
                    logger.warning(f"ElevenLabs request failed: {e}, using emergency audio")
                    return self._generate_emergency_audio(text)
                except Exception as e:
                    logger.error(f"Unexpected error in TTS generation: {e}, using emergency audio")
                    return self._generate_emergency_audio(text)
        
            def get_voice_settings_for_prospect(self, prospect_info: Dict) -> Dict:
                """
                Get enhanced voice settings based on prospect information for Roleplay 1.1
                """
                try:
                    job_title = prospect_info.get('prospect_job_title', '').lower()
                    industry = prospect_info.get('prospect_industry', '').lower()
                    roleplay_version = prospect_info.get('roleplay_version', 'standard')
                    call_urgency = prospect_info.get('call_urgency', 'medium')
                    stage = prospect_info.get('stage', 'phone_pickup')
                    
                    # Start with default configuration
                    base_config = self.voice_configs['default_prospect'].copy()
                    
                    # Roleplay 1.1 specific enhancements
                    if roleplay_version == '1.1':
                        # Apply stage-specific voice settings
                        if stage in self.roleplay_11_voice_settings:
                            stage_settings = self.roleplay_11_voice_settings[stage]
                            base_config.update(stage_settings)
                        
                        # Enhanced voice selection for Roleplay 1.1
                        if 'cto' in job_title or 'technical' in job_title:
                            base_config.update(self.voice_configs['cto_tech'])
                        elif 'ceo' in job_title or 'president' in job_title:
                            base_config.update(self.voice_configs['ceo_executive'])
                        elif 'sales' in job_title or 'revenue' in job_title:
                            base_config.update(self.voice_configs['vp_sales'])
                        elif 'director' in job_title or 'manager' in job_title:
                            base_config.update(self.voice_configs['director_operations'])
                        
                        # Adjust based on call urgency
                        if call_urgency == 'high' or stage in ['silence_impatience', 'silence_hangup']:
                            base_config.update(self.voice_configs['impatient_prospect'])
                        elif call_urgency == 'low':
                            base_config.update(self.voice_configs['busy_prospect'])
                    
                    # Industry-specific adjustments
                    if 'technology' in industry or 'tech' in industry:
                        base_config['style'] = min(base_config.get('style', 0) + 0.1, 1.0)
                    elif 'finance' in industry or 'banking' in industry:
                        base_config['stability'] = min(base_config.get('stability', 0.5) + 0.2, 1.0)
                    elif 'healthcare' in industry:
                        base_config['similarity_boost'] = min(base_config.get('similarity_boost', 0.75) + 0.1, 1.0)
                    
                    logger.info(f"Generated voice settings for Roleplay 1.1: {job_title} in {industry}, stage: {stage}")
                    return base_config
                    
                except Exception as e:
                    logger.error(f"Error generating voice settings: {e}")
                    return self.voice_configs['default_prospect']
        
            def _convert_mp3_to_wav(self, mp3_data: bytes) -> io.BytesIO:
                """
                Convert MP3 data to WAV format for better browser compatibility
                Enhanced for Roleplay 1.1 with better error handling
                """
                try:
                    # For now, return MP3 as-is wrapped in BytesIO
                    # In production, you might want to use pydub or similar for actual conversion
                    audio_stream = io.BytesIO(mp3_data)
                    
                    # If we need actual WAV conversion, we could use pydub:
                    # from pydub import AudioSegment
                    # audio = AudioSegment.from_mp3(io.BytesIO(mp3_data))
                    # wav_buffer = io.BytesIO()
                    # audio.export(wav_buffer, format="wav")
                    # wav_buffer.seek(0)
                    # return wav_buffer
                    
                    return audio_stream
                    
                except Exception as e:
                    logger.error(f"Error converting MP3 to WAV: {e}")
                    return self._generate_emergency_audio("Audio conversion failed")
        
            def _generate_silent_audio(self, duration_seconds: float = 0.5) -> io.BytesIO:
                """
                Generate silent audio for empty text - Enhanced for Roleplay 1.1
                """
                try:
                    sample_rate = 44100
                    duration_samples = int(sample_rate * duration_seconds)
                    
                    # Create WAV file in memory
                    audio_buffer = io.BytesIO()
                    
                    with wave.open(audio_buffer, 'wb') as wav_file:
                        wav_file.setnchannels(1)  # Mono
                        wav_file.setsampwidth(2)  # 16-bit
                        wav_file.setframerate(sample_rate)
                        
                        # Generate silence (zeros)
                        silent_frames = b'\x00\x00' * duration_samples
                        wav_file.writeframes(silent_frames)
                    
                    audio_buffer.seek(0)
                    logger.info(f"Generated {duration_seconds}s silent audio for Roleplay 1.1")
                    return audio_buffer
                    
                except Exception as e:
                    logger.error(f"Error generating silent audio: {e}")
                    return self._create_minimal_wav_audio()
        
            def _generate_emergency_audio(self, text: str = None) -> io.BytesIO:
                """
                Generate emergency fallback audio when ElevenLabs fails
                Enhanced for Roleplay 1.1 with better quality
                """
                try:
                    # Calculate appropriate duration based on text length
                    if text:
                        # Approximate speaking rate: 150 words per minute
                        word_count = len(text.split())
                        duration_seconds = max(1.0, min(8.0, (word_count / 150) * 60))
                    else:
                        duration_seconds = 2.0
                    
                    sample_rate = 44100
                    duration_samples = int(sample_rate * duration_seconds)
                    
                    # Create WAV file in memory
                    audio_buffer = io.BytesIO()
                    
                    with wave.open(audio_buffer, 'wb') as wav_file:
                        wav_file.setnchannels(1)  # Mono
                        wav_file.setsampwidth(2)  # 16-bit
                        wav_file.setframerate(sample_rate)
                        
                        # Generate simple tone pattern to indicate speech
                        # This creates a very quiet, low-frequency tone that simulates speech timing
                        frames = []
                        for i in range(duration_samples):
                            # Create a very quiet, variable tone
                            t = i / sample_rate
                            # Multiple sine waves at speech-like frequencies
                            amplitude = 0.1  # Very quiet
                            frequency1 = 200 + (50 * (i % 1000) / 1000)  # Variable frequency
                            frequency2 = 400 + (100 * (i % 2000) / 2000)
                            
                            # Combine frequencies and add some rhythm
                            wave1 = amplitude * 0.5 * (1 + 0.5 * (i % 4410 < 2205))
                            wave2 = amplitude * 0.3 * (1 + 0.3 * (i % 8820 < 4410))
                            
                            sample = int(16384 * (wave1 + wave2))  # 16-bit range
                            frames.append(struct.pack('<h', sample))
                        
                        wav_file.writeframes(b''.join(frames))
                    
                    audio_buffer.seek(0)
                    logger.info(f"Generated {duration_seconds}s emergency audio for Roleplay 1.1")
                    return audio_buffer
                    
                except Exception as e:
                    logger.error(f"Error generating emergency audio: {e}")
                    return self._create_minimal_wav_audio()
        
            def _create_minimal_wav_audio(self) -> io.BytesIO:
                """
                Create minimal WAV audio as absolute last resort
                Enhanced for Roleplay 1.1
                """
                try:
                    # Create a minimal 1-second WAV file
                    sample_rate = 44100
                    duration_samples = sample_rate  # 1 second
                    
                    audio_buffer = io.BytesIO()
                    
                    with wave.open(audio_buffer, 'wb') as wav_file:
                        wav_file.setnchannels(1)  # Mono
                        wav_file.setsampwidth(2)  # 16-bit
                        wav_file.setframerate(sample_rate)
                        
                        # Generate very quiet white noise
                        frames = []
                        for i in range(duration_samples):
                            # Very quiet random noise
                            sample = int(128 * (0.5 - (i % 127) / 254))  # Pseudo-random
                            frames.append(struct.pack('<h', sample))
                        
                        wav_file.writeframes(b''.join(frames))
                    
                    audio_buffer.seek(0)
                    logger.info("Generated minimal WAV audio for Roleplay 1.1")
                    return audio_buffer
                    
                except Exception as e:
                    logger.critical(f"Failed to create minimal WAV audio: {e}")
                    # Return empty BytesIO as absolute last resort
                    return io.BytesIO(b'')
        
            def test_connection(self) -> bool:
                """
                Test ElevenLabs connection with enhanced error handling for Roleplay 1.1
                """
                try:
                    if not self.is_enabled:
                        return False
                    
                    url = f"{self.base_url}/voices"
                    headers = {"xi-api-key": self.api_key}
                    
                    response = requests.get(url, headers=headers, timeout=5)
                    
                    if response.status_code == 200:
                        logger.info("ElevenLabs connection test successful for Roleplay 1.1")
                        return True
                    else:
                        logger.warning(f"ElevenLabs connection test failed: {response.status_code}")
                        return False
                        
                except Exception as e:
                    logger.error(f"ElevenLabs connection test error: {e}")
                    return False
        
            def is_available(self) -> bool:
                """Check if ElevenLabs service is available"""
                return self.is_enabled
        
            def get_status(self) -> Dict[str, Any]:
                """
                Get service status with enhanced information for Roleplay 1.1
                """
                status = {
                    'enabled': self.is_enabled,
                    'api_key_configured': bool(self.api_key),
                    'base_url': self.base_url,
                    'voice_configs_count': len(self.voice_configs),
                    'roleplay_11_enhanced': True,
                    'features': {
                        'stage_specific_voices': True,
                        'prospect_type_matching': True,
                        'emergency_fallback': True,
                        'silence_audio_generation': True,
                        'wav_conversion': True
                    }
                }
                
                if self.is_enabled:
                    # Test connection
                    try:
                        connection_test = self.test_connection()
                        status['connection_status'] = 'connected' if connection_test else 'failed'
                    except:
                        status['connection_status'] = 'unknown'
                else:
                    status['connection_status'] = 'disabled'
                
                return status
        
            def get_available_voices(self) -> List[Dict]:
                """
                Get list of available voices with enhanced descriptions for Roleplay 1.1
                """
                try:
                    if not self.is_enabled:
                        return []
                    
                    url = f"{self.base_url}/voices"
                    headers = {"xi-api-key": self.api_key}
                    
                    response = requests.get(url, headers=headers, timeout=10)
                    
                    if response.status_code == 200:
                        voices_data = response.json()
                        voices = voices_data.get('voices', [])
                        
                        # Enhance voice information for Roleplay 1.1
                        enhanced_voices = []
                        for voice in voices:
                            enhanced_voice = {
                                'voice_id': voice.get('voice_id'),
                                'name': voice.get('name'),
                                'category': voice.get('category'),
                                'description': voice.get('description'),
                                'roleplay_11_suitable': voice.get('voice_id') in [
                                    config['voice_id'] for config in self.voice_configs.values()
                                ]
                            }
                            enhanced_voices.append(enhanced_voice)
                        
                        logger.info(f"Retrieved {len(enhanced_voices)} voices for Roleplay 1.1")
                        return enhanced_voices
                    else:
                        logger.warning(f"Failed to get voices: {response.status_code}")
                        return []
                        
                except Exception as e:
                    logger.error(f"Error getting available voices: {e}")
                    return []
        
            # Utility methods for voice configuration
            
            def get_voice_config_for_stage(self, stage: str) -> Dict:
                """Get voice configuration for specific Roleplay 1.1 stage"""
                if stage in self.roleplay_11_voice_settings:
                    config = self.voice_configs['default_prospect'].copy()
                    config.update(self.roleplay_11_voice_settings[stage])
                    return config
                return self.voice_configs['default_prospect']
        
            def create_custom_voice_config(self, base_voice: str = 'default_prospect', 
                                         stability: float = None, similarity_boost: float = None,
                                         style: float = None) -> Dict:
                """Create custom voice configuration for Roleplay 1.1"""
                config = self.voice_configs.get(base_voice, self.voice_configs['default_prospect']).copy()
                
                if stability is not None:
                    config['stability'] = max(0.0, min(1.0, stability))
                if similarity_boost is not None:
                    config['similarity_boost'] = max(0.0, min(1.0, similarity_boost))
                if style is not None:
                    config['style'] = max(0.0, min(1.0, style))
                
                return config
        
            def validate_voice_settings(self, voice_settings: Dict) -> bool:
                """Validate voice settings for Roleplay 1.1"""
                try:
                    required_fields = ['voice_id', 'stability', 'similarity_boost']
                    for field in required_fields:
                        if field not in voice_settings:
                            return False
                    
                    # Validate ranges
                    if not (0.0 <= voice_settings['stability'] <= 1.0):
                        return False
                    if not (0.0 <= voice_settings['similarity_boost'] <= 1.0):
                        return False
                    if 'style' in voice_settings and not (0.0 <= voice_settings['style'] <= 1.0):
                        return False
                    
                    return True
                    
                except Exception as e:
                    logger.error(f"Error validating voice settings: {e}")
                    return False

  📄 openai_service.py (22.3KB)
      Content:
        # ===== FIXED: services/openai_service.py (OpenAI SDK v1.0+ Compatible) =====
        
        import os
        import json
        import logging
        from typing import Dict, List, Any, Optional
        from datetime import datetime
        
        # Use the modern OpenAI library
        from openai import OpenAI, RateLimitError, APIError, AuthenticationError
        
        logger = logging.getLogger(__name__)
        
        class OpenAIService:
            """Enhanced OpenAI service specifically designed for Roleplay 1.1"""
            
            def __init__(self):
                self.client: Optional[OpenAI] = None
                self.is_configured = False
                self.model = "gpt-4o-mini" # Using a more modern, cost-effective model
                
                try:
                    # Use the same environment variable as the rest of your application
                    api_key = os.getenv('REACT_APP_OPENAI_API_KEY')
                    if api_key:
                        # NEW: Initialize the OpenAI client with the API key
                        self.client = OpenAI(api_key=api_key)
                        self.is_configured = True
                        logger.info(f"âœ… OpenAI service initialized successfully with model: {self.model}")
                    else:
                        logger.warning("âš ï¸ OpenAI API key ('REACT_APP_OPENAI_API_KEY') not found. Service will use fallback methods.")
                except Exception as e:
                    logger.error(f"âŒ Failed to initialize OpenAI: {e}")
            
            def is_available(self) -> bool:
                """Check if OpenAI service is available"""
                return self.is_configured and self.client is not None
            
            def get_status(self) -> Dict[str, Any]:
                """Get service status"""
                return {
                    'available': self.is_available(),
                    'configured': self.is_configured,
                    'model': self.model,
                    'timestamp': datetime.now().isoformat()
                }
            
            def evaluate_user_input(self, user_input: str, conversation_history: List[Dict], evaluation_stage: str) -> Dict[str, Any]:
                """
                Evaluate user input based on Roleplay 1.1 criteria
                Returns detailed evaluation with scoring
                """
                if not self.is_available():
                    return self._fallback_evaluation(user_input, evaluation_stage)
                
                try:
                    # Build context for AI evaluation
                    context = self._build_evaluation_context(conversation_history, evaluation_stage)
                    
                    # Create evaluation prompt
                    prompt = self._create_evaluation_prompt(user_input, context, evaluation_stage)
                    
                    # NEW: Use the updated client.chat.completions.create method
                    response = self.client.chat.completions.create(
                        model=self.model,
                        messages=[
                            {"role": "system", "content": self._get_evaluator_system_prompt()},
                            {"role": "user", "content": prompt}
                        ],
                        temperature=0.3,
                        max_tokens=800
                    )
                    
                    # NEW: Access the response content from the message object
                    result = self._parse_evaluation_response(response.choices[0].message.content)
                    result['source'] = 'openai'
                    result['stage'] = evaluation_stage
                    
                    logger.info(f"âœ… AI evaluation complete: {result.get('score', 0)}/4 for {evaluation_stage}")
                    return result
                    
                except (APIError, RateLimitError, AuthenticationError) as e:
                    logger.error(f"âŒ OpenAI API error during evaluation: {type(e).__name__} - {e}")
                    return self._fallback_evaluation(user_input, evaluation_stage)
                except Exception as e:
                    logger.error(f"âŒ Unexpected error during OpenAI evaluation: {e}")
                    return self._fallback_evaluation(user_input, evaluation_stage)
            
            def generate_roleplay_response(self, user_input: str, conversation_history: List[Dict], 
                                             user_context: Dict, current_stage: str) -> Dict[str, Any]:
                """
                Generate AI prospect response for Roleplay 1.1
                Returns contextual, logical response
                """
                if not self.is_available():
                    return self._fallback_response(current_stage)
                
                try:
                    # Build conversation context
                    context = self._build_conversation_context(conversation_history, user_context, current_stage)
                    
                    # Create response prompt
                    prompt = self._create_response_prompt(user_input, context, current_stage)
                    
                    # NEW: Use the updated client.chat.completions.create method
                    response = self.client.chat.completions.create(
                        model=self.model,
                        messages=[
                            {"role": "system", "content": self._get_prospect_system_prompt(user_context)},
                            {"role": "user", "content": prompt}
                        ],
                        temperature=0.7,
                        max_tokens=150  # Keep responses concise
                    )
                    
                    # NEW: Access the response content from the message object
                    ai_response = response.choices[0].message.content.strip()
                    
                    # Clean up response
                    ai_response = self._clean_ai_response(ai_response)
                    
                    logger.info(f"âœ… AI response generated: '{ai_response[:50]}...'")
                    return {
                        'success': True,
                        'response': ai_response,
                        'stage': current_stage
                    }
                    
                except (APIError, RateLimitError, AuthenticationError) as e:
                    logger.error(f"âŒ OpenAI API error during response generation: {type(e).__name__} - {e}")
                    return self._fallback_response(current_stage)
                except Exception as e:
                    logger.error(f"âŒ Unexpected error during OpenAI response generation: {e}")
                    return self._fallback_response(current_stage)
            
            def generate_coaching_feedback(self, conversation_history: List[Dict], 
                                             rubric_scores: Dict, user_context: Dict) -> Dict[str, Any]:
                """
                Generate detailed coaching feedback for Roleplay 1.1
                """
                if not self.is_available():
                    return self._fallback_coaching(rubric_scores)
                
                try:
                    # Build coaching context
                    context = self._build_coaching_context(conversation_history, rubric_scores, user_context)
                    
                    # Create coaching prompt
                    prompt = self._create_coaching_prompt(context)
                    
                    # NEW: Use the updated client.chat.completions.create method
                    response = self.client.chat.completions.create(
                        model=self.model,
                        messages=[
                            {"role": "system", "content": self._get_coach_system_prompt()},
                            {"role": "user", "content": prompt}
                        ],
                        temperature=0.4,
                        max_tokens=1000
                    )
                    
                    # NEW: Access the response content from the message object
                    result = self._parse_coaching_response(response.choices[0].message.content)
                    result['source'] = 'openai'
                    
                    logger.info(f"âœ… AI coaching generated: Score {result.get('score', 75)}")
                    return result
                    
                except (APIError, RateLimitError, AuthenticationError) as e:
                    logger.error(f"âŒ OpenAI API error during coaching generation: {type(e).__name__} - {e}")
                    return self._fallback_coaching(rubric_scores)
                except Exception as e:
                    logger.error(f"âŒ Unexpected error during OpenAI coaching: {e}")
                    return self._fallback_coaching(rubric_scores)
            
            # ===== SYSTEM PROMPTS (No changes needed) =====
            
            def _get_evaluator_system_prompt(self) -> str:
                """System prompt for evaluation AI"""
                return """You are an expert cold calling coach evaluating sales performance.
        Your role:
        - Evaluate user input against specific criteria for each stage
        - Be objective and constructive
        - Focus on cold calling best practices
        - Consider natural conversation flow
        
        Evaluation criteria for each stage:
        OPENER: Clear introduction, empathy, natural tone, ends with question
        OBJECTION_HANDLING: Acknowledges calmly, brief reframe, forward question
        MINI_PITCH: Short (under 30 words), outcome-focused, natural language
        SOFT_DISCOVERY: Tied to pitch, open-ended question, curious tone
        
        Return evaluation in this format:
        SCORE: X/4
        PASSED: Yes/No
        CRITERIA_MET: [list criteria names that were met]
        FEEDBACK: [specific coaching advice]
        HANG_UP_PROBABILITY: 0.X (0.0-1.0)
        NEXT_ACTION: continue/improve"""
            
            def _get_prospect_system_prompt(self, user_context: Dict) -> str:
                """System prompt for AI prospect"""
                name = user_context.get('first_name', 'Alex')
                title = user_context.get('prospect_job_title', 'CTO')
                industry = user_context.get('prospect_industry', 'Technology')
                
                return f"""You are {name}, a {title} in the {industry} industry.
        Your personality:
        - Busy professional, mildly skeptical of cold calls
        - Direct but not rude
        - Will listen if approached professionally
        - Appreciates empathy and brevity
        - Responds naturally to good cold calling techniques
        
        Your behavior:
        - Start with mild resistance 
        - Warm up if user shows empathy and professionalism
        - Give clear objections when appropriate
        - Ask clarifying questions if interested
        - Speak naturally and conversationally
        
        Keep responses under 25 words. Be realistic and human-like.
        Never mention you're an AI or break character."""
            
            def _get_coach_system_prompt(self) -> str:
                """System prompt for coaching AI"""
                return """You are an expert cold calling coach providing detailed feedback.
        Your role:
        - Analyze the complete conversation objectively
        - Provide specific, actionable coaching advice
        - Focus on areas for improvement
        - Be encouraging but honest
        - Use simple, clear language
        
        Coaching categories:
        - Sales Performance: Opening, objection handling, conversation flow
        - Grammar & Structure: Sentence construction, clarity
        - Vocabulary: Word choice, professional language
        - Pronunciation: Speaking clearly (inferred from text)
        - Rapport & Confidence: Building connection, assertiveness
        
        Provide specific examples and improvement suggestions for each category."""
            
            # ===== PROMPT BUILDERS (No changes needed) =====
            
            def _create_evaluation_prompt(self, user_input: str, context: str, stage: str) -> str:
                """Create evaluation prompt"""
                return f"""Evaluate this cold call input for the {stage.upper()} stage:
        
        CONTEXT:
        {context}
        
        USER INPUT: "{user_input}"
        
        STAGE: {stage}
        
        Please evaluate based on the criteria for this stage and return your assessment."""
            
            def _create_response_prompt(self, user_input: str, context: str, stage: str) -> str:
                """Create response generation prompt"""
                return f"""Generate a realistic prospect response to this cold call:
        
        CONVERSATION CONTEXT:
        {context}
        
        CURRENT STAGE: {stage}
        USER JUST SAID: "{user_input}"
        
        Respond as the prospect would naturally. Keep it under 25 words and conversational."""
            
            def _create_coaching_prompt(self, context: str) -> str:
                """Create coaching prompt"""
                return f"""Provide detailed coaching feedback for this cold call:
        
        {context}
        
        Analyze the conversation and provide:
        1. Overall score (0-100)
        2. Specific coaching for each category
        3. What they did well
        4. Areas for improvement
        5. Actionable next steps
        
        Be constructive and specific."""
            
            # ===== CONTEXT BUILDERS (No changes needed) =====
            
            def _build_evaluation_context(self, conversation_history: List[Dict], stage: str) -> str:
                """Build context for evaluation"""
                context = f"EVALUATION STAGE: {stage}\n\n"
                context += "CONVERSATION SO FAR:\n"
                
                for msg in conversation_history[-6:]:  # Last 6 messages for context
                    role = "USER" if msg['role'] == 'user' else "PROSPECT"
                    context += f"{role}: {msg['content']}\n"
                
                return context
            
            def _build_conversation_context(self, conversation_history: List[Dict], 
                                          user_context: Dict, stage: str) -> str:
                """Build context for response generation"""
                context = f"CURRENT STAGE: {stage}\n"
                context += f"PROSPECT: {user_context.get('first_name', 'Alex')} ({user_context.get('prospect_job_title', 'CTO')})\n\n"
                context += "CONVERSATION:\n"
                
                for msg in conversation_history[-8:]:  # More context for better responses
                    role = "CALLER" if msg['role'] == 'user' else "YOU"
                    context += f"{role}: {msg['content']}\n"
                
                return context
            
            def _build_coaching_context(self, conversation_history: List[Dict], 
                                      rubric_scores: Dict, user_context: Dict) -> str:
                """Build context for coaching"""
                context = f"USER PROFILE: {user_context.get('first_name', 'User')}\n"
                context += f"TARGET: {user_context.get('prospect_job_title', 'CTO')} at {user_context.get('prospect_industry', 'Technology')} company\n\n"
                
                context += "CONVERSATION TRANSCRIPT:\n"
                for i, msg in enumerate(conversation_history):
                    role = "USER" if msg['role'] == 'user' else "PROSPECT"
                    context += f"{i+1}. {role}: {msg['content']}\n"
                
                context += f"\nRUBRIC SCORES: {rubric_scores}\n"
                context += f"TOTAL TURNS: {len([m for m in conversation_history if m['role'] == 'user'])}"
                
                return context
            
            # ===== RESPONSE PARSERS (No changes needed) =====
            
            def _parse_evaluation_response(self, response_text: str) -> Dict[str, Any]:
                """Parse AI evaluation response"""
                try:
                    lines = response_text.strip().split('\n')
                    result = {
                        'score': 2,
                        'passed': False,
                        'criteria_met': [],
                        'feedback': 'Basic evaluation completed.',
                        'hang_up_probability': 0.2,
                        'next_action': 'continue'
                    }
                    
                    for line in lines:
                        line = line.strip()
                        if line.startswith('SCORE:'):
                            score_part = line.split(':')[1].strip()
                            if '/' in score_part:
                                result['score'] = int(score_part.split('/')[0])
                            else:
                                result['score'] = int(score_part)
                        elif line.startswith('PASSED:'):
                            result['passed'] = 'yes' in line.lower()
                        elif line.startswith('CRITERIA_MET:'):
                            criteria_text = line.split(':', 1)[1].strip()
                            result['criteria_met'] = [c.strip() for c in criteria_text.split(',') if c.strip()]
                        elif line.startswith('FEEDBACK:'):
                            result['feedback'] = line.split(':', 1)[1].strip()
                        elif line.startswith('HANG_UP_PROBABILITY:'):
                            try:
                                result['hang_up_probability'] = float(line.split(':')[1].strip())
                            except:
                                result['hang_up_probability'] = 0.2
                        elif line.startswith('NEXT_ACTION:'):
                            result['next_action'] = line.split(':')[1].strip()
                    
                    return result
                    
                except Exception as e:
                    logger.error(f"Failed to parse evaluation response: {e}")
                    return {
                        'score': 2,
                        'passed': False,
                        'criteria_met': [],
                        'feedback': 'Evaluation completed.',
                        'hang_up_probability': 0.2,
                        'next_action': 'continue'
                    }
            
            def _parse_coaching_response(self, response_text: str) -> Dict[str, Any]:
                """Parse AI coaching response"""
                try:
                    # Extract overall score
                    score = 75  # default
                    if 'SCORE:' in response_text or 'Score:' in response_text:
                        import re
                        score_match = re.search(r'[Ss]core:?\s*(\d+)', response_text)
                        if score_match:
                            score = int(score_match.group(1))
                    
                    # Split into coaching categories
                    coaching = {
                        'sales_coaching': self._extract_coaching_section(response_text, ['sales', 'performance', 'opening']),
                        'grammar_coaching': self._extract_coaching_section(response_text, ['grammar', 'structure']),
                        'vocabulary_coaching': self._extract_coaching_section(response_text, ['vocabulary', 'word choice']),
                        'pronunciation_coaching': self._extract_coaching_section(response_text, ['pronunciation', 'speaking']),
                        'rapport_assertiveness': self._extract_coaching_section(response_text, ['rapport', 'confidence', 'assertiveness'])
                    }
                    
                    return {
                        'success': True,
                        'score': score,
                        'coaching': coaching
                    }
                    
                except Exception as e:
                    logger.error(f"Failed to parse coaching response: {e}")
                    return self._fallback_coaching({})
            
            def _extract_coaching_section(self, text: str, keywords: List[str]) -> str:
                """Extract coaching section based on keywords"""
                lines = text.split('\n')
                relevant_lines = []
                
                for line in lines:
                    line_lower = line.lower()
                    if any(keyword in line_lower for keyword in keywords):
                        relevant_lines.append(line.strip())
                        # Get next few lines as well
                        line_index = lines.index(line)
                        for i in range(1, 3):
                            if line_index + i < len(lines):
                                next_line = lines[line_index + i].strip()
                                if next_line and not any(k in next_line.lower() for k in ['score', 'category', '###']):
                                    relevant_lines.append(next_line)
                
                if relevant_lines:
                    return ' '.join(relevant_lines)
                
                # Fallback messages
                fallback_messages = {
                    'sales': 'Good effort on your cold calling approach. Focus on being more empathetic in your opener.',
                    'grammar': 'Your grammar and sentence structure were clear and professional.',
                    'vocabulary': 'Good vocabulary choice. Consider using more outcome-focused language.',
                    'pronunciation': 'Speak clearly and at a steady pace for better impact.',
                    'rapport': 'Build more rapport by showing empathy and confidence in your approach.'
                }
                
                for keyword in keywords:
                    if keyword in fallback_messages:
                        return fallback_messages[keyword]
                
                return 'Continue practicing to improve your skills.'
            
            # ===== UTILITY METHODS (No changes needed) =====
            
            def _clean_ai_response(self, response: str) -> str:
                """Clean and format AI response"""
                # Remove common AI artifacts
                response = response.replace('AI:', '').replace('Prospect:', '').strip()
                
                # Remove quotes if the entire response is quoted
                if response.startswith('"') and response.endswith('"'):
                    response = response[1:-1]
                
                # Ensure proper capitalization
                if response and response[0].islower():
                    response = response[0].upper() + response[1:]
                
                # Limit length
                if len(response) > 200:
                    sentences = response.split('. ')
                    response = '. '.join(sentences[:2])
                    if not response.endswith('.'):
                        response += '.'
                
                return response.strip()
            
            # ===== FALLBACK METHODS (No changes needed) =====
            
            def _fallback_evaluation(self, user_input: str, stage: str) -> Dict[str, Any]:
                """Fallback evaluation when OpenAI unavailable"""
                score = len(user_input.split()) // 3  # Basic scoring
                score = min(4, max(1, score))
                
                return {
                    'score': score,
                    'passed': score >= 2,
                    'criteria_met': ['basic_response'],
                    'feedback': f'Basic evaluation for {stage}. Keep practicing!',
                    'hang_up_probability': 0.3 if score <= 1 else 0.1,
                    'next_action': 'continue',
                    'source': 'fallback',
                    'stage': stage
                }
            
            def _fallback_response(self, stage: str) -> Dict[str, Any]:
                """Fallback response when OpenAI unavailable"""
                responses = {
                    'phone_pickup': ['Hello?', 'Yes?'],
                    'opener_evaluation': ["What's this about?", "I'm listening."],
                    'early_objection': ["I'm not interested.", "We don't take cold calls."],
                    'objection_handling': ["Alright, what do you do?", "You have 30 seconds."],
                    'mini_pitch': ["That sounds interesting.", "Tell me more."],
                    'soft_discovery': ["Good question.", "I'd need to think about it."]
                }
                
                import random
                response_list = responses.get(stage, ['I see. Please continue.'])
                
                return {
                    'success': True,

  📄 resend_service.py (14KB)
      Content:
        # ===== FIXED API/SERVICES/RESEND_SERVICE.PY =====
        import resend
        import os
        import random
        import string
        from typing import Optional
        import logging
        
        logger = logging.getLogger(__name__)
        
        class ResendService:
            def __init__(self):
                self.api_key = os.getenv('REACT_APP_RESEND_API_KEY')
                self.from_email = os.getenv('REACT_APP_RESEND_FROM_EMAIL', 'noreply@hpique.nl')
                self.from_name = os.getenv('REACT_APP_RESEND_FROM_NAME', 'Cold Calling Coach')
                
                if not self.api_key:
                    raise ValueError("Resend API key must be provided")
                
                # Set the API key
                resend.api_key = self.api_key
                
                # Log configuration for debugging
                logger.info(f"Resend service initialized:")
                logger.info(f"- API Key present: {'Yes' if self.api_key else 'No'}")
                logger.info(f"- From email: {self.from_email}")
                logger.info(f"- From name: {self.from_name}")
            
            def generate_verification_code(self) -> str:
                """Generate 6-digit verification code"""
                return ''.join(random.choices(string.digits, k=6))
            
            def send_verification_email(self, email: str, code: str, first_name: str = "") -> bool:
                """Send verification email with proper response handling"""
                try:
                    # Log the attempt
                    logger.info(f"Attempting to send verification email to {email}")
                    
                    # Format the from field with both name and email
                    from_field = f"{self.from_name} <{self.from_email}>"
                    
                    params = {
                        "from": from_field,
                        "to": [email],
                        "subject": "Verify your email - Cold Calling Coach",
                        "html": self._get_verification_email_html(code, first_name)
                    }
                    
                    # Log the parameters (without sensitive data)
                    logger.info(f"Email parameters: from={from_field}, to={email}, subject={params['subject']}")
                    
                    # Send the email
                    response = resend.Emails.send(params)
                    
                    # Log the full response for debugging
                    logger.info(f"Resend API response: {response}")
                    
                    # Fixed: Check if response is a dict with 'id' key OR an object with 'id' attribute
                    if self._is_successful_response(response):
                        email_id = response.get('id') if isinstance(response, dict) else getattr(response, 'id', None)
                        logger.info(f"Email sent successfully with ID: {email_id}")
                        return True
                    else:
                        logger.error(f"Email send failed - unexpected response: {response}")
                        return False
                    
                except Exception as e:
                    logger.error(f"Error sending verification email: {e}")
                    logger.error(f"Exception type: {type(e)}")
                    return False
            
            def send_password_reset_email(self, email: str, reset_link: str, first_name: str = "") -> bool:
                """Send password reset email"""
                try:
                    from_field = f"{self.from_name} <{self.from_email}>"
                    
                    params = {
                        "from": from_field,
                        "to": [email],
                        "subject": "Reset your password - Cold Calling Coach",
                        "html": self._get_password_reset_email_html(reset_link, first_name)
                    }
                    
                    response = resend.Emails.send(params)
                    logger.info(f"Password reset email sent to {email}: {response}")
                    
                    return self._is_successful_response(response)
                    
                except Exception as e:
                    logger.error(f"Error sending password reset email: {e}")
                    return False
            
            def send_welcome_email(self, email: str, first_name: str) -> bool:
                """Send welcome email after successful registration"""
                try:
                    from_field = f"{self.from_name} <{self.from_email}>"
                    
                    params = {
                        "from": from_field,
                        "to": [email],
                        "subject": "Welcome to Cold Calling Coach!",
                        "html": self._get_welcome_email_html(first_name)
                    }
                    
                    response = resend.Emails.send(params)
                    logger.info(f"Welcome email sent to {email}: {response}")
                    
                    return self._is_successful_response(response)
                    
                except Exception as e:
                    logger.error(f"Error sending welcome email: {e}")
                    return False
            
            def _is_successful_response(self, response) -> bool:
                """Check if the Resend response indicates success"""
                if not response:
                    return False
                
                # Handle dictionary response (most common)
                if isinstance(response, dict):
                    return 'id' in response and response['id']
                
                # Handle object response (alternative format)
                if hasattr(response, 'id'):
                    return bool(response.id)
                
                # If we can't determine success, log and assume failure
                logger.warning(f"Unknown response format: {type(response)} - {response}")
                return False
            
            def send_test_email(self, to_email: str) -> dict:
                """Send a test email for debugging purposes"""
                try:
                    from_field = f"{self.from_name} <{self.from_email}>"
                    
                    params = {
                        "from": from_field,
                        "to": [to_email],
                        "subject": "Test Email - Cold Calling Coach",
                        "html": "<h1>Test Email</h1><p>If you receive this, Resend is working correctly!</p>"
                    }
                    
                    response = resend.Emails.send(params)
                    
                    if self._is_successful_response(response):
                        return {
                            "success": True,
                            "response": response,
                            "message": "Test email sent successfully"
                        }
                    else:
                        return {
                            "success": False,
                            "response": response,
                            "message": "Test email failed - unexpected response"
                        }
                    
                except Exception as e:
                    return {
                        "success": False,
                        "error": str(e),
                        "message": "Test email failed with exception"
                    }
            
            def _get_verification_email_html(self, code: str, first_name: str) -> str:
                """Get HTML template for verification email"""
                name_greeting = f"Hi {first_name}," if first_name else "Hello,"
                
                return f"""
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Verify Your Email</title>
                </head>
                <body style="font-family: Arial, sans-serif; line-height: 1.6; margin: 0; padding: 20px; background-color: #f4f4f4;">
                    <div style="max-width: 600px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1);">
                        <h1 style="color: #007bff; text-align: center; margin-bottom: 30px;">
                            <span style="font-size: 24px;">ðŸ“ž</span> Cold Calling Coach
                        </h1>
                        
                        <p style="font-size: 16px; color: #333;">{name_greeting}</p>
                        
                        <p style="font-size: 16px; color: #333;">
                            Welcome to Cold Calling Coach! Please verify your email address to complete your registration.
                        </p>
                        
                        <div style="text-align: center; margin: 30px 0;">
                            <div style="font-size: 32px; font-weight: bold; color: #007bff; letter-spacing: 3px; padding: 20px; background-color: #f8f9fa; border-radius: 8px; display: inline-block;">
                                {code}
                            </div>
                        </div>
                        
                        <p style="font-size: 14px; color: #666;">
                            This code will expire in 10 minutes. If you didn't request this verification, please ignore this email.
                        </p>
                        
                        <hr style="border: none; border-top: 1px solid #eee; margin: 30px 0;">
                        
                        <p style="font-size: 12px; color: #999; text-align: center;">
                            Cold Calling Coach - Practice makes perfect!<br>
                            <a href="https://hpique.nl" style="color: #007bff;">Visit our website</a>
                        </p>
                    </div>
                </body>
                </html>
                """
            
            def _get_password_reset_email_html(self, reset_link: str, first_name: str) -> str:
                """Get HTML template for password reset email"""
                name_greeting = f"Hi {first_name}," if first_name else "Hello,"
                
                return f"""
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Reset Your Password</title>
                </head>
                <body style="font-family: Arial, sans-serif; line-height: 1.6; margin: 0; padding: 20px; background-color: #f4f4f4;">
                    <div style="max-width: 600px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1);">
                        <h1 style="color: #007bff; text-align: center; margin-bottom: 30px;">
                            <span style="font-size: 24px;">ðŸ“ž</span> Cold Calling Coach
                        </h1>
                        
                        <p style="font-size: 16px; color: #333;">{name_greeting}</p>
                        
                        <p style="font-size: 16px; color: #333;">
                            We received a request to reset your password. Click the button below to create a new password:
                        </p>
                        
                        <div style="text-align: center; margin: 30px 0;">
                            <a href="{reset_link}" style="display: inline-block; background-color: #007bff; color: white; padding: 15px 30px; text-decoration: none; border-radius: 5px; font-weight: bold;">
                                Reset Password
                            </a>
                        </div>
                        
                        <p style="font-size: 14px; color: #666;">
                            This link will expire in 1 hour. If you didn't request a password reset, please ignore this email.
                        </p>
                        
                        <p style="font-size: 12px; color: #999;">
                            If the button doesn't work, copy and paste this link into your browser:<br>
                            <a href="{reset_link}" style="color: #007bff; word-break: break-all;">{reset_link}</a>
                        </p>
                        
                        <hr style="border: none; border-top: 1px solid #eee; margin: 30px 0;">
                        
                        <p style="font-size: 12px; color: #999; text-align: center;">
                            Cold Calling Coach - Practice makes perfect!<br>
                            <a href="https://hpique.nl" style="color: #007bff;">Visit our website</a>
                        </p>
                    </div>
                </body>
                </html>
                """
            
            def _get_welcome_email_html(self, first_name: str) -> str:
                """Get HTML template for welcome email"""
                return f"""
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Welcome to Cold Calling Coach!</title>
                </head>
                <body style="font-family: Arial, sans-serif; line-height: 1.6; margin: 0; padding: 20px; background-color: #f4f4f4;">
                    <div style="max-width: 600px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1);">
                        <h1 style="color: #007bff; text-align: center; margin-bottom: 30px;">
                            <span style="font-size: 24px;">ðŸ“ž</span> Cold Calling Coach
                        </h1>
                        
                        <p style="font-size: 18px; color: #333;">Hi {first_name},</p>
                        
                        <p style="font-size: 16px; color: #333;">
                            Welcome to Cold Calling Coach! ðŸŽ‰ You're now ready to start improving your English cold calling skills.
                        </p>
                        
                        <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px; margin: 25px 0;">
                            <h3 style="color: #007bff; margin-top: 0;">What's Next?</h3>
                            <ul style="margin-bottom: 0;">
                                <li>Complete your first roleplay: "Opener + Early Objections"</li>
                                <li>Practice with different modes: Practice, Marathon, and Legend</li>
                                <li>Unlock advanced modules as you improve</li>
                                <li>Get personalized coaching feedback after each session</li>
                            </ul>
                        </div>
                        
                        <div style="text-align: center; margin: 30px 0;">
                            <a href="https://hpique.nl/dashboard" style="display: inline-block; background-color: #28a745; color: white; padding: 15px 30px; text-decoration: none; border-radius: 5px; font-weight: bold;">
                                Start Training Now
                            </a>
                        </div>
                        
                        <p style="font-size: 14px; color: #666;">
                            Need help? Reply to this email or visit our support page.
                        </p>
                        
                        <hr style="border: none; border-top: 1px solid #eee; margin: 30px 0;">
                        
                        <p style="font-size: 12px; color: #999; text-align: center;">
                            Cold Calling Coach - Practice makes perfect!<br>
                            <a href="https://hpique.nl" style="color: #007bff;">Visit our website</a>
                        </p>
                    </div>
                </body>
                </html>
                """

  📄 roleplay_engine.py (23.2KB)
      Content:
        # ===== FIXED: services/roleplay_engine.py =====
        
        import logging
        from datetime import datetime, timezone
        from typing import Dict, List, Any, Optional
        import uuid
        
        logger = logging.getLogger(__name__)
        
        class RoleplayEngine:
            """FIXED Roleplay Engine with robust session management and recovery"""
            
            def __init__(self, openai_service=None, supabase_service=None):
                # Store active sessions in memory (primary storage)
                self.active_sessions = {}
                
                # Service dependencies
                self.openai_service = openai_service
                self.supabase_service = supabase_service
                
                # Initialize services if not provided
                if not self.openai_service:
                    try:
                        from .openai_service import OpenAIService
                        self.openai_service = OpenAIService()
                        logger.info("âœ… OpenAI service initialized")
                    except ImportError as e:
                        logger.warning(f"âš ï¸ OpenAI service not available: {e}")
                        self.openai_service = None
                
                if not self.supabase_service:
                    try:
                        from .supabase_client import SupabaseService
                        self.supabase_service = SupabaseService()
                        logger.info("âœ… Supabase service initialized")
                    except ImportError as e:
                        logger.warning(f"âš ï¸ Supabase service not available: {e}")
                        self.supabase_service = None
                
                # Load roleplay implementations
                self.roleplay_implementations = {}
                self._load_roleplay_implementations()
                
                logger.info(f"âœ… RoleplayEngine initialized with {len(self.roleplay_implementations)} roleplay types")
            
            def _load_roleplay_implementations(self):
                """Load all available roleplay implementations"""
                try:
                    # Import the fixed roleplay implementations
                    from .roleplay.roleplay_1_1 import Roleplay11
                    
                    # Initialize with OpenAI service
                    self.roleplay_implementations = {
                        '1.1': Roleplay11(self.openai_service)
                    }
                    
                    # Try to load other roleplays if available
                    try:
                        from .roleplay.roleplay_1_2 import Roleplay12
                        self.roleplay_implementations['1.2'] = Roleplay12(self.openai_service)
                        logger.info("âœ… Loaded Roleplay 1.2")
                    except ImportError:
                        logger.info("â„¹ï¸ Roleplay 1.2 not available")
                    
                    try:
                        from .roleplay.roleplay_1_3 import Roleplay13
                        self.roleplay_implementations['1.3'] = Roleplay13(self.openai_service)
                        logger.info("âœ… Loaded Roleplay 1.3")
                    except ImportError:
                        logger.info("â„¹ï¸ Roleplay 1.3 not available")
                    
                    logger.info(f"âœ… Loaded roleplay implementations: {list(self.roleplay_implementations.keys())}")
                    
                except ImportError as e:
                    logger.error(f"âŒ Failed to load roleplay implementations: {e}")
                    # Create minimal fallback
                    self.roleplay_implementations = {
                        '1.1': self._create_fallback_roleplay('1.1')
                    }
                    logger.warning("âš ï¸ Using fallback roleplay implementation")
            
            def _create_fallback_roleplay(self, roleplay_id: str):
                """Create a minimal fallback roleplay implementation"""
                class FallbackRoleplay:
                    def __init__(self, roleplay_id):
                        self.roleplay_id = roleplay_id
                        self.active_sessions = {}
                        logger.warning(f"âš ï¸ Using fallback implementation for {roleplay_id}")
                    
                    def get_roleplay_info(self):
                        return {
                            'id': roleplay_id,
                            'name': f'Roleplay {roleplay_id}',
                            'description': 'Basic roleplay training (fallback mode)',
                            'type': 'practice',
                            'features': {'ai_evaluation': False, 'basic_coaching': True}
                        }
                    
                    def create_session(self, user_id, mode, user_context):
                        session_id = f"{user_id}_{roleplay_id}_{int(datetime.now().timestamp())}"
                        session_data = {
                            'session_id': session_id,
                            'user_id': user_id,
                            'roleplay_id': roleplay_id,
                            'mode': mode,
                            'started_at': datetime.now(timezone.utc).isoformat(),
                            'conversation_history': [],
                            'current_stage': 'phone_pickup',
                            'session_active': True,
                            'turn_count': 0,
                            'user_context': user_context
                        }
                        self.active_sessions[session_id] = session_data
                        
                        return {
                            'success': True,
                            'session_id': session_id,
                            'initial_response': 'Hello?'
                        }
                    
                    def process_user_input(self, session_id, user_input):
                        if session_id not in self.active_sessions:
                            return {'success': False, 'error': 'Session not found'}
                        
                        session = self.active_sessions[session_id]
                        session['turn_count'] += 1
                        
                        # Very basic logic - continue for a few turns then end
                        if session['turn_count'] < 5:
                            return {
                                'success': True,
                                'ai_response': 'I see. Please continue.',
                                'call_continues': True,
                                'evaluation': {'score': 2, 'passed': True}
                            }
                        else:
                            return {
                                'success': True,
                                'ai_response': 'Thank you for calling.',
                                'call_continues': False,
                                'evaluation': {'score': 2, 'passed': True}
                            }
                    
                    def end_session(self, session_id, forced_end=False):
                        session_data = self.active_sessions.pop(session_id, {})
                        return {
                            'success': True,
                            'duration_minutes': 2,
                            'session_success': True,
                            'coaching': {'overall': 'Good practice session! (Fallback mode)'},
                            'overall_score': 75,
                            'session_data': session_data
                        }
                
                return FallbackRoleplay(roleplay_id)
            
            def get_available_roleplays(self) -> List[str]:
                """Get list of available roleplay IDs"""
                return list(self.roleplay_implementations.keys())
            
            def get_roleplay_info(self, roleplay_id: str) -> Dict[str, Any]:
                """Get information about a specific roleplay"""
                try:
                    if roleplay_id not in self.roleplay_implementations:
                        return {'error': f'Roleplay {roleplay_id} not found'}
                    
                    implementation = self.roleplay_implementations[roleplay_id]
                    info = implementation.get_roleplay_info()
                    logger.info(f"âœ… Retrieved info for roleplay {roleplay_id}")
                    return info
                    
                except Exception as e:
                    logger.error(f"âŒ Error getting roleplay info for {roleplay_id}: {e}")
                    return {
                        'error': str(e),
                        'id': roleplay_id,
                        'name': f'Roleplay {roleplay_id}',
                        'description': 'Information unavailable'
                    }
            
            def create_session(self, user_id: str, roleplay_id: str, mode: str, user_context: Dict) -> Dict[str, Any]:
                """FIXED: Create roleplay session with serializable data"""
                try:
                    # Validate inputs
                    
                    if not user_id or not roleplay_id:
                        return {'success': False, 'error': 'Missing required parameters'}
                    
                    if roleplay_id not in self.roleplay_implementations:
                        return {'success': False, 'error': f'Roleplay {roleplay_id} not available'}
                    
                    logger.info(f"Ã°Å¸Å¡â‚¬ Creating session: {roleplay_id} for user {user_id} (mode: {mode})")
                    
                    self._cleanup_user_sessions(user_id)
                    
                    implementation = self.roleplay_implementations[roleplay_id]
                    session_result = implementation.create_session(user_id, mode, user_context)
                    
                    if not session_result.get('success'):
                        logger.error(f"Ã¢ Å’ Implementation failed to create session: {session_result}")
                        return session_result
                    
                    session_id = session_result['session_id']
                    session_data = implementation.active_sessions.get(session_id)
                    
                    if session_data:
                        # CRITICAL FIX: Store the roleplay_id string, not the implementation object
                        self.active_sessions[session_id] = {
                            'implementation_id': roleplay_id, # STORE ID, NOT OBJECT
                            'session_data': session_data,
                            'created_at': datetime.now(timezone.utc).isoformat(),
                            'last_activity': datetime.now(timezone.utc).isoformat(),
                            'user_id': user_id,
                            'roleplay_id': roleplay_id
                        }
                        logger.info(f"Ã¢Å“â€¦ Session {session_id} created and stored successfully")
                        self._persist_session_to_database(session_id, user_id, self.active_sessions[session_id])
                    
                    return session_result
                    
                except Exception as e:
                    logger.error(f"Ã¢ Å’ Error creating roleplay session: {e}", exc_info=True)
                    return {'success': False, 'error': f'Failed to create session: {str(e)}'}
            
            def process_user_input(self, session_id: str, user_input: str) -> Dict[str, Any]:
                """FIXED: Process user input using implementation_id"""
                try:
                    # Validate inputs
                    if not session_id or not user_input:
                        return {'success': False, 'error': 'Missing required parameters'}
                    
                    logger.info(f"ðŸ’¬ Processing input for session {session_id}: '{user_input[:50]}...'")
                    
                    # Get session with recovery
                    session_info = self._get_session_with_recovery(session_id)
                    if not session_info:
                        logger.error(f"âŒ Session {session_id} not found in any storage location")
                        return {'success': False, 'error': 'Session not found or expired'}
                    
                    implementation_id = session_info['implementation_id']
                    implementation = self.roleplay_implementations[implementation_id]
                    
                    # Update last activity
                    self._update_session_activity(session_id)
                    
                    # Validate session belongs to user (if user info available)
                    session_data = session_info['session_data']
                    
                    # Check if session is still active
                    if not session_data.get('session_active', True):
                        logger.error(f"âŒ Session {session_id} is no longer active")
                        return {'success': False, 'error': 'Session has ended'}
                    
                    # Process input through implementation
                    try:
                        result = implementation.process_user_input(session_id, user_input)
                        logger.info(f"âœ… Input processed: call_continues={result.get('call_continues', False)}")
                    except Exception as processing_error:
                        logger.error(f"âŒ Implementation processing error: {processing_error}")
                        return {'success': False, 'error': f'Processing failed: {str(processing_error)}'}
                    
                    if result.get('success'):
                        # Update session data in engine
                        updated_session_data = implementation.active_sessions.get(session_id)
                        if updated_session_data and session_id in self.active_sessions:
                            self.active_sessions[session_id]['session_data'] = updated_session_data
                            self.active_sessions[session_id]['last_activity'] = datetime.now(timezone.utc).isoformat()
                        
                        logger.info(f"âœ… Input processed successfully for session {session_id}")
                    
                    return result
                    
                except Exception as e:
                    logger.error(f"âŒ Error processing user input: {e}")
                    return {'success': False, 'error': f'Processing failed: {str(e)}'}
            
            def end_session(self, session_id: str, forced_end: bool = False) -> Dict[str, Any]:
                """FIXED: End session using implementation_id"""
                try:
                    logger.info(f"Ã°Å¸â€œÅ¾ Ending session {session_id} (forced: {forced_end})")
                    
                    session_info = self._get_session_with_recovery(session_id)
                    
                    if session_info:
                        # CRITICAL FIX: Retrieve implementation using its stored ID
                        implementation_id = session_info['implementation_id']
                        implementation = self.roleplay_implementations[implementation_id]
                        
                        result = implementation.end_session(session_id, forced_end)
                        
                        self.active_sessions.pop(session_id, None)
                        self._cleanup_session_from_database(session_id)
                        
                        logger.info(f"Ã¢Å“â€¦ Session {session_id} ended successfully")
                        return result
                    else:
                        # Session not found, but return success for cleanup
                        logger.warning(f"âš ï¸ Session {session_id} not found for ending")
                        return {
                            'success': True,
                            'duration_minutes': 1,
                            'session_success': False,
                            'coaching': {'error': 'Session not found'},
                            'overall_score': 0,
                            'session_data': {}
                        }
                        
                except Exception as e:
                    logger.error(f"âŒ Error ending session: {e}")
                    return {
                        'success': True,  # Return success to allow cleanup
                        'duration_minutes': 1,
                        'session_success': False,
                        'coaching': {'error': f'Error ending session: {str(e)}'},
                        'overall_score': 0,
                        'session_data': {}
                    }
            
            def get_session_status(self, session_id: str) -> Optional[Dict[str, Any]]:
                """Get current status of a session"""
                try:
                    session_info = self._get_session_with_recovery(session_id)
                    
                    if not session_info:
                        return None
                    
                    session_data = session_info['session_data']
                    
                    return {
                        'session_active': session_data.get('session_active', False),
                        'current_stage': session_data.get('current_stage', 'unknown'),
                        'rubric_scores': session_data.get('rubric_scores', {}),
                        'conversation_length': len(session_data.get('conversation_history', [])),
                        'openai_available': self.is_openai_available(),
                        'user_id': session_data.get('user_id'),
                        'roleplay_id': session_data.get('roleplay_id'),
                        'mode': session_data.get('mode'),
                        'last_activity': session_info.get('last_activity')
                    }
                    
                except Exception as e:
                    logger.error(f"âŒ Error getting session status: {e}")
                    return None
            
            def is_openai_available(self) -> bool:
                """Check if OpenAI service is available"""
                try:
                    return (
                        self.openai_service is not None and 
                        hasattr(self.openai_service, 'is_available') and 
                        self.openai_service.is_available()
                    )
                except Exception:
                    return False
            
            # ===== PRIVATE HELPER METHODS =====
            
            def _get_session_with_recovery(self, session_id: str) -> Optional[Dict[str, Any]]:
                """Get session with automatic recovery if needed"""
                # First check active sessions
                if session_id in self.active_sessions:
                    return self.active_sessions[session_id]
                
                # Try to recover from implementation
                for implementation in self.roleplay_implementations.values():
                    if hasattr(implementation, 'active_sessions') and session_id in implementation.active_sessions:
                        session_data = implementation.active_sessions[session_id]
                        
                        # Restore to engine
                        self.active_sessions[session_id] = {
                            'implementation': implementation,
                            'session_data': session_data,
                            'created_at': session_data.get('started_at'),
                            'last_activity': datetime.now(timezone.utc).isoformat(),
                            'user_id': session_data.get('user_id'),
                            'roleplay_id': session_data.get('roleplay_id'),
                            'recovered_from_implementation': True
                        }
                        
                        logger.info(f"âœ… Session {session_id} recovered from implementation")
                        return self.active_sessions[session_id]
                
                logger.warning(f"âš ï¸ Session {session_id} not found in active storage")
                return None
            
            def _cleanup_user_sessions(self, user_id: str):
                """Clean up existing sessions for a user"""
                try:
                    sessions_to_remove = []
                    
                    for session_id, session_info in self.active_sessions.items():
                        if session_info.get('user_id') == user_id:
                            sessions_to_remove.append(session_id)
                    
                    for session_id in sessions_to_remove:
                        try:
                            logger.info(f"ðŸ§¹ Cleaning up existing session {session_id} for user {user_id}")
                            self.end_session(session_id, forced_end=True)
                        except Exception as cleanup_error:
                            logger.warning(f"âš ï¸ Error cleaning up session {session_id}: {cleanup_error}")
                            # Force remove from memory
                            self.active_sessions.pop(session_id, None)
                    
                    if sessions_to_remove:
                        logger.info(f"âœ… Cleaned up {len(sessions_to_remove)} existing sessions for user {user_id}")
                    
                except Exception as e:
                    logger.error(f"âŒ Error cleaning up user sessions: {e}")
            
            def _update_session_activity(self, session_id: str):
                """Update session last activity timestamp"""
                try:
                    if session_id in self.active_sessions:
                        self.active_sessions[session_id]['last_activity'] = datetime.now(timezone.utc).isoformat()
                    
                    # Update in database if available
                    if self.supabase_service:
                        try:
                            self.supabase_service.update_data_by_id(
                                'active_roleplay_sessions',
                                {'session_id': session_id},
                                {'last_activity': datetime.now(timezone.utc).isoformat()}
                            )
                        except Exception as db_error:
                            logger.warning(f"âš ï¸ Failed to update session activity in database: {db_error}")
                            
                except Exception as e:
                    logger.warning(f"âš ï¸ Error updating session activity: {e}")
            
            def _persist_session_to_database(self, session_id: str, user_id: str, session_data: Dict):
                """Persist session to database for recovery"""
                try:
                    if not self.supabase_service:
                        return
                    
                    db_record = {
                        'session_id': session_id,
                        'user_id': user_id,
                        'session_data': session_data,
                        'created_at': datetime.now(timezone.utc).isoformat(),
                        'last_activity': datetime.now(timezone.utc).isoformat(),
                        'is_active': True
                    }
                    
                    self.supabase_service.upsert_data('active_roleplay_sessions', db_record)
                    logger.info(f"âœ… Session {session_id} persisted to database")
                    
                except Exception as e:
                    logger.warning(f"âš ï¸ Failed to persist session to database: {e}")
            
            def _cleanup_session_from_database(self, session_id: str):
                """Clean up session from database"""
                try:
                    if not self.supabase_service:
                        return
                    
                    self.supabase_service.update_data_by_id(
                        'active_roleplay_sessions',
                        {'session_id': session_id},
                        {
                            'is_active': False,
                            'ended_at': datetime.now(timezone.utc).isoformat()
                        }
                    )
                    
                    logger.info(f"âœ… Session {session_id} marked as inactive in database")
                    
                except Exception as e:
                    logger.warning(f"âš ï¸ Failed to cleanup session from database: {e}")
            
            def cleanup_old_sessions(self, max_age_hours: int = 24):
                """Clean up old/abandoned sessions"""
                try:
                    cutoff_time = datetime.now(timezone.utc).timestamp() - (max_age_hours * 3600)
                    sessions_to_remove = []
                    
                    for session_id, session_info in self.active_sessions.items():
                        last_activity_str = session_info.get('last_activity')
                        if last_activity_str:
                            try:
                                last_activity = datetime.fromisoformat(last_activity_str.replace('Z', '+00:00'))
                                if last_activity.timestamp() < cutoff_time:
                                    sessions_to_remove.append(session_id)
                            except Exception as parse_error:
                                logger.warning(f"âš ï¸ Error parsing last_activity for session {session_id}: {parse_error}")
                                sessions_to_remove.append(session_id)  # Remove sessions with bad timestamps
                    
                    for session_id in sessions_to_remove:
                        try:
                            self.end_session(session_id, forced_end=True)
                            logger.info(f"âœ… Cleaned up old session: {session_id}")
                        except Exception as cleanup_error:
                            logger.warning(f"âš ï¸ Error cleaning up old session {session_id}: {cleanup_error}")
                    
                    if sessions_to_remove:
                        logger.info(f"âœ… Cleaned up {len(sessions_to_remove)} old sessions")
                    
                    return len(sessions_to_remove)
                    
                except Exception as e:
                    logger.error(f"âŒ Error cleaning up old sessions: {e}")

  📄 supabase_client.py (15.3KB)
      Content:
        # ===== UPDATED API/SERVICES/SUPABASE_CLIENT.PY (FIXED) =====
        from supabase import create_client, Client
        import os
        from typing import Optional, Dict, Any, List, Union
        import logging
        import json
        
        logger = logging.getLogger(__name__)
        
        class SupabaseService:
            _instance = None
            
            def __new__(cls):
                if cls._instance is None:
                    cls._instance = super(SupabaseService, cls).__new__(cls)
                    cls._instance._initialized = False
                return cls._instance
            
            def __init__(self):
                if not self._initialized:
                    self.url = os.getenv('REACT_APP_SUPABASE_URL')
                    self.anon_key = os.getenv('REACT_APP_SUPABASE_ANON_KEY')
                    self.service_key = os.getenv('SUPABASE_SERVICE_ROLE_KEY')  # Add this to your .env
                    
                    if not self.url or not self.anon_key:
                        raise ValueError("Supabase URL and anon key must be provided")
                    
                    # Client for user operations (with RLS)
                    self.client: Client = create_client(self.url, self.anon_key)
                    
                    # Service client for admin operations (bypasses RLS)
                    if self.service_key:
                        self.service_client: Client = create_client(self.url, self.service_key)
                    else:
                        logger.warning("Service role key not provided - using anon key for all operations")
                        self.service_client = self.client
                    
                    self._initialized = True
            
            def get_client(self) -> Client:
                """Get client for user operations"""
                return self.client
            
            def get_service_client(self) -> Client:
                """Get client for admin operations that bypass RLS"""
                return self.service_client
            
            def authenticate_user(self, token: str) -> Optional[Dict[str, Any]]:
                """Verify JWT token and return user"""
                try:
                    # Create a temporary client with the user's token to verify it
                    temp_client = create_client(self.url, self.anon_key)
                    user = temp_client.auth.get_user(token)
                    
                    if user and user.user:
                        return user.user
                    else:
                        logger.warning("Invalid token or no user found")
                except Exception as e:
                    logger.error(f"Auth error: {e}")
                    return None
            def get_user_profile_by_service(self, user_id: str) -> Optional[Dict[str, Any]]:
                """Get user profile using service client (bypasses RLS)"""
                try:
                    response = self.service_client.table('user_profiles').select('*').eq('id', user_id).execute()
                    
                    if response.data and len(response.data) > 0:
                        logger.info(f"Profile found for user_id: {user_id}")
                        return response.data[0]
                    else:
                        logger.warning(f"No profile found for user_id: {user_id}")
                        return None
                        
                except Exception as e:
                    logger.error(f"Error getting user profile for {user_id}: {e}")
                    return None
                
            
            def get_user_profile(self, user_id: str, access_token: str = None) -> Optional[Dict[str, Any]]:
                """Get user profile by ID with enhanced error handling"""
                try:
                    # If we have an access token, create an authenticated client
                    if access_token:
                        try:
                            # Create a new client instance with the user's token
                            auth_client = create_client(self.url, self.anon_key)
                            auth_client.auth.set_session(access_token, "")
                            response = auth_client.table('user_profiles').select('*').eq('id', user_id).execute()
                        except Exception as auth_error:
                            logger.warning(f"Failed to use authenticated client: {auth_error}, falling back to service client")
                            # Fall back to service client if auth client fails
                            response = self.service_client.table('user_profiles').select('*').eq('id', user_id).execute()
                    else:
                        # Use service client for non-authenticated requests
                        response = self.service_client.table('user_profiles').select('*').eq('id', user_id).execute()
                    
                    if response.data and len(response.data) > 0:
                        return response.data[0]
                    else:
                        logger.warning(f"No profile found for user_id: {user_id}")
                        return None
                        
                except Exception as e:
                    logger.error(f"Error getting user profile for {user_id}: {e}")
                    return None
            
            def get_user_profile_by_service(self, user_id: str) -> Optional[Dict[str, Any]]:
                """Get user profile using service client (bypasses RLS)"""
                try:
                    response = self.service_client.table('user_profiles').select('*').eq('id', user_id).execute()
                    
                    if response.data and len(response.data) > 0:
                        logger.info(f"Profile found for user_id: {user_id}")
                        return response.data[0]
                    else:
                        logger.warning(f"No profile found for user_id: {user_id}")
                        return None
                        
                except Exception as e:
                    logger.error(f"Error getting user profile for {user_id}: {e}")
                    return None
            
            def create_user_profile(self, profile_data: Dict[str, Any]) -> bool:
                """Create new user profile using service client to bypass RLS"""
                try:
                    # Use service client to bypass RLS during registration
                    response = self.service_client.table('user_profiles').insert(profile_data).execute()
                    
                    if response.data:
                        logger.info(f"User profile created successfully for user {profile_data.get('id')}")
                        return True
                    else:
                        logger.error(f"Failed to create user profile - no data returned")
                        return False
                        
                except Exception as e:
                    logger.error(f"Error creating user profile: {e}")
                    return False
            
            def update_user_profile(self, user_id: str, updates: Dict[str, Any]) -> bool:
                """Update user profile"""
                try:
                    updates['updated_at'] = 'NOW()'
                    response = self.client.table('user_profiles').update(updates).eq('id', user_id).execute()
                    return bool(response.data)
                except Exception as e:
                    logger.error(f"Error updating user profile: {e}")
                    return False
            
            def get_user_progress(self, user_id: str) -> list:
                """Get all user progress records"""
                try:
                    response = self.client.table('user_progress').select('*').eq('user_id', user_id).execute()
                    return response.data or []
                except Exception as e:
                    logger.error(f"Error getting user progress: {e}")
                    return []
            
            def update_user_progress(self, user_id: str, roleplay_id: int, updates: Dict[str, Any]) -> bool:
                """Update or create user progress for specific roleplay"""
                try:
                    # Use service client for initial progress creation
                    client_to_use = self.service_client
                    
                    # Try to update existing record
                    response = client_to_use.table('user_progress').update(updates).eq('user_id', user_id).eq('roleplay_id', roleplay_id).execute()
                    
                    if not response.data:
                        # Create new record if it doesn't exist
                        progress_data = {
                            'user_id': user_id,
                            'roleplay_id': roleplay_id,
                            **updates
                        }
                        response = client_to_use.table('user_progress').insert(progress_data).execute()
                    
                    return bool(response.data)
                except Exception as e:
                    logger.error(f"Error updating user progress: {e}")
                    return False
            
            def create_verification_code(self, email: str, code: str) -> bool:
                """Create verification code (legacy method)"""
                return self.create_verification_code_with_data(email, code, {})
            
            def create_verification_code_with_data(self, email: str, code: str, user_data: Dict[str, Any]) -> bool:
                """Create verification code with associated user data"""
                try:
                    data = {
                        'email': email,
                        'code': code,
                        'user_data': json.dumps(user_data)  # Store user data as JSON
                    }
                    # Use service client to ensure insertion works
                    response = self.service_client.table('verification_codes').insert(data).execute()
                    
                    if response.data:
                        logger.info(f"Verification code created for {email}")
                        return True
                    else:
                        logger.error("Failed to create verification code - no data returned")
                        return False
                        
                except Exception as e:
                    logger.error(f"Error creating verification code: {e}")
                    return False
            
            def verify_code(self, email: str, code: str) -> bool:
                """Verify email code (legacy method)"""
                user_data = self.verify_code_and_get_data(email, code)
                return user_data is not None
            
            def verify_code_and_get_data(self, email: str, code: str) -> Optional[Dict[str, Any]]:
                """Verify email code and return associated user data"""
                try:
                    # Check if code exists and is not expired (using service client to ensure access)
                    response = self.service_client.table('verification_codes')\
                        .select('*')\
                        .eq('email', email)\
                        .eq('code', code)\
                        .eq('used', False)\
                        .gt('expires_at', 'NOW()')\
                        .execute()
                    
                    if response.data:
                        verification_record = response.data[0]
                        
                        # Mark code as used
                        self.service_client.table('verification_codes')\
                            .update({'used': True})\
                            .eq('id', verification_record['id'])\
                            .execute()
                        
                        # Extract user data
                        user_data_json = verification_record.get('user_data', '{}')
                        try:
                            user_data = json.loads(user_data_json) if user_data_json else {}
                            logger.info(f"Verification code verified for {email}")
                            return user_data
                        except json.JSONDecodeError:
                            logger.error(f"Failed to parse user_data JSON: {user_data_json}")
                            return {}
                    
                    logger.warning(f"Invalid or expired verification code for {email}")
                    return None
                    
                except Exception as e:
                    logger.error(f"Error verifying code: {e}")
                    return None
                
            def upsert_data(self, table_name: str, data: Union[Dict, List[Dict]]) -> Optional[List[Dict]]:
                """Upsert data into a table using the service client."""
                try:
                    response = self.service_client.table(table_name).upsert(data).execute()
                    if response.data:
                        logger.info(f"Upsert successful for table '{table_name}'")
                        return response.data
                    else:
                        logger.warning(f"Upsert to '{table_name}' returned no data.")
                        return None
                except Exception as e:
                    logger.error(f"Error upserting data to '{table_name}': {e}")
                    return None
        
            def get_data_with_filter(self, table_name: str, filter_column: str, filter_value: Any, additional_filters: Dict = None, limit: int = None, order_by: str = None, ascending: bool = True) -> List[Dict[str, Any]]:
                """Get data from a table with filters using the service client."""
                try:
                    query = self.service_client.table(table_name).select('*').eq(filter_column, filter_value)
                    if additional_filters:
                        for col, val in additional_filters.items():
                            query = query.eq(col, val)
                    if order_by:
                        query = query.order(order_by, desc=not ascending)
                    if limit:
                        query = query.limit(limit)
                    
                    response = query.execute()
                    return response.data or []
                except Exception as e:
                    logger.error(f"Error getting data from '{table_name}': {e}")
                    return []
        
            def insert_data(self, table_name: str, data: Dict) -> Optional[Dict[str, Any]]:
                """Insert a single record into a table using the service client."""
                try:
                    response = self.service_client.table(table_name).insert(data).execute()
                    if response.data:
                        logger.info(f"Insert successful for table '{table_name}'")
                        return response.data[0]
                    return None
                except Exception as e:
                    logger.error(f"Error inserting data into '{table_name}': {e}")
                    return None
        
            def update_data_by_id(self, table_name: str, id_filter: Dict, updates: Dict) -> bool:
                """Update data in a table based on a filter using the service client."""
                try:
                    query = self.service_client.table(table_name).update(updates)
                    for col, val in id_filter.items():
                        query = query.eq(col, val)
                    response = query.execute()
                    return len(response.data) > 0
                except Exception as e:
                    logger.error(f"Error updating data in '{table_name}': {e}")
                    return False
            def get_user_sessions(self, user_id: str, limit: int = 20, offset: int = 0) -> List[Dict[str, Any]]:
                """Get user's voice sessions"""
                try:
                    response = self.service_client.table('voice_sessions')\
                        .select('*')\
                        .eq('user_id', user_id)\
                        .order('created_at', desc=True)\
                        .range(offset, offset + limit - 1)\
                        .execute()
                    return response.data or []
                except Exception as e:
                    logger.error(f"Error getting user sessions: {e}")
                    return []
        
            def get_session_count(self, user_id: str) -> int:
                """Get total session count for user"""
                try:
                    response = self.service_client.table('voice_sessions')\
                        .select('id', count='exact')\
                        .eq('user_id', user_id)\
                        .execute()
                    return response.count or 0
                except Exception as e:
                    logger.error(f"Error getting session count: {e}")
                    return 0
        
            def update_user_profile_by_service(self, user_id: str, updates: Dict[str, Any]) -> bool:
                """Update user profile using service client (bypasses RLS)"""
                try:
                    from datetime import datetime, timezone
                    # Add updated timestamp
                    updates['updated_at'] = datetime.now(timezone.utc).isoformat()
                    
                    response = self.service_client.table('user_profiles').update(updates).eq('id', user_id).execute()
                    return len(response.data) > 0
                except Exception as e:
                    logger.error(f"Error updating user profile by service: {e}")
                    return False

  📄 user_progress_service.py (26.6KB)
      Content:
        # ===== services/user_progress_service.py =====
        
        import logging
        from datetime import datetime, timezone
        from typing import Dict, List, Any, Optional
        import json
        
        logger = logging.getLogger(__name__)
        
        class UserProgressService:
            """Service for managing user roleplay progress and achievements"""
            
            def __init__(self, supabase_service=None):
                if supabase_service:
                    self.supabase = supabase_service
                else:
                    # Import here to avoid circular imports
                    try:
                        from .supabase_client import SupabaseService
                        self.supabase = SupabaseService()
                    except ImportError as e:
                        logger.error(f"Failed to import SupabaseService: {e}")
                        self.supabase = None
                
                # Roleplay progression rules
                self.progression_rules = {
                    '1.1': {
                        'name': 'Practice Mode',
                        'unlocks': [],
                        'required_for': ['1.2'],
                        'always_available': True
                    },
                    '1.2': {
                        'name': 'Marathon Mode', 
                        'unlocks': ['1.3'],
                        'required_for': ['2.1'],
                        'requires_completion': False,
                        'requires_pass': False
                    },
                    '1.3': {
                        'name': 'Legend Mode',
                        'unlocks': ['2.1', '2.2'],
                        'required_for': [],
                        'requires_completion': '1.2',
                        'requires_pass': True
                    },
                    '2.1': {
                        'name': 'Advanced Practice',
                        'unlocks': ['2.2'],
                        'required_for': [],
                        'requires_completion': '1.3',
                        'requires_pass': True
                    },
                    '2.2': {
                        'name': 'Advanced Marathon',
                        'unlocks': [],
                        'required_for': [],
                        'requires_completion': '2.1',
                        'requires_pass': True
                    }
                }
                
                logger.info("UserProgressService initialized")
            
            def check_roleplay_access(self, user_id: str, roleplay_id: str) -> Dict[str, Any]:
                """Check if user has access to a specific roleplay"""
                try:
                    if not self.supabase:
                        return {'allowed': True, 'reason': 'Service unavailable'}
                    
                    # Always allow Practice Mode (1.1)
                    if roleplay_id == '1.1':
                        return {'allowed': True, 'reason': 'Always available'}
                    
                    rules = self.progression_rules.get(roleplay_id)
                    if not rules:
                        return {'allowed': False, 'reason': f'Unknown roleplay: {roleplay_id}'}
                    
                    # Check if requires completion of another roleplay
                    if 'requires_completion' in rules:
                        required_roleplay = rules['requires_completion']
                        requires_pass = rules.get('requires_pass', False)
                        
                        progress = self.get_user_roleplay_progress(user_id, [required_roleplay])
                        required_progress = progress.get(required_roleplay)
                        
                        if not required_progress:
                            return {
                                'allowed': False,
                                'reason': f'Must complete {self.progression_rules[required_roleplay]["name"]} first',
                                'requirements': [required_roleplay]
                            }
                        
                        if requires_pass and not required_progress.get('completed'):
                            return {
                                'allowed': False,
                                'reason': f'Must pass {self.progression_rules[required_roleplay]["name"]} first',
                                'requirements': [required_roleplay]
                            }
                    
                    return {'allowed': True, 'reason': 'Access granted'}
                    
                except Exception as e:
                    logger.error(f"Error checking roleplay access: {e}")
                    return {'allowed': True, 'reason': 'Error checking access'}
            
            def get_user_roleplay_progress(self, user_id: str, roleplay_ids: Optional[List[str]] = None) -> Dict[str, Any]:
                """Get user's progress for specific roleplays or all roleplays"""
                try:
                    if not self.supabase:
                        return {}
                    
                    # Get progress records
                    if roleplay_ids:
                        progress_records = []
                        for roleplay_id in roleplay_ids:
                            records = self.supabase.get_data_with_filter(
                                'user_roleplay_progress',
                                'user_id',
                                user_id,
                                additional_filters={'roleplay_id': roleplay_id}
                            )
                            progress_records.extend(records)
                    else:
                        progress_records = self.supabase.get_data_with_filter(
                            'user_roleplay_progress',
                            'user_id',
                            user_id
                        )
                    
                    # Get recent completions for additional context
                    completions = self.supabase.get_data_with_filter(
                        'roleplay_completions',
                        'user_id',
                        user_id,
                        limit=50,
                        order_by='created_at',
                        ascending=False
                    )
                    
                    # Build progress dictionary
                    progress = {}
                    
                    for record in progress_records:
                        roleplay_id = record['roleplay_id']
                        
                        # Get recent completions for this roleplay
                        roleplay_completions = [c for c in completions if c['roleplay_id'] == roleplay_id]
                        
                        progress[roleplay_id] = {
                            'best_score': record.get('best_score', 0),
                            'total_attempts': record.get('total_attempts', 0),
                            'successful_attempts': record.get('successful_attempts', 0),
                            'marathon_best_run': record.get('marathon_best_run', 0),
                            'marathon_completed': record.get('marathon_completed', False),
                            'marathon_passed': record.get('marathon_passed', False),
                            'legend_streak': record.get('legend_streak', 0),
                            'legend_completed': record.get('legend_completed', False),
                            'is_unlocked': record.get('is_unlocked', True),
                            'first_attempt_at': record.get('first_attempt_at'),
                            'last_attempt_at': record.get('last_attempt_at'),
                            'recent_completions': roleplay_completions[:5],  # Last 5 attempts
                            'completed': self._determine_completion_status(roleplay_id, record, roleplay_completions),
                            'passed': self._determine_pass_status(roleplay_id, record, roleplay_completions)
                        }
                    
                    return progress
                    
                except Exception as e:
                    logger.error(f"Error getting user roleplay progress: {e}")
                    return {}
            
            def _determine_completion_status(self, roleplay_id: str, progress_record: Dict, completions: List[Dict]) -> bool:
                """Determine if user has completed a roleplay based on type"""
                if roleplay_id.endswith('.1'):  # Practice modes
                    return progress_record.get('best_score', 0) >= 70
                elif roleplay_id.endswith('.2'):  # Marathon modes
                    return progress_record.get('marathon_completed', False) and progress_record.get('marathon_passed', False)
                elif roleplay_id.endswith('.3'):  # Legend modes
                    return progress_record.get('legend_completed', False)
                else:
                    return len(completions) > 0 and any(c.get('success', False) for c in completions)
            
            def _determine_pass_status(self, roleplay_id: str, progress_record: Dict, completions: List[Dict]) -> bool:
                """Determine if user has passed a roleplay"""
                if roleplay_id.endswith('.1'):  # Practice modes
                    return progress_record.get('best_score', 0) >= 70
                elif roleplay_id.endswith('.2'):  # Marathon modes
                    return progress_record.get('marathon_passed', False)
                elif roleplay_id.endswith('.3'):  # Legend modes
                    return progress_record.get('legend_completed', False)
                else:
                    return progress_record.get('best_score', 0) >= 70
            
            def log_roleplay_attempt(self, user_id: str, roleplay_id: str, session_id: str) -> bool:
                """Log that a user started a roleplay attempt"""
                try:
                    if not self.supabase:
                        return False
                    
                    # Create or update progress record
                    now = datetime.now(timezone.utc).isoformat()
                    
                    existing_progress = self.supabase.get_data_with_filter(
                        'user_roleplay_progress',
                        'user_id',
                        user_id,
                        additional_filters={'roleplay_id': roleplay_id}
                    )
                    
                    if existing_progress:
                        # Update existing record
                        progress_id = existing_progress[0]['id']
                        updates = {
                            'total_attempts': (existing_progress[0].get('total_attempts', 0) + 1),
                            'last_attempt_at': now,
                            'updated_at': now
                        }
                        
                        if not existing_progress[0].get('first_attempt_at'):
                            updates['first_attempt_at'] = now
                        
                        self.supabase.update_data_by_id('user_roleplay_progress', {'id': progress_id}, updates)
                    else:
                        # Create new progress record
                        self.supabase.insert_data('user_roleplay_progress', {
                            'user_id': user_id,
                            'roleplay_id': roleplay_id,
                            'total_attempts': 1,
                            'first_attempt_at': now,
                            'last_attempt_at': now,
                            'is_unlocked': True,
                            'created_at': now
                        })
                    
                    logger.info(f"Logged roleplay attempt: {user_id} -> {roleplay_id}")
                    return True
                    
                except Exception as e:
                    logger.error(f"Error logging roleplay attempt: {e}")
                    return False
            
            def save_roleplay_completion(self, completion_data: Dict[str, Any]) -> Optional[str]:
                """Save a completed roleplay session to database"""
                try:
                    if not self.supabase:
                        return None
                    
                    # Prepare completion record
                    completion_record = {
                        'user_id': completion_data['user_id'],
                        'session_id': completion_data['session_id'],
                        'roleplay_id': completion_data['roleplay_id'],
                        'mode': completion_data.get('mode', 'practice'),
                        'started_at': completion_data.get('started_at'),
                        'ended_at': completion_data.get('ended_at', datetime.now(timezone.utc).isoformat()),
                        'duration_minutes': completion_data.get('duration_minutes', 1),
                        'success': completion_data.get('success', False),
                        'score': completion_data.get('score', 0),
                        'ai_evaluation': completion_data.get('ai_evaluation'),
                        'coaching_feedback': completion_data.get('coaching_feedback'),
                        'conversation_data': completion_data.get('conversation_data'),
                        'rubric_scores': completion_data.get('rubric_scores'),
                        'marathon_results': completion_data.get('marathon_results'),
                        'forced_end': completion_data.get('forced_end', False),
                        'created_at': datetime.now(timezone.utc).isoformat()
                    }
                    
                    # Insert completion record
                    result = self.supabase.insert_data('roleplay_completions', completion_record)
                    
                    if result:
                        completion_id = result.get('id') if isinstance(result, dict) else str(result)
                        logger.info(f"Saved roleplay completion: {completion_id}")
                        return completion_id
                    
                    return None
                    
                except Exception as e:
                    logger.error(f"Error saving roleplay completion: {e}")
                    return None
            
            def update_user_progress(self, user_id: str, roleplay_id: str, completion_data: Dict[str, Any]) -> Dict[str, Any]:
                """Update user's overall progress based on a completion"""
                try:
                    if not self.supabase:
                        return {'updated': False, 'error': 'Service unavailable'}
                    
                    score = completion_data.get('score', 0)
                    success = completion_data.get('success', False)
                    marathon_results = completion_data.get('marathon_results')
                    
                    # Get existing progress
                    existing_progress = self.supabase.get_data_with_filter(
                        'user_roleplay_progress',
                        'user_id',
                        user_id,
                        additional_filters={'roleplay_id': roleplay_id}
                    )
                    
                    if not existing_progress:
                        # Create initial progress record
                        progress_data = {
                            'user_id': user_id,
                            'roleplay_id': roleplay_id,
                            'best_score': score,
                            'total_attempts': 1,
                            'successful_attempts': 1 if success else 0,
                            'is_unlocked': True,
                            'first_attempt_at': completion_data.get('started_at'),
                            'last_attempt_at': completion_data.get('ended_at'),
                            'created_at': datetime.now(timezone.utc).isoformat()
                        }
                        
                        # Handle mode-specific data
                        if roleplay_id.endswith('.2') and marathon_results:  # Marathon mode
                            progress_data.update({
                                'marathon_best_run': marathon_results.get('calls_passed', 0),
                                'marathon_completed': marathon_results.get('marathon_complete', False),
                                'marathon_passed': marathon_results.get('marathon_passed', False)
                            })
                        elif roleplay_id.endswith('.3'):  # Legend mode
                            progress_data.update({
                                'legend_streak': score // 10,  # Simplified calculation
                                'legend_completed': success
                            })
                        
                        self.supabase.insert_data('user_roleplay_progress', progress_data)
                        
                    else:
                        # Update existing progress
                        current_progress = existing_progress[0]
                        progress_id = current_progress['id']
                        
                        updates = {
                            'last_attempt_at': completion_data.get('ended_at'),
                            'updated_at': datetime.now(timezone.utc).isoformat()
                        }
                        
                        # Update best score if this is better
                        if score > current_progress.get('best_score', 0):
                            updates['best_score'] = score
                        
                        # Update successful attempts
                        if success:
                            updates['successful_attempts'] = current_progress.get('successful_attempts', 0) + 1
                        
                        # Handle mode-specific updates
                        if roleplay_id.endswith('.2') and marathon_results:  # Marathon mode
                            calls_passed = marathon_results.get('calls_passed', 0)
                            if calls_passed > current_progress.get('marathon_best_run', 0):
                                updates['marathon_best_run'] = calls_passed
                            
                            if marathon_results.get('marathon_complete', False):
                                updates['marathon_completed'] = True
                                
                            if marathon_results.get('marathon_passed', False):
                                updates['marathon_passed'] = True
                                
                        elif roleplay_id.endswith('.3') and success:  # Legend mode
                            updates['legend_completed'] = True
                            updates['legend_streak'] = max(current_progress.get('legend_streak', 0), score // 10)
                        
                        self.supabase.update_data_by_id('user_roleplay_progress', {'id': progress_id}, updates)
                    
                    logger.info(f"Updated user progress: {user_id} -> {roleplay_id} (score: {score})")
                    
                    return {
                        'updated': True,
                        'best_score': score,
                        'completion_recorded': True
                    }
                    
                except Exception as e:
                    logger.error(f"Error updating user progress: {e}")
                    return {'updated': False, 'error': str(e)}
            
            def check_new_unlocks(self, user_id: str) -> List[str]:
                """Check for new roleplay unlocks based on current progress"""
                try:
                    if not self.supabase:
                        return []
                    
                    unlocked_roleplays = []
                    progress = self.get_user_roleplay_progress(user_id)
                    
                    for roleplay_id, rules in self.progression_rules.items():
                        if 'unlocks' not in rules or not rules['unlocks']:
                            continue
                        
                        # Check if this roleplay was just completed
                        roleplay_progress = progress.get(roleplay_id)
                        if not roleplay_progress or not roleplay_progress.get('completed'):
                            continue
                        
                        # Check what this roleplay unlocks
                        for unlock_id in rules['unlocks']:
                            unlock_progress = progress.get(unlock_id)
                            
                            # If not yet unlocked, add to unlocks list
                            if not unlock_progress or not unlock_progress.get('is_unlocked'):
                                unlocked_roleplays.append(unlock_id)
                                
                                # Update database to mark as unlocked
                                try:
                                    existing = self.supabase.get_data_with_filter(
                                        'user_roleplay_progress',
                                        'user_id',
                                        user_id,
                                        additional_filters={'roleplay_id': unlock_id}
                                    )
                                    
                                    now = datetime.now(timezone.utc).isoformat()
                                    
                                    if existing:
                                        self.supabase.update_data_by_id(
                                            'user_roleplay_progress',
                                            {'id': existing[0]['id']},
                                            {'is_unlocked': True, 'unlocked_at': now, 'updated_at': now}
                                        )
                                    else:
                                        self.supabase.insert_data('user_roleplay_progress', {
                                            'user_id': user_id,
                                            'roleplay_id': unlock_id,
                                            'is_unlocked': True,
                                            'unlocked_at': now,
                                            'created_at': now
                                        })
                                        
                                except Exception as unlock_error:
                                    logger.error(f"Error updating unlock status: {unlock_error}")
                    
                    if unlocked_roleplays:
                        logger.info(f"New unlocks for {user_id}: {unlocked_roleplays}")
                    
                    return unlocked_roleplays
                    
                except Exception as e:
                    logger.error(f"Error checking new unlocks: {e}")
                    return []
            
            def get_available_roleplays(self, user_id: str) -> List[str]:
                """Get list of roleplays available to the user"""
                try:
                    progress = self.get_user_roleplay_progress(user_id)
                    available = []
                    
                    for roleplay_id, rules in self.progression_rules.items():
                        access_check = self.check_roleplay_access(user_id, roleplay_id)
                        if access_check['allowed']:
                            available.append(roleplay_id)
                    
                    return available
                    
                except Exception as e:
                    logger.error(f"Error getting available roleplays: {e}")
                    return ['1.1']  # Always return at least Practice Mode
            
            def get_completion_stats(self, user_id: str) -> Dict[str, Any]:
                """Get user's overall completion statistics"""
                try:
                    if not self.supabase:
                        return {}
                    
                    completions = self.supabase.get_data_with_filter(
                        'roleplay_completions',
                        'user_id',
                        user_id
                    )
                    
                    if not completions:
                        return {
                            'total_sessions': 0,
                            'successful_sessions': 0,
                            'average_score': 0,
                            'total_time_minutes': 0,
                            'completion_rate': 0
                        }
                    
                    total_sessions = len(completions)
                    successful_sessions = len([c for c in completions if c.get('success', False)])
                    scores = [c.get('score', 0) for c in completions if c.get('score', 0) > 0]
                    total_time = sum(c.get('duration_minutes', 0) for c in completions)
                    
                    return {
                        'total_sessions': total_sessions,
                        'successful_sessions': successful_sessions,
                        'average_score': sum(scores) / len(scores) if scores else 0,
                        'best_score': max(scores) if scores else 0,
                        'total_time_minutes': total_time,
                        'completion_rate': (successful_sessions / total_sessions * 100) if total_sessions > 0 else 0,
                        'roleplays_completed': len(set(c['roleplay_id'] for c in completions if c.get('success', False)))
                    }
                    
                except Exception as e:
                    logger.error(f"Error getting completion stats: {e}")
                    return {}
            
            def get_leaderboard(self, roleplay_id: str, limit: int = 10) -> List[Dict[str, Any]]:
                """Get leaderboard for a specific roleplay"""
                try:

  📄 __init__.py (0KB)
      (Empty file)

  📁 roleplay/
    📄 base_roleplay.py (15.4KB)
        Content:
          # ===== FIXED: services/roleplay/base_roleplay.py =====
          
          import logging
          from datetime import datetime, timezone
          from typing import Dict, List, Any, Optional
          import json
          
          logger = logging.getLogger(__name__)
          
          class BaseRoleplay:
              """Enhanced base class for all roleplay implementations"""
              
              def __init__(self, openai_service=None):
                  self.openai_service = openai_service
                  self.active_sessions = {}
                  self.roleplay_id = "base"
                  
                  logger.info(f"BaseRoleplay initialized with OpenAI: {self.is_openai_available()}")
              
              def is_openai_available(self) -> bool:
                  """Check if OpenAI service is available"""
                  return self.openai_service and hasattr(self.openai_service, 'is_available') and self.openai_service.is_available()
              
              def get_roleplay_info(self) -> Dict[str, Any]:
                  """Base roleplay info - should be overridden by subclasses"""
                  return {
                      'id': self.roleplay_id,
                      'name': f'Roleplay {self.roleplay_id}',
                      'description': 'Cold calling training',
                      'type': 'base',
                      'features': {
                          'ai_evaluation': self.is_openai_available(),
                          'basic_coaching': True
                      }
                  }
              
              def create_session(self, user_id: str, mode: str, user_context: Dict) -> Dict[str, Any]:
                  """Create a basic roleplay session"""
                  try:
                      session_id = f"{user_id}_{self.roleplay_id}_{mode}_{int(datetime.now().timestamp())}"
                      
                      session_data = {
                          'session_id': session_id,
                          'user_id': user_id,
                          'roleplay_id': self.roleplay_id,
                          'mode': mode,
                          'started_at': datetime.now(timezone.utc).isoformat(),
                          'user_context': user_context,
                          'conversation_history': [],
                          'current_stage': 'initial',
                          'session_active': True,
                          'turn_count': 0,
                          'overall_quality': 0
                      }
                      
                      # Store session
                      self.active_sessions[session_id] = session_data
                      
                      # Generate initial response
                      initial_response = self._get_basic_initial_response(user_context)
                      
                      # Add to conversation
                      session_data['conversation_history'].append({
                          'role': 'assistant',
                          'content': initial_response,
                          'timestamp': datetime.now(timezone.utc).isoformat(),
                          'stage': 'initial'
                      })
                      
                      logger.info(f"Created base session {session_id}")
                      
                      return {
                          'success': True,
                          'session_id': session_id,
                          'initial_response': initial_response,
                          'roleplay_info': self.get_roleplay_info()
                      }
                      
                  except Exception as e:
                      logger.error(f"Error creating base session: {e}")
                      return {'success': False, 'error': str(e)}
              
              def process_user_input(self, session_id: str, user_input: str) -> Dict[str, Any]:
                  """Process user input - basic implementation"""
                  try:
                      if session_id not in self.active_sessions:
                          raise ValueError("Session not found")
                      
                      session = self.active_sessions[session_id]
                      
                      if not session.get('session_active'):
                          raise ValueError("Session not active")
                      
                      # Increment turn count
                      session['turn_count'] += 1
                      
                      # Add user input to conversation
                      session['conversation_history'].append({
                          'role': 'user',
                          'content': user_input,
                          'timestamp': datetime.now(timezone.utc).isoformat(),
                          'stage': session.get('current_stage', 'conversation')
                      })
                      
                      # Generate AI response
                      ai_response = self._generate_basic_response(session, user_input)
                      
                      # Add AI response to conversation
                      session['conversation_history'].append({
                          'role': 'assistant',
                          'content': ai_response,
                          'timestamp': datetime.now(timezone.utc).isoformat(),
                          'stage': session.get('current_stage', 'conversation')
                      })
                      
                      # Determine if call should continue
                      call_continues = session['turn_count'] < 10  # Simple limit
                      
                      return {
                          'success': True,
                          'ai_response': ai_response,
                          'call_continues': call_continues,
                          'session_state': session.get('current_stage', 'conversation'),
                          'turn_count': session['turn_count']
                      }
                      
                  except Exception as e:
                      logger.error(f"Error processing input: {e}")
                      return {'success': False, 'error': str(e), 'call_continues': False}
              
              def end_session(self, session_id: str, forced_end: bool = False) -> Dict[str, Any]:
                  """End session - basic implementation"""
                  try:
                      if session_id not in self.active_sessions:
                          raise ValueError("Session not found")
                      
                      session = self.active_sessions[session_id]
                      session['session_active'] = False
                      session['ended_at'] = datetime.now(timezone.utc).isoformat()
                      
                      # Calculate duration
                      started_at = datetime.fromisoformat(session['started_at'].replace('Z', '+00:00'))
                      ended_at = datetime.now(timezone.utc)
                      duration_minutes = max(1, int((ended_at - started_at).total_seconds() / 60))
                      
                      # Basic scoring
                      basic_score = min(100, max(30, session['turn_count'] * 10))
                      
                      # Basic coaching
                      basic_coaching = {
                          'opening': 'Good effort on your call opening.',
                          'communication': 'Your communication was clear.',
                          'overall': 'Keep practicing to improve your skills!'
                      }
                      
                      result = {
                          'success': True,
                          'duration_minutes': duration_minutes,
                          'session_success': session['turn_count'] >= 3,
                          'coaching': basic_coaching,
                          'overall_score': basic_score,
                          'session_data': session,
                          'roleplay_type': 'basic'
                      }
                      
                      # Clean up session
                      del self.active_sessions[session_id]
                      
                      return result
                      
                  except Exception as e:
                      logger.error(f"Error ending session: {e}")
                      return {'success': False, 'error': str(e)}
              
              def get_session_status(self, session_id: str) -> Optional[Dict[str, Any]]:
                  """Get session status"""
                  session = self.active_sessions.get(session_id)
                  if session:
                      return {
                          'session_active': session.get('session_active', False),
                          'current_stage': session.get('current_stage', 'unknown'),
                          'conversation_length': len(session.get('conversation_history', [])),
                          'turn_count': session.get('turn_count', 0),
                          'roleplay_type': 'base',
                          'openai_available': self.is_openai_available()
                      }
                  return None
              
              def cleanup_expired_sessions(self):
                  """Clean up old sessions"""
                  try:
                      current_time = datetime.now(timezone.utc)
                      expired_sessions = []
                      
                      for session_id, session_data in self.active_sessions.items():
                          try:
                              started_at = datetime.fromisoformat(session_data['started_at'].replace('Z', '+00:00'))
                              if (current_time - started_at).total_seconds() > 3600:  # 1 hour
                                  expired_sessions.append(session_id)
                          except:
                              expired_sessions.append(session_id)  # Clean up malformed sessions
                      
                      for session_id in expired_sessions:
                          del self.active_sessions[session_id]
                          logger.info(f"Cleaned up expired session: {session_id}")
                          
                  except Exception as e:
                      logger.error(f"Error cleaning up sessions: {e}")
              
              # ===== HELPER METHODS =====
              
              def _get_basic_initial_response(self, user_context: Dict) -> str:
                  """Generate basic initial response"""
                  responses = [
                      "Hello?",
                      "Good morning.",
                      f"{user_context.get('first_name', 'Alex')} speaking.",
                      "Yes, this is Alex.",
                      "Hi there."
                  ]
                  
                  import random
                  return random.choice(responses)
              
              def _generate_basic_response(self, session: Dict, user_input: str) -> str:
                  """Generate basic AI response"""
                  try:
                      # Try using OpenAI if available
                      if self.is_openai_available():
                          response_result = self.openai_service.generate_roleplay_response(
                              user_input,
                              session['conversation_history'],
                              session['user_context'],
                              session.get('current_stage', 'conversation')
                          )
                          
                          if response_result.get('success'):
                              return response_result['response']
                      
                      # Fallback to basic responses
                      return self._get_fallback_response(user_input, session['turn_count'])
                      
                  except Exception as e:
                      logger.error(f"Error generating response: {e}")
                      return self._get_fallback_response(user_input, session['turn_count'])
              
              def _get_fallback_response(self, user_input: str, turn_count: int) -> str:
                  """Get fallback response when AI is unavailable"""
                  import random
                  
                  user_input_lower = user_input.lower()
                  
                  # Early turn responses
                  if turn_count <= 2:
                      if any(word in user_input_lower for word in ['calling from', 'my name', 'hi']):
                          return random.choice([
                              "What's this about?",
                              "I'm listening.",
                              "Go ahead."
                          ])
                      else:
                          return random.choice([
                              "I'm not interested.",
                              "What do you want?"
                          ])
                  
                  # Mid-conversation responses
                  elif turn_count <= 5:
                      if any(word in user_input_lower for word in ['help', 'save', 'improve']):
                          return random.choice([
                              "That sounds interesting. Tell me more.",
                              "How does that work?",
                              "What kind of results do you see?"
                          ])
                      else:
                          return random.choice([
                              "I'm not sure I understand.",
                              "Can you be more specific?",
                              "That's pretty vague."
                          ])
                  
                  # Later conversation responses
                  else:
                      return random.choice([
                          "I'll have to think about it.",
                          "Send me some information.",
                          "I need to discuss this with my team.",
                          "This isn't a priority right now.",
                          "Thanks for calling."
                      ])
              
              def _calculate_basic_quality(self, session: Dict) -> float:
                  """Calculate basic conversation quality"""
                  try:
                      turn_count = session.get('turn_count', 0)
                      conversation_length = len(session.get('conversation_history', []))
                      
                      # Basic quality based on engagement
                      if turn_count >= 6 and conversation_length >= 10:
                          return 75.0
                      elif turn_count >= 4:
                          return 60.0
                      elif turn_count >= 2:
                          return 45.0
                      else:
                          return 30.0
                          
                  except:
                      return 50.0
              
              # ===== SHARED HELPER METHODS FOR SUBCLASSES =====
              
              def _get_contextual_initial_response(self, user_context: Dict) -> str:
                  """Generate contextual initial response"""
                  import random
                  
                  responses = [
                      "Hello?",
                      f"{user_context.get('first_name', 'Alex')} speaking.",
                      "Good morning.",
                      "Yes?",
                      "Hi there."
                  ]
                  
                  return random.choice(responses)
              
              def _get_evaluation_stage(self, current_stage: str) -> str:
                  """Map current stage to evaluation stage"""
                  stage_mapping = {
                      'phone_pickup': 'opener',
                      'opener_evaluation': 'opener',
                      'early_objection': 'objection_handling',
                      'objection_handling': 'objection_handling',
                      'mini_pitch': 'mini_pitch',
                      'soft_discovery': 'soft_discovery',
                      'extended_conversation': 'soft_discovery'
                  }
                  
                  return stage_mapping.get(current_stage, 'opener')
              
              def _apply_weighted_scoring(self, evaluation: Dict, stage: str) -> Dict[str, Any]:
                  """Apply weighted scoring to evaluation results"""
                  try:
                      base_score = evaluation.get('score', 2)
                      
                      # Apply stage-specific weights
                      stage_weights = {
                          'opener': 1.2,
                          'objection_handling': 1.1, 
                          'mini_pitch': 1.0,
                          'soft_discovery': 0.9
                      }
                      
                      weight = stage_weights.get(stage, 1.0)
                      weighted_score = base_score * weight
                      
                      evaluation['weighted_score'] = round(weighted_score, 1)
                      evaluation['weight_applied'] = weight
                      
                      return evaluation
                      
                  except Exception as e:
                      logger.error(f"Error applying weighted scoring: {e}")
                      evaluation['weighted_score'] = evaluation.get('score', 2)
                      return evaluation
              
              def _generate_comprehensive_coaching(self, session: Dict) -> Dict[str, Any]:
                  """Generate comprehensive coaching feedback"""
                  try:
                      if self.is_openai_available():
                          return self.openai_service.generate_coaching_feedback(
                              session.get('conversation_history', []),
                              session.get('rubric_scores', {}),
                              session.get('user_context', {})
                          )
                      else:
                          # Fallback coaching
                          return {
                              'success': True,
                              'coaching': {
                                  'sales_coaching': 'Good effort on your cold calling approach.',
                                  'grammar_coaching': 'Your grammar and structure were clear.',
                                  'vocabulary_coaching': 'Good vocabulary usage.',
                                  'pronunciation_coaching': 'Speak clearly for better impact.',
                                  'rapport_assertiveness': 'Keep building confidence!'
                              }
                          }
                          
                  except Exception as e:
                      logger.error(f"Error generating coaching: {e}")
                      return {
                          'success': False,
                          'coaching': {
                              'error': 'Unable to generate coaching feedback'
                          }
                      }

    📄 roleplay_1_1.py (38.5KB)
        Content:
          # ===== FIXED: services/roleplay/roleplay_1_1.py - PROPER CONVERSATION FLOW =====
          
          import random
          import logging
          from datetime import datetime, timezone
          from typing import Dict, List, Any, Optional
          from .base_roleplay import BaseRoleplay
          from .configs.roleplay_1_1_config import Roleplay11Config
          
          logger = logging.getLogger(__name__)
          
          class Roleplay11(BaseRoleplay):
              """FIXED Roleplay 1.1 - Practice Mode with Proper Conversation Flow"""
              
              def __init__(self, openai_service=None):
                  super().__init__(openai_service)
                  self.config = Roleplay11Config()
                  self.roleplay_id = self.config.ROLEPLAY_ID
                  
                  logger.info(f"Roleplay 1.1 initialized with OpenAI: {self.is_openai_available()}")
                  
              def get_roleplay_info(self) -> Dict[str, Any]:
                  """Return enhanced Roleplay 1.1 configuration"""
                  return {
                      'id': self.config.ROLEPLAY_ID,
                      'name': self.config.NAME,
                      'description': self.config.DESCRIPTION,
                      'type': 'practice',
                      'features': {
                          'ai_evaluation': self.is_openai_available(),
                          'dynamic_scoring': True,
                          'extended_conversation': True,
                          'detailed_coaching': True,
                          'natural_conversation': True,
                          'empathy_scoring': True,
                          'outcome_focused_evaluation': True
                      },
                      'stages': list(self.config.STAGE_FLOW.keys()),
                      'max_turns': self.config.CONVERSATION_LIMITS['max_total_turns'],
                      'scoring_system': 'weighted_criteria'
                  }
              
              def create_session(self, user_id: str, mode: str, user_context: Dict) -> Dict[str, Any]:
                  """Create enhanced Roleplay 1.1 session"""
                  try:
                      session_id = f"{user_id}_{self.config.ROLEPLAY_ID}_{mode}_{int(datetime.now().timestamp())}"
                      
                      session_data = {
                          'session_id': session_id,
                          'user_id': user_id,
                          'roleplay_id': self.config.ROLEPLAY_ID,
                          'mode': mode,
                          'started_at': datetime.now(timezone.utc).isoformat(),
                          'user_context': user_context,
                          'conversation_history': [],
                          'current_stage': 'phone_pickup',
                          'session_active': True,
                          'hang_up_triggered': False,
                          'turn_count': 0,
                          'stage_turn_count': 0,
                          'stages_completed': [],
                          'conversation_quality': 0,
                          'rubric_scores': {},
                          'stage_progression': ['phone_pickup'],
                          'overall_call_result': 'in_progress',
                          
                          # Enhanced: Additional tracking
                          'prospect_warmth': 0,           
                          'empathy_shown': False,         
                          'specific_benefits_mentioned': False,  
                          'conversation_flow_score': 0,   
                          'last_evaluation': None,       
                          'cumulative_score': 0,
                          'minimum_turns_completed': False,  # NEW: Track minimum conversation length
                          'valid_opener_received': False,    # NEW: Track if we got a real opener
                          'conversation_started': False,     # NEW: Track if conversation has begun
                          'attempts_count': 0                # NEW: Track number of attempts
                      }
                      
                      # Store session
                      self.active_sessions[session_id] = session_data
                      
                      # Generate contextual initial response
                      initial_response = self._get_contextual_initial_response(user_context)
                      
                      # Add to conversation
                      session_data['conversation_history'].append({
                          'role': 'assistant',
                          'content': initial_response,
                          'timestamp': datetime.now(timezone.utc).isoformat(),
                          'stage': 'phone_pickup',
                          'prospect_warmth': 0
                      })
                      
                      logger.info(f"Created Roleplay 1.1 session {session_id} with enhanced tracking")
                      
                      return {
                          'success': True,
                          'session_id': session_id,
                          'initial_response': initial_response,
                          'roleplay_info': self.get_roleplay_info()
                      }
                      
                  except Exception as e:
                      logger.error(f"Error creating Roleplay 1.1 session: {e}")
                      return {'success': False, 'error': str(e)}
              
              def process_user_input(self, session_id: str, user_input: str) -> Dict[str, Any]:
                  """FIXED: Process user input with proper conversation flow"""
                  try:
                      if session_id not in self.active_sessions:
                          raise ValueError("Session not found")
                      
                      session = self.active_sessions[session_id]
                      
                      if not session.get('session_active'):
                          raise ValueError("Session not active")
                      
                      # Handle special silence triggers
                      if user_input in ['[SILENCE_IMPATIENCE]', '[SILENCE_HANGUP]']:
                          return self._handle_silence_trigger(session, user_input)
                      
                      # Increment counters
                      session['turn_count'] += 1
                      session['stage_turn_count'] += 1
                      session['attempts_count'] += 1
                      
                      # Add user input to conversation
                      session['conversation_history'].append({
                          'role': 'user',
                          'content': user_input,
                          'timestamp': datetime.now(timezone.utc).isoformat(),
                          'stage': session['current_stage']
                      })
                      
                      logger.info(f"Processing input #{session['turn_count']}: '{user_input[:50]}...'")
                      
                      # FIXED: Better evaluation logic
                      evaluation_stage = self._get_evaluation_stage(session['current_stage'])
                      evaluation = self._evaluate_user_input_enhanced(session, user_input, evaluation_stage)
                      
                      # Store evaluation for context
                      session['last_evaluation'] = evaluation
                      
                      # FIXED: Update conversation metrics
                      self._update_conversation_metrics(session, evaluation)
                      
                      # FIXED: Validate conversation progress
                      self._validate_conversation_progress(session, user_input, evaluation)
                      
                      # FIXED: Check if should hang up (much more lenient)
                      should_hang_up = self._should_hang_up_enhanced(session, evaluation, user_input)
                      
                      if should_hang_up:
                          ai_response = self._get_contextual_hangup_response(session, evaluation)
                          session['hang_up_triggered'] = True
                          call_continues = False
                          logger.info(f"Session {session_id}: Call ending due to hang-up")
                      else:
                          # Generate contextual AI response
                          ai_response = self._generate_contextual_ai_response(session, user_input, evaluation)
                          
                          # FIXED: Update session state with proper logic
                          self._update_session_state_enhanced(session, evaluation)
                          
                          # FIXED: Check if call should continue (much more lenient)
                          call_continues = self._should_call_continue_enhanced(session, evaluation)
                          
                          if not call_continues:
                              logger.info(f"Session {session_id}: Call ending naturally after {session['turn_count']} turns")
                      
                      # Add AI response to conversation
                      session['conversation_history'].append({
                          'role': 'assistant',
                          'content': ai_response,
                          'timestamp': datetime.now(timezone.utc).isoformat(),
                          'stage': session['current_stage'],
                          'evaluation': evaluation,
                          'prospect_warmth': session.get('prospect_warmth', 0)
                      })
                      
                      return {
                          'success': True,
                          'ai_response': ai_response,
                          'call_continues': call_continues,
                          'evaluation': evaluation,
                          'session_state': session['current_stage'],
                          'turn_count': session['turn_count'],
                          'conversation_quality': session['conversation_quality'],
                          'prospect_warmth': session.get('prospect_warmth', 0),
                          'debug_info': {
                              'minimum_turns_completed': session.get('minimum_turns_completed', False),
                              'valid_opener_received': session.get('valid_opener_received', False),
                              'conversation_started': session.get('conversation_started', False),
                              'evaluation_stage': evaluation_stage,
                              'should_hang_up': should_hang_up,
                              'attempts_count': session.get('attempts_count', 0)
                          }
                      }
                      
                  except Exception as e:
                      logger.error(f"Error processing Roleplay 1.1 input: {e}")
                      return {'success': False, 'error': str(e), 'call_continues': False}
              
              # ===== FIXED CONVERSATION VALIDATION =====
              
              def _validate_conversation_progress(self, session: Dict, user_input: str, evaluation: Dict):
                  """Validate that the conversation is progressing properly"""
                  current_stage = session['current_stage']
                  turn_count = session['turn_count']
                  
                  # Check if this is a valid opener (much more lenient)
                  if current_stage in ['phone_pickup', 'opener_evaluation']:
                      if turn_count == 1:
                          # For first attempt, just mark conversation as started
                          session['conversation_started'] = True
                          
                          # Check if it's a valid opener
                          if self._is_valid_opener(user_input):
                              session['valid_opener_received'] = True
                              logger.info("Valid opener received")
                          else:
                              logger.info(f"Basic opener received: '{user_input}' - giving user chance to improve")
                              # Don't end conversation, give chance to improve
                  
                  # Mark minimum turns completed (increased threshold)
                  if turn_count >= self.config.CONVERSATION_LIMITS['min_turns_for_success']:
                      session['minimum_turns_completed'] = True
                  
                  # Always mark conversation as started after first turn
                  if turn_count >= 1:
                      session['conversation_started'] = True
              
              def _is_valid_opener(self, user_input: str) -> bool:
                  """FIXED: More lenient check for valid conversation opener"""
                  user_input = user_input.strip().lower()
                  
                  # Any input over 2 words is considered an attempt
                  if len(user_input.split()) >= 2:
                      return True
                  
                  # Single words that show effort
                  effort_words = ['hi', 'hello', 'hey', 'good', 'morning', 'afternoon', 'evening']
                  if user_input in effort_words:
                      return True
                  
                  return False
              
              # ===== FIXED CALL CONTINUATION LOGIC =====
              
              def _should_call_continue_enhanced(self, session: Dict, evaluation: Dict) -> bool:
                  """FIXED: Much more lenient call continuation logic"""
                  
                  # Always continue if hung up
                  if session.get('hang_up_triggered'):
                      return False
                  
                  # Always continue if stage is call_ended
                  if session['current_stage'] == 'call_ended':
                      return False
                  
                  # Check conversation limits (absolute maximum only)
                  max_turns = self.config.CONVERSATION_LIMITS['max_total_turns']
                  if session['turn_count'] >= max_turns:
                      logger.info(f"Ending call: reached maximum turns ({max_turns})")
                      return False
                  
                  # FIXED: Much more lenient early turn logic
                  min_turns = self.config.CONVERSATION_LIMITS.get('min_turns_for_success', 6)
                  
                  # NEVER end before at least 3 turns
                  if session['turn_count'] < 3:
                      logger.info(f"Continuing call: only {session['turn_count']} turns, need at least 3")
                      return True
                  
                  # For turns 3-6, be very lenient
                  if session['turn_count'] < min_turns:
                      # Only end if user is clearly not trying (empty inputs, single words repeatedly)
                      attempts = session.get('attempts_count', 0)
                      if attempts >= 3:
                          # Check if user has made any real effort
                          conversation_quality = session.get('conversation_quality', 0)
                          if conversation_quality < 20:
                              logger.info(f"Ending call: 3+ attempts but quality still very low ({conversation_quality})")
                              return False
                      
                      logger.info(f"Continuing call: {session['turn_count']} turns, still in learning phase")
                      return True
                  
                  # After minimum turns, use normal logic but still be lenient
                  conversation_quality = session.get('conversation_quality', 0)
                  prospect_warmth = session.get('prospect_warmth', 0)
                  
                  # Continue if conversation quality is decent
                  if conversation_quality >= 40:
                      logger.info(f"Continuing call: good conversation quality ({conversation_quality}%)")
                      return True
                  
                  # Continue if prospect is warming up
                  if prospect_warmth >= 2:
                      logger.info(f"Continuing call: prospect warming up (warmth={prospect_warmth})")
                      return True
                  
                  # Continue if we're in early stages and user is making effort
                  early_stages = ['phone_pickup', 'opener_evaluation', 'early_objection', 'objection_handling']
                  if session['current_stage'] in early_stages and session['turn_count'] < 8:
                      logger.info(f"Continuing call: in early stage '{session['current_stage']}'")
                      return True
                  
                  # Only end if we've had reasonable length conversation AND poor quality
                  if (session['turn_count'] >= 8 and 
                      conversation_quality < 30 and 
                      prospect_warmth <= 1):
                      logger.info(f"Natural conversation end: {session['turn_count']} turns, quality={conversation_quality}, warmth={prospect_warmth}")
                      return False
                  
                  # Default: continue the conversation
                  logger.info(f"Continuing call: default continuation (turn {session['turn_count']})")
                  return True
              
              # ===== FIXED HANG-UP LOGIC =====
              
              def _should_hang_up_enhanced(self, session: Dict, evaluation: Dict, user_input: str) -> bool:
                  """FIXED: Much more lenient hang-up logic"""
                  current_stage = session['current_stage']
                  turn_count = session['turn_count']
                  
                  # NEVER hang up in the first 4 turns - give users time to learn
                  if turn_count <= 4:
                      logger.info("No hang-up: too early in conversation (first 4 turns)")
                      return False
                  
                  # Don't hang up if prospect is warming up at all
                  prospect_warmth = session.get('prospect_warmth', 0)
                  if prospect_warmth >= 1:
                      logger.info(f"No hang-up: prospect showing some warmth ({prospect_warmth})")
                      return False
                  
                  # Don't hang up if conversation quality is above minimum
                  conversation_quality = session.get('conversation_quality', 0)
                  if conversation_quality >= 25:
                      logger.info(f"No hang-up: conversation quality acceptable ({conversation_quality}%)")
                      return False
                  
                  # Very rare hang-up only for extremely poor performance after many tries
                  weighted_score = evaluation.get('weighted_score', evaluation.get('score', 2))
                  attempts = session.get('attempts_count', 0)
                  
                  # Only consider hang-up after 6+ turns AND multiple poor attempts
                  if turn_count >= 6 and attempts >= 4 and weighted_score <= 0.5 and conversation_quality < 15:
                      hang_up_prob = 0.2  # Only 20% chance even then
                      should_hang_up = random.random() < hang_up_prob
                      
                      if should_hang_up:
                          logger.info(f"Rare hang-up triggered: turns={turn_count}, attempts={attempts}, score={weighted_score}, quality={conversation_quality}%")
                      
                      return should_hang_up
                  
                  # Default: no hang-up
                  logger.info("No hang-up: conditions not met for hang-up")
                  return False
              
              # ===== FIXED EVALUATION LOGIC =====
              
              def _evaluate_user_input_enhanced(self, session: Dict, user_input: str, evaluation_stage: str) -> Dict[str, Any]:
                  """FIXED: Enhanced evaluation with better scoring"""
                  try:
                      if self.is_openai_available():
                          # Use OpenAI with enhanced prompting
                          evaluation = self.openai_service.evaluate_user_input(
                              user_input,
                              session['conversation_history'],
                              evaluation_stage
                          )
                          
                          # Apply weighted scoring
                          evaluation = self._apply_weighted_scoring(evaluation, evaluation_stage)
                          
                          # Store in session rubric scores
                          session['rubric_scores'][evaluation_stage] = {
                              'score': evaluation.get('score', 0),
                              'weighted_score': evaluation.get('weighted_score', 0),
                              'passed': evaluation.get('passed', False),
                              'criteria_met': evaluation.get('criteria_met', [])
                          }
                          
                          return evaluation
                      else:
                          return self._enhanced_basic_evaluation(user_input, evaluation_stage, session)
                          
                  except Exception as e:
                      logger.error(f"Enhanced evaluation error: {e}")
                      return self._enhanced_basic_evaluation(user_input, evaluation_stage, session)
              
              def _enhanced_basic_evaluation(self, user_input: str, evaluation_stage: str, session: Dict) -> Dict[str, Any]:
                  """FIXED: Much more encouraging basic evaluation"""
                  score = 0
                  weighted_score = 0
                  criteria_met = []
                  user_input_lower = user_input.lower().strip()
                  turn_count = session.get('turn_count', 1)
                  
                  # Get criteria for this stage
                  stage_criteria = self.config.EVALUATION_CRITERIA.get(evaluation_stage, {}).get('criteria', [])
                  
                  # FIXED: Much more encouraging evaluation, especially for early attempts
                  for criterion in stage_criteria:
                      weight = criterion.get('weight', 1.0)
                      met = False
                      
                      # Check keywords
                      if 'keywords' in criterion:
                          if any(keyword in user_input_lower for keyword in criterion['keywords']):
                              met = True
                      
                      # FIXED: Much more lenient basic criteria
                      if criterion.get('name') == 'clear_introduction':
                          # Accept any attempt to communicate
                          basic_attempts = ['hello', 'hi', 'hey', 'good', 'morning', 'afternoon', 'this is', 'my name', 'calling from']
                          if any(word in user_input_lower for word in basic_attempts):
                              met = True
                      
                      # Give credit for natural tone (any contractions or casual language)
                      if criterion.get('check_contractions') or criterion.get('name') == 'natural_tone':
                          natural_indicators = ["i'm", "don't", "can't", "we're", "you're", "won't", "isn't", "i", "we", "our"]
                          if any(indicator in user_input_lower for indicator in natural_indicators):
                              met = True
                      
                      # Give credit for any question
                      if criterion.get('name') == 'engaging_close':
                          if '?' in user_input or any(q in user_input_lower for q in ['can i', 'may i', 'would you', 'could i']):
                              met = True
                      
                      if met:
                          criteria_met.append(criterion['name'])
                          score += 1
                          weighted_score += weight
                  
                  # FIXED: Much more generous base scoring
                  word_count = len(user_input.split())
                  
                  # Give credit for effort based on word count
                  if word_count >= 1:
                      score += 0.5  # Base effort bonus
                  if word_count >= 3:
                      score += 0.5  # Meaningful attempt bonus
                  if word_count >= 5:
                      score += 0.5  # Good length bonus
                  if word_count >= 8:
                      score += 0.5  # Detailed attempt bonus
                  
                  # FIXED: Very generous scoring for early attempts
                  if turn_count <= 2:
                      score = max(score, 1.5)  # Minimum score for first attempts
                      weighted_score = max(weighted_score, 1.5)
                  elif turn_count <= 4:
                      score = max(score, 1.0)  # Still generous for early attempts
                      weighted_score = max(weighted_score, 1.0)
                  
                  # Calculate normalized scores
                  total_possible_weight = sum(c.get('weight', 1.0) for c in stage_criteria)
                  if total_possible_weight > 0:
                      normalized_weighted_score = (weighted_score / total_possible_weight) * 4
                  else:
                      normalized_weighted_score = min(score, 4.0)
                  
                  # Ensure minimum score for effort
                  final_score = max(normalized_weighted_score, 1.0)
                  
                  # Check pass threshold (more lenient)
                  threshold = self.config.EVALUATION_CRITERIA.get(evaluation_stage, {}).get('pass_threshold', 2)
                  passed = final_score >= threshold
                  
                  logger.info(f"Basic evaluation: score={final_score:.1f}, passed={passed}, criteria={len(criteria_met)}, words={word_count}")
                  
                  return {
                      'score': min(4, max(1, int(final_score))),  # Keep in 1-4 range
                      'weighted_score': round(final_score, 1),
                      'passed': passed,
                      'criteria_met': criteria_met,
                      'feedback': f'Enhanced evaluation: {len(criteria_met)} criteria met for {evaluation_stage}',
                      'should_continue': True,
                      'next_action': 'continue',
                      'hang_up_probability': 0.0,  # No hang-up from evaluation
                      'source': 'enhanced_basic',
                      'stage': evaluation_stage
                  }
              
              # ===== FIXED AI RESPONSE GENERATION =====
              
              def _generate_contextual_ai_response(self, session: Dict, user_input: str, evaluation: Dict) -> str:
                  """Generate contextual AI response based on conversation state"""
                  try:
                      if self.is_openai_available():
                          # Enhanced context for AI response
                          enhanced_context = {
                              **session['user_context'],
                              'prospect_warmth': session.get('prospect_warmth', 0),
                              'conversation_quality': session.get('conversation_quality', 0),
                              'empathy_shown': session.get('empathy_shown', False),
                              'stage_performance': evaluation,

    📄 roleplay_1_2.py (36.8KB)
        Content:
          # ===== services/roleplay/roleplay_1_2.py =====
          
          import random
          import logging
          from datetime import datetime, timezone
          from typing import Dict, List, Any, Optional, Set
          from .base_roleplay import BaseRoleplay
          from .configs.roleplay_1_2_config import Roleplay12Config
          
          logger = logging.getLogger(__name__)
          
          class Roleplay12(BaseRoleplay):
              """Roleplay 1.2 - Marathon Mode: 10 calls, need 6 to pass"""
              
              def __init__(self, openai_service=None):
                  super().__init__(openai_service)
                  self.config = Roleplay12Config()
                  
              def get_roleplay_info(self) -> Dict[str, Any]:
                  """Return Roleplay 1.2 configuration"""
                  return {
                      'id': self.config.ROLEPLAY_ID,
                      'name': self.config.NAME,
                      'description': self.config.DESCRIPTION,
                      'type': 'marathon',
                      'total_calls': self.config.TOTAL_CALLS,
                      'calls_to_pass': self.config.CALLS_TO_PASS,
                      'features': {
                          'ai_evaluation': True,
                          'multiple_calls': True,
                          'random_hangups': True,
                          'no_in_call_feedback': True,
                          'aggregated_coaching': True,
                          'objection_variety': True
                      },
                      'stages': list(self.config.STAGE_FLOW.keys()),
                      'objection_count': len(self.config.EARLY_OBJECTIONS)
                  }
              
              def create_session(self, user_id: str, mode: str, user_context: Dict) -> Dict[str, Any]:
                  """Create new Marathon session"""
                  try:
                      session_id = f"{user_id}_{self.config.ROLEPLAY_ID}_{mode}_{int(datetime.now().timestamp())}"
                      
                      session_data = {
                          'session_id': session_id,
                          'user_id': user_id,
                          'roleplay_id': self.config.ROLEPLAY_ID,
                          'mode': mode,
                          'started_at': datetime.now(timezone.utc).isoformat(),
                          'user_context': user_context,
                          'session_active': True,
                          
                          # Marathon specific fields
                          'marathon_state': {
                              'current_call': 1,
                              'total_calls': self.config.TOTAL_CALLS,
                              'calls_passed': 0,
                              'calls_failed': 0,
                              'calls_to_pass': self.config.CALLS_TO_PASS,
                              'is_complete': False,
                              'is_passed': False
                          },
                          
                          # Current call state
                          'current_call_data': self._initialize_call_data(),
                          
                          # Marathon tracking
                          'all_calls_data': [],  # Store data from completed calls
                          'used_objections': set(),  # Track used objections
                          'overall_performance': {
                              'total_interactions': 0,
                              'successful_stages': 0,
                              'rubric_scores_aggregate': {}
                          }
                      }
                      
                      # Store session
                      self.active_sessions[session_id] = session_data
                      
                      # Generate initial response for first call
                      initial_response = self._get_initial_response(user_context)
                      
                      # Add to current call conversation
                      session_data['current_call_data']['conversation_history'].append({
                          'role': 'assistant',
                          'content': initial_response,
                          'timestamp': datetime.now(timezone.utc).isoformat(),
                          'stage': 'phone_pickup'
                      })
                      
                      logger.info(f"Created Marathon session {session_id} - Call 1/{self.config.TOTAL_CALLS}")
                      
                      return {
                          'success': True,
                          'session_id': session_id,
                          'initial_response': initial_response,
                          'roleplay_info': self.get_roleplay_info(),
                          'marathon_status': self._get_marathon_status(session_data)
                      }
                      
                  except Exception as e:
                      logger.error(f"Error creating Marathon session: {e}")
                      return {'success': False, 'error': str(e)}
              
              def process_user_input(self, session_id: str, user_input: str) -> Dict[str, Any]:
                  """Process user input for Marathon mode"""
                  try:
                      if session_id not in self.active_sessions:
                          raise ValueError("Session not found")
                      
                      session = self.active_sessions[session_id]
                      
                      if not session.get('session_active'):
                          raise ValueError("Session not active")
                      
                      # Check if marathon is complete
                      if session['marathon_state']['is_complete']:
                          return {
                              'success': True,
                              'ai_response': "Marathon complete! Check your results.",
                              'call_continues': False,
                              'marathon_complete': True,
                              'marathon_status': self._get_marathon_status(session)
                          }
                      
                      # Handle silence triggers
                      if user_input in ['[SILENCE_IMPATIENCE]', '[SILENCE_HANGUP]']:
                          return self._handle_silence_trigger(session, user_input)
                      
                      current_call = session['current_call_data']
                      
                      # Increment counters
                      current_call['turn_count'] += 1
                      current_call['stage_turn_count'] += 1
                      session['overall_performance']['total_interactions'] += 1
                      
                      # Add user input to conversation
                      current_call['conversation_history'].append({
                          'role': 'user',
                          'content': user_input,
                          'timestamp': datetime.now(timezone.utc).isoformat(),
                          'stage': current_call['current_stage']
                      })
                      
                      # Evaluate user input
                      evaluation_stage = self._get_evaluation_stage(current_call['current_stage'])
                      evaluation = self._evaluate_user_input(session, user_input, evaluation_stage)
                      
                      # Check for random hangup (Marathon specific)
                      if self._should_random_hangup(current_call, evaluation):
                          logger.info("Random hangup triggered in Marathon mode")
                          return self._handle_random_hangup(session)
                      
                      # Check if should hang up based on performance
                      should_hang_up = self._should_hang_up_now(session, evaluation, user_input)
                      
                      if should_hang_up:
                          logger.info("Performance-based hangup in Marathon mode")
                          return self._handle_call_failure(session, evaluation, "performance")
                      
                      # Generate AI response
                      ai_response = self._generate_ai_response(session, user_input, evaluation)
                      
                      # Update session state
                      self._update_session_state(session, evaluation)
                      
                      # Check if current call should end (success)
                      call_should_end = self._should_current_call_end(session, evaluation)
                      
                      if call_should_end:
                          return self._handle_call_success(session, ai_response, evaluation)
                      
                      # Add AI response to conversation
                      current_call['conversation_history'].append({
                          'role': 'assistant',
                          'content': ai_response,
                          'timestamp': datetime.now(timezone.utc).isoformat(),
                          'stage': current_call['current_stage'],
                          'evaluation': evaluation
                      })
                      
                      return {
                          'success': True,
                          'ai_response': ai_response,
                          'call_continues': True,
                          'evaluation': evaluation,
                          'session_state': current_call['current_stage'],
                          'marathon_status': self._get_marathon_status(session),
                          'current_call': session['marathon_state']['current_call'],
                          'total_calls': session['marathon_state']['total_calls']
                      }
                      
                  except Exception as e:
                      logger.error(f"Error processing Marathon input: {e}")
                      return {'success': False, 'error': str(e), 'call_continues': False}
              
              def end_session(self, session_id: str, forced_end: bool = False) -> Dict[str, Any]:
                  """End Marathon session and generate aggregated coaching"""
                  try:
                      if session_id not in self.active_sessions:
                          raise ValueError("Session not found")
                      
                      session = self.active_sessions[session_id]
                      session['session_active'] = False
                      session['ended_at'] = datetime.now(timezone.utc).isoformat()
                      
                      # If current call is not complete, mark it as failed
                      if not session['marathon_state']['is_complete']:
                          current_call = session['current_call_data']
                          if current_call and current_call.get('call_status') == 'in_progress':
                              current_call['call_status'] = 'failed'
                              current_call['end_reason'] = 'forced_end' if forced_end else 'incomplete'
                              session['all_calls_data'].append(current_call)
                              session['marathon_state']['calls_failed'] += 1
                          
                          # Mark marathon as complete
                          session['marathon_state']['is_complete'] = True
                          session['marathon_state']['is_passed'] = (
                              session['marathon_state']['calls_passed'] >= session['marathon_state']['calls_to_pass']
                          )
                      
                      # Calculate duration
                      started_at = datetime.fromisoformat(session['started_at'].replace('Z', '+00:00'))
                      ended_at = datetime.now(timezone.utc)
                      duration_minutes = max(1, int((ended_at - started_at).total_seconds() / 60))
                      
                      # Generate aggregated coaching
                      coaching_result = self._generate_marathon_coaching(session)
                      
                      # Calculate overall success
                      marathon_success = session['marathon_state']['is_passed']
                      
                      result = {
                          'success': True,
                          'duration_minutes': duration_minutes,
                          'session_success': marathon_success,
                          'coaching': coaching_result.get('coaching', {}),
                          'overall_score': coaching_result.get('score', 50),
                          'session_data': session,
                          'roleplay_type': 'marathon',
                          'marathon_results': {
                              'calls_passed': session['marathon_state']['calls_passed'],
                              'calls_failed': session['marathon_state']['calls_failed'],
                              'total_calls': len(session['all_calls_data']),
                              'target_calls': session['marathon_state']['calls_to_pass'],
                              'passed': marathon_success
                          }
                      }
                      
                      # Clean up session
                      del self.active_sessions[session_id]
                      
                      return result
                      
                  except Exception as e:
                      logger.error(f"Error ending Marathon session: {e}")
                      return {'success': False, 'error': str(e)}
              
              def get_session_status(self, session_id: str) -> Optional[Dict[str, Any]]:
                  """Get current Marathon session status"""
                  session = self.active_sessions.get(session_id)
                  if session:
                      current_call = session.get('current_call_data', {})
                      return {
                          'session_active': session.get('session_active', False),
                          'current_stage': current_call.get('current_stage', 'unknown'),
                          'current_call': session['marathon_state']['current_call'],
                          'total_calls': session['marathon_state']['total_calls'],
                          'calls_passed': session['marathon_state']['calls_passed'],
                          'calls_failed': session['marathon_state']['calls_failed'],
                          'calls_to_pass': session['marathon_state']['calls_to_pass'],
                          'is_complete': session['marathon_state']['is_complete'],
                          'conversation_length': len(current_call.get('conversation_history', [])),
                          'roleplay_type': 'marathon',
                          'openai_available': self.is_openai_available()
                      }
                  return None
              
              # ===== PRIVATE METHODS =====
              
              def _initialize_call_data(self) -> Dict[str, Any]:
                  """Initialize data for a new call"""
                  return {
                      'conversation_history': [],
                      'current_stage': 'phone_pickup',
                      'turn_count': 0,
                      'stage_turn_count': 0,
                      'call_status': 'in_progress',  # in_progress, passed, failed
                      'end_reason': None,  # success, hangup_random, hangup_performance, silence, etc.
                      'stages_completed': [],
                      'rubric_scores': {},
                      'started_at': datetime.now(timezone.utc).isoformat()
                  }
              
              def _get_initial_response(self, user_context: Dict) -> str:
                  """Generate initial phone pickup response"""
                  responses = [
                      "Hello?", 
                      "Hi there.", 
                      "Good morning.", 
                      "Yes?",
                      f"{user_context.get('first_name', 'Alex')} speaking."
                  ]
                  return random.choice(responses)
              
              def _get_marathon_status(self, session: Dict) -> Dict[str, Any]:
                  """Get current marathon status"""
                  marathon_state = session['marathon_state']
                  return {
                      'current_call': marathon_state['current_call'],
                      'total_calls': marathon_state['total_calls'],
                      'calls_passed': marathon_state['calls_passed'],
                      'calls_failed': marathon_state['calls_failed'],
                      'calls_to_pass': marathon_state['calls_to_pass'],
                      'is_complete': marathon_state['is_complete'],
                      'is_passed': marathon_state['is_passed'],
                      'calls_remaining': marathon_state['total_calls'] - len(session['all_calls_data']),
                      'progress_percentage': (len(session['all_calls_data']) / marathon_state['total_calls']) * 100
                  }
              
              def _get_evaluation_stage(self, current_stage: str) -> str:
                  """Map current stage to evaluation stage"""
                  mapping = {
                      'phone_pickup': 'opener',
                      'opener_evaluation': 'opener',
                      'early_objection': 'objection_handling',
                      'objection_handling': 'objection_handling',
                      'mini_pitch': 'mini_pitch',
                      'soft_discovery': 'soft_discovery'
                  }
                  return mapping.get(current_stage, 'opener')
              
              def _evaluate_user_input(self, session: Dict, user_input: str, evaluation_stage: str) -> Dict[str, Any]:
                  """Evaluate user input using OpenAI or fallback"""
                  try:
                      if self.is_openai_available():
                          evaluation = self.openai_service.evaluate_user_input(
                              user_input,
                              session['current_call_data']['conversation_history'],
                              evaluation_stage
                          )
                          
                          # Store in current call rubric scores
                          session['current_call_data']['rubric_scores'][evaluation_stage] = {
                              'score': evaluation.get('score', 0),
                              'passed': evaluation.get('passed', False),
                              'criteria_met': evaluation.get('criteria_met', [])
                          }
                          
                          return evaluation
                      else:
                          return self._basic_evaluation(user_input, evaluation_stage)
                          
                  except Exception as e:
                      logger.error(f"Evaluation error: {e}")
                      return self._basic_evaluation(user_input, evaluation_stage)
              
              def _basic_evaluation(self, user_input: str, evaluation_stage: str) -> Dict[str, Any]:
                  """Basic evaluation fallback - same as Roleplay 1.1"""
                  score = 0
                  criteria_met = []
                  user_input_lower = user_input.lower().strip()
                  
                  # Use same evaluation logic as Roleplay 1.1
                  if evaluation_stage == "opener":
                      if len(user_input.strip()) > 15:
                          score += 1
                          criteria_met.append('substantial_opener')
                      
                      if any(phrase in user_input_lower for phrase in ["i'm calling", "calling from"]):
                          score += 1
                          criteria_met.append('clear_opener')
                      
                      if any(contraction in user_input_lower for contraction in ["i'm", "don't", "can't"]):
                          score += 1
                          criteria_met.append('casual_tone')
                      
                      if any(empathy in user_input_lower for empathy in ["know this is", "out of the blue"]):
                          score += 1
                          criteria_met.append('shows_empathy')
                  
                  # Similar logic for other stages...
                  
                  threshold = self.config.PASS_THRESHOLDS.get(evaluation_stage, 2)
                  passed = score >= threshold
                  
                  return {
                      'score': score,
                      'passed': passed,
                      'criteria_met': criteria_met,
                      'feedback': f'Basic evaluation: {score} criteria met for {evaluation_stage}',
                      'should_continue': True,
                      'next_action': 'continue',
                      'hang_up_probability': 0.4 if score <= 1 else 0.2,
                      'source': 'basic',
                      'stage': evaluation_stage
                  }
              
              def _should_random_hangup(self, current_call: Dict, evaluation: Dict) -> bool:
                  """Check if random hangup should occur (Marathon specific)"""
                  # Only in opener_evaluation stage and only if opener passed
                  if (current_call['current_stage'] == 'opener_evaluation' and 
                      evaluation.get('passed', False)):
                      
                      return random.random() < self.config.RANDOM_HANGUP_CHANCE
                  
                  return False
              
              def _should_hang_up_now(self, session: Dict, evaluation: Dict, user_input: str) -> bool:
                  """Determine if prospect should hang up based on performance"""
                  current_call = session['current_call_data']
                  
                  # Never hang up on first interaction
                  if current_call['turn_count'] <= 1:
                      return False
                  
                  # Get hang up probability from evaluation
                  hang_up_prob = evaluation.get('hang_up_probability', 0.1)
                  
                  # Marathon mode is less forgiving than Practice mode
                  score = evaluation.get('score', 0)
                  current_stage = current_call['current_stage']
                  
                  if current_stage == 'opener_evaluation':
                      if score <= 1:
                          hang_up_prob = 0.6  # Higher than Practice mode
                      elif score == 2:
                          hang_up_prob = 0.3
                      else:
                          hang_up_prob = 0.05
                  elif current_stage in ['objection_handling']:
                      if not evaluation.get('passed', True):
                          hang_up_prob = 0.5  # Higher than Practice mode
                  
                  return random.random() < hang_up_prob
              
              def _generate_ai_response(self, session: Dict, user_input: str, evaluation: Dict) -> str:
                  """Generate AI prospect response"""
                  try:
                      if self.is_openai_available():
                          response_result = self.openai_service.generate_roleplay_response(
                              user_input,
                              session['current_call_data']['conversation_history'],
                              session['user_context'],
                              session['current_call_data']['current_stage']
                          )
                          
                          if response_result.get('success'):
                              return response_result['response']
                      
                      # Fallback response
                      return self._get_fallback_response(session, evaluation)
                      
                  except Exception as e:
                      logger.error(f"Error generating AI response: {e}")
                      return self._get_fallback_response(session, evaluation)
              
              def _get_fallback_response(self, session: Dict, evaluation: Dict) -> str:
                  """Get fallback response for Marathon mode"""
                  current_call = session['current_call_data']
                  current_stage = current_call['current_stage']
                  passed = evaluation.get('passed', False)
                  
                  if current_stage == 'early_objection':
                      # Get unused objection
                      used_objections = session.get('used_objections', set())
                      available_objections = [obj for obj in self.config.EARLY_OBJECTIONS 
                                            if obj not in used_objections]
                      
                      if available_objections:
                          objection = random.choice(available_objections)
                          session['used_objections'].add(objection)
                          return objection
                      else:
                          # All objections used, use a generic one
                          return random.choice(self.config.EARLY_OBJECTIONS[:5])
                  
                  # For other stages, use similar logic as Roleplay 1.1
                  responses_map = {
                      'opener_evaluation': {
                          True: ["Alright, what's this about?", "I'm listening. Go ahead."],
                          False: ["What's this about?", "I'm not interested."]
                      },
                      'objection_handling': {
                          True: ["Okay, you have 30 seconds.", "Go ahead."],
                          False: ["I already told you I'm not interested.", "You're not listening."]
                      },
                      'mini_pitch': {
                          True: ["That sounds interesting. Tell me more.", "How does that work?"],
                          False: ["I don't understand.", "That's too vague."]
                      },
                      'soft_discovery': ["Send me some information.", "I'll think about it.", "That makes sense."]
                  }
                  
                  stage_responses = responses_map.get(current_stage, ["I see."])
                  
                  if isinstance(stage_responses, dict):
                      responses = stage_responses.get(passed, stage_responses.get(True, ["I see."]))
                  else:
                      responses = stage_responses

    📄 roleplay_1_3.py (18.2KB)
        Content:
          # ===== services/roleplay/roleplay_1_3.py (Legend Mode) =====
          
          import random
          import logging
          from datetime import datetime, timezone
          from typing import Dict, List, Any, Optional
          from .base_roleplay import BaseRoleplay
          from .configs.roleplay_1_3_config import Roleplay13Config
          
          logger = logging.getLogger(__name__)
          
          class Roleplay13(BaseRoleplay):
              """Roleplay 1.3 - Legend Mode: 6 perfect calls in a row"""
              
              def __init__(self, openai_service=None):
                  super().__init__(openai_service)
                  self.config = Roleplay13Config()
                  
              def get_roleplay_info(self) -> Dict[str, Any]:
                  """Return Roleplay 1.3 configuration"""
                  return {
                      'id': self.config.ROLEPLAY_ID,
                      'name': self.config.NAME,
                      'description': self.config.DESCRIPTION,
                      'type': 'legend',
                      'features': {
                          'ai_evaluation': True,
                          'perfect_calls_required': True,
                          'no_mistakes_allowed': True,
                          'elite_challenge': True,
                          'bragging_rights': True
                      },
                      'total_calls': self.config.TOTAL_CALLS,
                      'perfect_calls_required': self.config.PERFECT_CALLS_REQUIRED
                  }
              
              def create_session(self, user_id: str, mode: str, user_context: Dict) -> Dict[str, Any]:
                  """Create new Legend Mode session"""
                  try:
                      session_id = f"{user_id}_{self.config.ROLEPLAY_ID}_{mode}_{int(datetime.now().timestamp())}"
                      
                      session_data = {
                          'session_id': session_id,
                          'user_id': user_id,
                          'roleplay_id': self.config.ROLEPLAY_ID,
                          'mode': mode,
                          'started_at': datetime.now(timezone.utc).isoformat(),
                          'user_context': user_context,
                          'session_active': True,
                          
                          # Legend specific fields
                          'legend_state': {
                              'current_call': 1,
                              'total_calls': self.config.TOTAL_CALLS,
                              'perfect_calls': 0,
                              'failed_calls': 0,
                              'required_perfect': self.config.PERFECT_CALLS_REQUIRED,
                              'is_complete': False,
                              'is_legend': False,
                              'failure_reasons': []
                          },
                          
                          # Current call state
                          'current_call_data': self._initialize_call_data(),
                          
                          # Legend tracking
                          'all_calls_data': [],
                          'overall_performance': {
                              'total_interactions': 0,
                              'perfect_stages': 0,
                              'rubric_scores_aggregate': {}
                          }
                      }
                      
                      # Store session
                      self.active_sessions[session_id] = session_data
                      
                      # Generate initial response
                      initial_response = self._get_initial_response(user_context)
                      
                      # Add to current call conversation
                      session_data['current_call_data']['conversation_history'].append({
                          'role': 'assistant',
                          'content': initial_response,
                          'timestamp': datetime.now(timezone.utc).isoformat(),
                          'stage': 'phone_pickup'
                      })
                      
                      logger.info(f"Created Legend Mode session {session_id} - Call 1/{self.config.TOTAL_CALLS}")
                      
                      return {
                          'success': True,
                          'session_id': session_id,
                          'initial_response': initial_response,
                          'roleplay_info': self.get_roleplay_info(),
                          'legend_status': self._get_legend_status(session_data)
                      }
                      
                  except Exception as e:
                      logger.error(f"Error creating Legend Mode session: {e}")
                      return {'success': False, 'error': str(e)}
              
              def process_user_input(self, session_id: str, user_input: str) -> Dict[str, Any]:
                  """Process user input for Legend Mode - VERY strict evaluation"""
                  try:
                      if session_id not in self.active_sessions:
                          raise ValueError("Session not found")
                      
                      session = self.active_sessions[session_id]
                      
                      if not session.get('session_active'):
                          raise ValueError("Session not active")
                      
                      # Check if legend challenge is complete
                      if session['legend_state']['is_complete']:
                          return {
                              'success': True,
                              'ai_response': "Legend challenge complete! Check your results.",
                              'call_continues': False,
                              'legend_complete': True,
                              'legend_status': self._get_legend_status(session)
                          }
                      
                      current_call = session['current_call_data']
                      
                      # Increment counters
                      current_call['turn_count'] += 1
                      session['overall_performance']['total_interactions'] += 1
                      
                      # Add user input to conversation
                      current_call['conversation_history'].append({
                          'role': 'user',
                          'content': user_input,
                          'timestamp': datetime.now(timezone.utc).isoformat(),
                          'stage': current_call['current_stage']
                      })
                      
                      # STRICT evaluation for Legend Mode
                      evaluation = self._evaluate_user_input_strict(session, user_input)
                      
                      # In Legend Mode, any failure immediately ends the call
                      if not evaluation.get('perfect', False):
                          logger.info("Legend Mode failure - imperfect performance detected")
                          return self._handle_legend_failure(session, evaluation)
                      
                      # Generate AI response for perfect performance
                      ai_response = self._generate_ai_response(session, user_input, evaluation)
                      
                      # Update session state
                      self._update_session_state(session, evaluation)
                      
                      # Check if current call should end (perfect completion)
                      call_should_end = self._should_current_call_end(session, evaluation)
                      
                      if call_should_end:
                          return self._handle_perfect_call_completion(session, ai_response, evaluation)
                      
                      # Add AI response to conversation
                      current_call['conversation_history'].append({
                          'role': 'assistant',
                          'content': ai_response,
                          'timestamp': datetime.now(timezone.utc).isoformat(),
                          'stage': current_call['current_stage'],
                          'evaluation': evaluation
                      })
                      
                      return {
                          'success': True,
                          'ai_response': ai_response,
                          'call_continues': True,
                          'evaluation': evaluation,
                          'legend_status': self._get_legend_status(session),
                          'current_call': session['legend_state']['current_call'],
                          'total_calls': session['legend_state']['total_calls']
                      }
                      
                  except Exception as e:
                      logger.error(f"Error processing Legend Mode input: {e}")
                      return {'success': False, 'error': str(e), 'call_continues': False}
              
              def _evaluate_user_input_strict(self, session: Dict, user_input: str) -> Dict[str, Any]:
                  """VERY strict evaluation for Legend Mode - must be perfect"""
                  try:
                      if self.is_openai_available():
                          # Use AI evaluation with LEGEND MODE strictness
                          evaluation = self.openai_service.evaluate_user_input(
                              user_input,
                              session['current_call_data']['conversation_history'],
                              'legend_mode_strict'  # Special mode for ultra-strict evaluation
                          )
                          
                          # In Legend Mode, score must be perfect (4/4 or equivalent)
                          max_score = evaluation.get('max_score', 4)
                          score = evaluation.get('score', 0)
                          evaluation['perfect'] = (score >= max_score)
                          
                          return evaluation
                      else:
                          return self._basic_strict_evaluation(user_input)
                          
                  except Exception as e:
                      logger.error(f"Legend Mode evaluation error: {e}")
                      return self._basic_strict_evaluation(user_input)
              
              def _basic_strict_evaluation(self, user_input: str) -> Dict[str, Any]:
                  """Ultra-strict basic evaluation for Legend Mode"""
                  score = 0
                  criteria_met = []
                  user_input_lower = user_input.lower().strip()
                  
                  # Must meet ALL criteria for each stage
                  required_phrases = ["i'm calling", "calling from", "calling about"]
                  contractions = ["i'm", "don't", "can't", "won't"]
                  empathy_phrases = ["know this is", "out of the blue", "sorry to"]
                  
                  if len(user_input.strip()) > 20:  # Higher bar
                      score += 1
                      criteria_met.append('substantial_opener')
                  
                  if any(phrase in user_input_lower for phrase in required_phrases):
                      score += 1
                      criteria_met.append('clear_opener')
                  
                  if any(contraction in user_input_lower for contraction in contractions):
                      score += 1
                      criteria_met.append('casual_tone')
                  
                  if any(empathy in user_input_lower for empathy in empathy_phrases):
                      score += 1
                      criteria_met.append('shows_empathy')
                  
                  # Legend Mode requires PERFECT score (4/4)
                  perfect = (score >= 4)
                  
                  return {
                      'score': score,
                      'max_score': 4,
                      'perfect': perfect,
                      'passed': perfect,
                      'criteria_met': criteria_met,
                      'feedback': f'Legend evaluation: {score}/4 criteria met',
                      'should_continue': perfect,
                      'hang_up_probability': 0.0 if perfect else 1.0,  # Immediate failure if not perfect
                      'source': 'legend_strict',
                      'stage': 'opener'
                  }
              
              def _handle_legend_failure(self, session: Dict, evaluation: Dict) -> Dict[str, Any]:
                  """Handle failure in Legend Mode"""
                  current_call = session['current_call_data']
                  legend_state = session['legend_state']
                  
                  # Mark call as failed
                  current_call['call_status'] = 'failed'
                  current_call['end_reason'] = 'imperfect_performance'
                  current_call['ended_at'] = datetime.now(timezone.utc).isoformat()
                  
                  # Record failure reason
                  failure_reason = f"Call {legend_state['current_call']}: {evaluation.get('feedback', 'Performance not perfect')}"
                  legend_state['failure_reasons'].append(failure_reason)
                  
                  # Update legend state
                  legend_state['failed_calls'] += 1
                  session['all_calls_data'].append(current_call)
                  
                  # Legend challenge failed
                  legend_state['is_complete'] = True
                  legend_state['is_legend'] = False
                  
                  failure_response = random.choice([
                      "Sorry, I'm not interested. Goodbye.",
                      "This doesn't sound right. I'm hanging up.",
                      "Not what I was expecting. Have a good day."
                  ])
                  
                  current_call['conversation_history'].append({
                      'role': 'assistant',
                      'content': failure_response,
                      'timestamp': datetime.now(timezone.utc).isoformat(),
                      'stage': current_call['current_stage'],
                      'failure': True
                  })
                  
                  return {
                      'success': True,
                      'ai_response': failure_response,
                      'call_continues': False,
                      'call_result': 'failed',
                      'legend_complete': True,
                      'legend_achieved': False,
                      'legend_status': self._get_legend_status(session),
                      'failure_reason': failure_reason
                  }
              
              def _handle_perfect_call_completion(self, session: Dict, ai_response: str, evaluation: Dict) -> Dict[str, Any]:
                  """Handle perfect call completion"""
                  current_call = session['current_call_data']
                  legend_state = session['legend_state']
                  
                  # Mark call as perfect
                  current_call['call_status'] = 'perfect'
                  current_call['end_reason'] = 'perfect_completion'
                  current_call['ended_at'] = datetime.now(timezone.utc).isoformat()
                  
                  # Add final AI response
                  success_response = random.choice([
                      "That sounds excellent. Send me the details and let's schedule a meeting.",
                      "Perfect! I'm very interested. When can we talk more?",
                      "Exactly what we need. Please send over the information."
                  ])
                  
                  current_call['conversation_history'].append({
                      'role': 'assistant',
                      'content': success_response,
                      'timestamp': datetime.now(timezone.utc).isoformat(),
                      'stage': 'perfect_completion',
                      'perfect': True
                  })
                  
                  # Update legend state
                  legend_state['perfect_calls'] += 1
                  session['all_calls_data'].append(current_call)
                  
                  # Check if legend achieved
                  if legend_state['perfect_calls'] >= legend_state['required_perfect']:
                      # LEGEND ACHIEVED!
                      legend_state['is_complete'] = True
                      legend_state['is_legend'] = True
                      
                      return {
                          'success': True,
                          'ai_response': success_response,
                          'call_continues': False,
                          'call_result': 'perfect',
                          'legend_complete': True,
                          'legend_achieved': True,
                          'legend_status': self._get_legend_status(session),
                          'congratulations': "ðŸ† LEGEND STATUS ACHIEVED! ðŸ†"
                      }
                  else:
                      # Continue to next call
                      return self._start_next_legend_call(session, success_response)
              
              def _start_next_legend_call(self, session: Dict, previous_response: str) -> Dict[str, Any]:
                  """Start the next call in legend challenge"""
                  legend_state = session['legend_state']
                  
                  # Increment call number
                  legend_state['current_call'] += 1
                  
                  # Initialize new call data
                  session['current_call_data'] = self._initialize_call_data()
                  
                  # Generate new initial response
                  initial_response = self._get_initial_response(session['user_context'])
                  
                  # Add to new call conversation
                  session['current_call_data']['conversation_history'].append({
                      'role': 'assistant',
                      'content': initial_response,
                      'timestamp': datetime.now(timezone.utc).isoformat(),
                      'stage': 'phone_pickup'
                  })
                  
                  logger.info(f"Started legend call {legend_state['current_call']}/{legend_state['total_calls']}")
                  
                  return {
                      'success': True,
                      'ai_response': initial_response,
                      'call_continues': True,
                      'call_result': 'next_call',
                      'previous_call_response': previous_response,
                      'legend_status': self._get_legend_status(session),
                      'new_call_started': True
                  }
              
              def _get_legend_status(self, session: Dict) -> Dict[str, Any]:
                  """Get current legend status"""
                  legend_state = session['legend_state']
                  return {
                      'current_call': legend_state['current_call'],
                      'total_calls': legend_state['total_calls'],
                      'perfect_calls': legend_state['perfect_calls'],
                      'failed_calls': legend_state['failed_calls'],
                      'required_perfect': legend_state['required_perfect'],
                      'is_complete': legend_state['is_complete'],
                      'is_legend': legend_state['is_legend'],
                      'calls_remaining': legend_state['total_calls'] - len(session['all_calls_data']),
                      'progress_percentage': (legend_state['perfect_calls'] / legend_state['required_perfect']) * 100,
                      'failure_reasons': legend_state.get('failure_reasons', [])
                  }
              
              # ... (Additional methods similar to Marathon mode but with perfect requirements)
              
              def _initialize_call_data(self) -> Dict[str, Any]:
                  """Initialize data for a new call"""
                  return {
                      'conversation_history': [],
                      'current_stage': 'phone_pickup',
                      'turn_count': 0,
                      'call_status': 'in_progress',
                      'end_reason': None,
                      'started_at': datetime.now(timezone.utc).isoformat()
                  }
              
              def _get_initial_response(self, user_context: Dict) -> str:
                  """Generate initial phone pickup response"""
                  responses = [
                      "Hello?", 
                      "Hi there.", 
                      "Good morning.", 
                      "Yes?",
                      f"{user_context.get('first_name', 'Alex')} speaking."
                  ]
                  return random.choice(responses)
          
          # ===== services/roleplay/configs/roleplay_1_3_config.py =====
          
          class Roleplay13Config:
              """Configuration for Roleplay 1.3 - Legend Mode"""
              
              ROLEPLAY_ID = "1.3"
              NAME = "Legend Mode"
              DESCRIPTION = "6 perfect calls in a row - the ultimate challenge"
              
              # Legend specific settings
              TOTAL_CALLS = 6
              PERFECT_CALLS_REQUIRED = 6
              
              # No tolerance for mistakes in Legend Mode
              PERFECTION_REQUIRED = True
              
              # Stage flow (same as other modes but stricter evaluation)
              STAGE_FLOW = {
                  'phone_pickup': 'opener_evaluation',
                  'opener_evaluation': 'early_objection',
                  'early_objection': 'objection_handling',
                  'objection_handling': 'mini_pitch',
                  'mini_pitch': 'soft_discovery',
                  'soft_discovery': 'perfect_completion'
              }
              
              # Silence thresholds (same as other modes)
              IMPATIENCE_THRESHOLD = 10000
              HANGUP_THRESHOLD = 15000
              
              # Perfect thresholds (must score maximum on everything)
              PERFECT_THRESHOLDS = {
                  'opener': 4,           # Must get 4/4
                  'objection_handling': 4, # Must get 4/4
                  'mini_pitch': 4,       # Must get 4/4
                  'soft_discovery': 3    # Must get 3/3
              }

    📄 roleplay_factory.py (4.3KB)
        Content:
          # ===== services/roleplay/roleplay_factory.py (SIMPLIFIED) =====
          
          import logging
          from typing import Dict, Any, Optional
          
          logger = logging.getLogger(__name__)
          
          class RoleplayFactory:
              """Simplified factory for creating roleplay instances"""
              
              @staticmethod
              def get_available_roleplays():
                  """Get list of available roleplay IDs"""
                  return ['1.1', '1.2', '1.3', '2.1', '2.2', '3', '4', '5']
              
              @staticmethod
              def create_roleplay(roleplay_id: str, openai_service=None):
                  """Create appropriate roleplay instance - SIMPLIFIED"""
                  try:
                      logger.info(f"Creating SIMPLE roleplay instance for ID: {roleplay_id}")
                      
                      # Import the base roleplay class
                      from services.roleplay.base_roleplay import BaseRoleplay
                      
                      # Create a simple roleplay instance for any ID
                      roleplay = BaseRoleplay(openai_service)
                      roleplay.roleplay_id = roleplay_id
                      
                      logger.info(f"âœ… Created simple roleplay instance for {roleplay_id}")
                      return roleplay
                          
                  except Exception as e:
                      logger.error(f"âŒ Error creating roleplay {roleplay_id}: {e}")
                      # Last resort fallback
                      from services.roleplay.base_roleplay import BaseRoleplay
                      fallback = BaseRoleplay(openai_service)
                      fallback.roleplay_id = roleplay_id
                      return fallback
              
              @staticmethod
              def get_roleplay_info(roleplay_id: str) -> Dict[str, Any]:
                  """Get roleplay configuration information"""
                  roleplay_configs = {
                      '1.1': {
                          'id': '1.1',
                          'name': 'Practice Mode',
                          'description': 'Single call with detailed coaching',
                          'icon': 'user-graduate',
                          'difficulty': 'Beginner',
                          'available': True
                      },
                      '1.2': {
                          'id': '1.2',
                          'name': 'Marathon Mode',
                          'description': '10 calls, need 6 to pass',
                          'icon': 'running',
                          'difficulty': 'Intermediate',
                          'available': True
                      },
                      '1.3': {
                          'id': '1.3',
                          'name': 'Legend Mode',
                          'description': '6 perfect calls in a row',
                          'icon': 'crown',
                          'difficulty': 'Expert',
                          'available': False
                      },
                      '2.1': {
                          'id': '2.1',
                          'name': 'Pitch Practice',
                          'description': 'Advanced pitch training',
                          'icon': 'bullhorn',
                          'difficulty': 'Advanced',
                          'available': False
                      },
                      '2.2': {
                          'id': '2.2',
                          'name': 'Pitch Marathon',
                          'description': '10 advanced calls',
                          'icon': 'running',
                          'difficulty': 'Expert',
                          'available': False
                      },
                      '3': {
                          'id': '3',
                          'name': 'Warm-up Challenge',
                          'description': '25 rapid-fire questions',
                          'icon': 'fire',
                          'difficulty': 'All Levels',
                          'available': True
                      },
                      '4': {
                          'id': '4',
                          'name': 'Full Cold Call',
                          'description': 'Complete simulation',
                          'icon': 'headset',
                          'difficulty': 'Advanced',
                          'available': True
                      },
                      '5': {
                          'id': '5',
                          'name': 'Power Hour',
                          'description': '10 consecutive calls',
                          'icon': 'bolt',
                          'difficulty': 'Expert',
                          'available': True
                      }
                  }
                  
                  if roleplay_id not in roleplay_configs:
                      logger.warning(f"No config found for roleplay {roleplay_id}")
                      return {
                          'id': roleplay_id,
                          'name': f'Roleplay {roleplay_id}',
                          'description': 'Roleplay training',
                          'icon': 'phone',
                          'difficulty': 'Unknown',
                          'available': True
                      }
                  
                  return roleplay_configs[roleplay_id]

    📄 __init__.py (0KB)
        (Empty file)

    📁 configs/
      📄 roleplay_1_1_config.py (21.8KB)
          Content:
            # ===== ENHANCED: services/roleplay/configs/roleplay_1_1_config.py =====
            
            class Roleplay11Config:
                """Enhanced Configuration for Roleplay 1.1 - Practice Mode
                
                OPTIMIZED FOR LOGICAL CONVERSATION FLOW AND ACCURATE SCORING
                """
                
                # Basic Info
                ROLEPLAY_ID = "1.1"
                NAME = "Practice Mode"
                DESCRIPTION = "Single call with detailed coaching and feedback"
                
                # ===== ENHANCED STAGE FLOW =====
                
                STAGE_FLOW = {
                    'phone_pickup': 'opener_evaluation',      # AI answers phone -> User gives opener
                    'opener_evaluation': 'early_objection',   # AI evaluates opener -> Gives objection
                    'early_objection': 'objection_handling',  # User handles objection
                    'objection_handling': 'mini_pitch',       # User gives mini pitch
                    'mini_pitch': 'soft_discovery',           # User asks discovery question
                    'soft_discovery': 'extended_conversation', # Continue natural conversation
                    'extended_conversation': 'call_ended'     # Natural end
                }
                
                # ===== ENHANCED EVALUATION CRITERIA =====
                
                EVALUATION_CRITERIA = {
                    'opener': {
                        'description': 'Evaluate opening statement for empathy, clarity, and engagement',
                        'criteria': [
                            {
                                'name': 'clear_introduction',
                                'description': 'Clearly states name and company/reason for calling',
                                'examples': ['Hi, this is John from TechCorp', 'calling from SalesCorp about your marketing'],
                                'keywords': ['calling from', 'this is', 'my name is', 'calling about'],
                                'weight': 1.5
                            },
                            {
                                'name': 'shows_empathy',
                                'description': 'Acknowledges interrupting their day or shows understanding',
                                'examples': ['know this is out of the blue', 'know you don\'t know me', 'unexpected call'],
                                'keywords': ['out of the blue', 'interrupting', 'don\'t know me', 'unexpected', 'busy'],
                                'weight': 2.0  # Higher weight for empathy
                            },
                            {
                                'name': 'natural_tone',
                                'description': 'Uses contractions and conversational language',
                                'examples': ["I'm calling", "don't want to", "we're helping", "can't take long"],
                                'keywords': ["i'm", "don't", "can't", "we're", "you're", "won't", "isn't"],
                                'weight': 1.0
                            },
                            {
                                'name': 'engaging_close',
                                'description': 'Ends with permission-seeking question',
                                'examples': ['Can I tell you why I\'m calling?', 'Mind if I explain?', 'Fair to ask why?'],
                                'patterns': [r'\?$', r'can i', r'mind if', r'fair to'],
                                'weight': 1.5
                            }
                        ],
                        'pass_threshold': 5.0,  # Out of 7 possible points (weighted)
                        'coaching_tips': {
                            'excellent': 'Outstanding opener! Perfect empathy, clarity, and natural tone.',
                            'good': 'Good opener! Consider adding more empathy: "I know this is out of the blue, but..."',
                            'needs_work': 'Focus on empathy first, then briefly state why you\'re calling. Try: "I know this is unexpected, but I\'m calling from [Company] because..."'
                        }
                    },
                    
                    'objection_handling': {
                        'description': 'How user responds to early objections with grace and forward momentum',
                        'criteria': [
                            {
                                'name': 'acknowledges_gracefully',
                                'description': 'Acknowledges objection without being defensive',
                                'examples': ['Fair enough', 'I understand', 'I get that', 'That makes sense'],
                                'keywords': ['fair enough', 'understand', 'get that', 'totally fair', 'makes sense'],
                                'negative_indicators': ['but you', 'you need', 'you should'],
                                'weight': 2.0
                            },
                            {
                                'name': 'stays_calm',
                                'description': 'Doesn\'t argue or get defensive',
                                'evaluation': 'no_defensive_language',
                                'negative_keywords': ['but you should', 'you need to understand', 'actually you do'],
                                'positive_tone': ['calm', 'understanding', 'respectful'],
                                'weight': 1.5
                            },
                            {
                                'name': 'brief_reason',
                                'description': 'Gives brief, compelling reason for calling (under 20 words)',
                                'examples': ['Quick reason I called...', 'The reason I reached out...'],
                                'max_words': 20,
                                'keywords': ['reason i called', 'why i reached out', 'quick reason'],
                                'weight': 1.5
                            },
                            {
                                'name': 'moves_forward',
                                'description': 'Asks for permission to continue or small commitment',
                                'examples': ['Can I get 30 seconds?', 'Fair to ask why?', 'Mind if I explain?'],
                                'keywords': ['30 seconds', 'quick question', 'fair to ask', 'mind if'],
                                'weight': 2.0
                            }
                        ],
                        'pass_threshold': 5.0,
                        'coaching_tips': {
                            'excellent': 'Perfect objection handling! You stayed calm and moved the conversation forward.',
                            'good': 'Good objection handling. Remember to acknowledge first, then briefly explain.',
                            'needs_work': 'Don\'t argue back. Try: "Fair enough. Quick reason I called is... Can I get 30 seconds?"'
                        }
                    },
                    
                    'mini_pitch': {
                        'description': 'Short, compelling pitch focused on outcomes',
                        'criteria': [
                            {
                                'name': 'concise_length',
                                'description': 'Under 25 words total',
                                'max_words': 25,
                                'weight': 1.0
                            },
                            {
                                'name': 'outcome_focused',
                                'description': 'Mentions benefits/results, not just features',
                                'positive_keywords': ['save', 'increase', 'improve', 'reduce', 'help companies', 'results'],
                                'negative_keywords': ['platform', 'software features', 'our tool', 'technology'],
                                'examples': ['help companies save 30%', 'increase revenue by', 'reduce costs'],
                                'weight': 2.5  # Most important for pitch
                            },
                            {
                                'name': 'specific_benefit',
                                'description': 'Includes specific numbers or concrete outcomes',
                                'examples': ['save 30%', 'increase by 50%', 'reduce time by 2 hours'],
                                'patterns': [r'\d+%', r'\$\d+', r'\d+\s*(hours|minutes|days)'],
                                'weight': 2.0
                            },
                            {
                                'name': 'conversational_tone',
                                'description': 'Sounds natural, not robotic or scripted',
                                'check_contractions': True,
                                'avoid_jargon': ['synergies', 'optimize', 'leverage', 'streamline', 'solution'],
                                'weight': 1.5
                            }
                        ],
                        'pass_threshold': 5.0,
                        'coaching_tips': {
                            'excellent': 'Perfect pitch! Short, specific, and outcome-focused.',
                            'good': 'Good pitch! Make it even shorter and more specific about results.',
                            'needs_work': 'Keep it under 20 words and focus on specific outcomes: "We help [type] companies save [X]% on [specific thing]."'
                        }
                    },
                    
                    'soft_discovery': {
                        'description': 'Asking discovery questions naturally',
                        'criteria': [
                            {
                                'name': 'relevant_to_pitch',
                                'description': 'Question relates directly to the pitch given',
                                'check_relevance': True,
                                'weight': 2.0
                            },
                            {
                                'name': 'open_ended',
                                'description': 'Uses "How", "What", "When" - not yes/no questions',
                                'question_starters': ['how', 'what', 'when', 'where', 'why', 'tell me'],
                                'avoid_yes_no': True,
                                'examples': ['How are you currently handling...', 'What\'s your process for...'],
                                'weight': 1.5
                            },
                            {
                                'name': 'curious_tone',
                                'description': 'Sounds genuinely curious, not pushy',
                                'soft_phrases': ['curious', 'wondering', 'mind me asking', 'interested to know'],
                                'avoid_aggressive': ['need to know', 'have to tell me', 'you must'],
                                'weight': 1.5
                            }
                        ],
                        'pass_threshold': 3.5,
                        'coaching_tips': {
                            'excellent': 'Great discovery question! Curious, relevant, and open-ended.',
                            'good': 'Good question! Make sure it ties directly to your pitch.',
                            'needs_work': 'Try open questions tied to your pitch: "How are you currently handling [specific area from pitch]?"'
                        }
                    }
                }
                
                # ===== ENHANCED AI PROSPECT BEHAVIOR =====
                
                PROSPECT_BEHAVIOR = {
                    'personality_traits': {
                        'base_personality': 'Busy but professional executive',
                        'initial_resistance': 'Moderate - willing to listen if approached right',
                        'empathy_sensitivity': 'High - responds well to empathy and respect',
                        'time_consciousness': 'Very high - values brevity and directness',
                        'decision_style': 'Analytical but practical'
                    },
                    
                    'response_patterns': {
                        'excellent_opener': [
                            "Alright, what's this about?",
                            "I'm listening. You have my attention.",
                            "You have 30 seconds. Go ahead.",
                            "Fair enough. What do you do?"
                        ],
                        'good_opener': [
                            "What's this regarding?",
                            "I'm busy, but go ahead.",
                            "Make it quick."
                        ],
                        'poor_opener': [
                            "I'm not interested.",
                            "We don't take cold calls.",
                            "How did you get this number?",
                            "Remove me from your list."
                        ],
                        'excellent_objection_handling': [
                            "Okay, you have my attention.",
                            "Fair enough. What exactly do you do?",
                            "Alright, I'm listening.",
                            "That's reasonable. Continue."
                        ],
                        'good_objection_handling': [
                            "Go on.",
                            "I'm listening.",
                            "What do you mean?"
                        ],
                        'poor_objection_handling': [
                            "I already told you I'm not interested.",
                            "You're not listening to me.",
                            "This is exactly why I hate cold calls.",
                            "Goodbye."
                        ],
                        'excellent_pitch': [
                            "That sounds interesting. How does that work?",
                            "Tell me more about that.",
                            "What kind of results do you typically see?",
                            "That could be relevant. Continue."
                        ],
                        'good_pitch': [
                            "Okay, I'm following.",
                            "That's intriguing.",
                            "Go on."
                        ],
                        'poor_pitch': [
                            "That's too vague.",
                            "I don't understand what you're saying.",
                            "Sounds like every other vendor.",
                            "We're all set, thanks."
                        ]
                    },
                    
                    'conversation_progression': {
                        'warmup_threshold': 3,  # Number of good responses needed to warm up
                        'interest_indicators': ['specific questions', 'asking for details', 'time investment'],
                        'disengagement_signals': ['short responses', 'looking to end', 'skeptical tone']
                    }
                }
                
                # ===== ENHANCED CONVERSATION LIMITS =====
                
                CONVERSATION_LIMITS = {
                    'max_total_turns': 14,          # Increased for natural conversation
                    'min_turns_for_success': 6,    # Minimum for meaningful conversation
                    'optimal_turn_range': (8, 12), # Sweet spot for practice mode
                    'max_stage_turns': {
                        'opener_evaluation': 2,
                        'objection_handling': 3,
                        'mini_pitch': 2,
                        'soft_discovery': 4,
                        'extended_conversation': 6
                    }
                }
                
                # ===== ENHANCED SCORING SYSTEM =====
                
                SCORING_WEIGHTS = {
                    'opener_score': 0.30,           # 30% - Critical first impression
                    'objection_handling_score': 0.30, # 30% - Shows sales skill
                    'pitch_score': 0.25,            # 25% - Core value proposition
                    'discovery_score': 0.15,        # 15% - Shows curiosity
                    'conversation_flow_bonus': 0.10, # 10% - Natural progression
                    'empathy_bonus': 0.05,          # 5% - Extra for showing empathy
                    'specificity_bonus': 0.05       # 5% - Extra for specific benefits
                }
                
                SUCCESS_CRITERIA = {
                    'minimum_score': 70,            # Need 70+ to pass
                    'excellent_threshold': 85,      # Excellent performance
                    'required_stages': ['opener_evaluation', 'objection_handling', 'mini_pitch'],
                    'bonus_stages': ['soft_discovery', 'extended_conversation'],
                    'critical_failures': {
                        'no_empathy': -10,          # Penalty for no empathy
                        'too_pushy': -15,           # Penalty for being pushy
                        'too_vague': -10,           # Penalty for vague pitch
                        'argues_with_prospect': -20  # Major penalty for arguing
                    }
                }
                
                # ===== ENHANCED COACHING TEMPLATES =====
                
                COACHING_TEMPLATES = {
                    'opener_feedback': {
                        'excellent': {
                            'message': 'Outstanding opener! You showed genuine empathy, were clear about why you were calling, and sounded completely natural. This is exactly how cold calls should start.',
                            'next_steps': 'Keep using this approach - it builds immediate trust and rapport.'
                        },
                        'good': {
                            'message': 'Good opener! You covered most of the basics well. Consider adding more empathy right at the start.',
                            'next_steps': 'Try: "I know this is completely out of the blue, but I\'m calling from [Company] because..."'
                        },
                        'needs_work': {
                            'message': 'Your opener needs more empathy and clarity. Start by acknowledging you\'re interrupting their day.',
                            'next_steps': 'Structure: Empathy â†’ Brief reason â†’ Permission. Example: "I know this is unexpected, but I\'m calling because we help companies like yours save 30% on [specific area]. Mind if I explain?"'
                        }
                    },
                    
                    'objection_feedback': {
                        'excellent': {
                            'message': 'Perfect objection handling! You stayed calm, acknowledged their concern, and smoothly moved the conversation forward.',
                            'next_steps': 'This is the gold standard - keep using this approach.'
                        },
                        'good': {
                            'message': 'Good objection handling. You stayed calm and professional.',
                            'next_steps': 'Remember the formula: Acknowledge â†’ Brief reason â†’ Ask permission. "Fair enough. Quick reason I called is [X]. Can I get 30 seconds?"'
                        },
                        'needs_work': {
                            'message': 'Don\'t argue with objections. Instead, acknowledge and redirect.',
                            'next_steps': 'Try: "I totally understand. The reason I called is [brief, specific reason]. Fair to ask why?" Never say "but you should" or argue back.'
                        }
                    },
                    
                    'pitch_feedback': {
                        'excellent': {
                            'message': 'Excellent pitch! Short, specific, and focused on concrete outcomes. This is how you capture attention.',
                            'next_steps': 'Perfect approach - specific benefits resonate much better than features.'
                        },
                        'good': {
                            'message': 'Good pitch! You kept it concise and benefit-focused.',
                            'next_steps': 'Make it even more specific with numbers: "We help [type] companies save [X]% on [specific thing]."'
                        },
                        'needs_work': {
                            'message': 'Your pitch needs to be shorter and more outcome-focused.',
                            'next_steps': 'Under 20 words. Formula: "We help [specific type] companies [specific outcome with number] on [specific area]." Avoid feature lists.'
                        }
                    },
                    
                    'discovery_feedback': {
                        'excellent': {
                            'message': 'Great discovery question! Open-ended, relevant to your pitch, and shows genuine curiosity.',
                            'next_steps': 'This shows you\'re consultative, not just pitching. Keep asking questions that relate to your value proposition.'
                        },
                        'good': {
                            'message': 'Good discovery approach. Your question was open-ended and relevant.',
                            'next_steps': 'Make sure every question ties directly back to the specific area you mentioned in your pitch.'
                        },
                        'needs_work': {
                            'message': 'Use open-ended questions that relate to your pitch.',
                            'next_steps': 'Try: "How are you currently handling [specific area from your pitch]?" or "What\'s your process for [relevant area]?"'
                        }
                    }
                }
                
                # ===== CONVERSATION QUALITY INDICATORS =====
                
                QUALITY_INDICATORS = {
                    'excellent_conversation': {
                        'prospect_engagement': ['asks questions', 'provides details', 'shows interest'],
                        'user_performance': ['natural flow', 'good listening', 'relevant responses'],
                        'overall_feel': 'Natural, consultative, professional'
                    },
                    'good_conversation': {
                        'prospect_engagement': ['stays on call', 'responds appropriately'],
                        'user_performance': ['follows structure', 'mostly natural'],
                        'overall_feel': 'Professional, somewhat engaging'
                    },
                    'needs_improvement': {
                        'prospect_engagement': ['short responses', 'trying to end call'],
                        'user_performance': ['rigid script', 'not listening', 'pushy'],
                        'overall_feel': 'Awkward, one-sided, unnatural'
                    }
                }
                
                # ===== HANG-UP TRIGGERS (ENHANCED) =====
                
                HANGUP_TRIGGERS = {
                    'immediate_hangup': {
                        'no_empathy_opener': 0.6,       # 60% chance if opener shows no empathy
                        'aggressive_response': 0.8,      # 80% chance if user argues aggressively
                        'pushy_after_objection': 0.7     # 70% chance if pushy after clear objection
                    },
                    'gradual_hangup': {
                        'poor_opener': 0.3,              # 30% chance if opener scores 0-1
                        'repeated_objections': 0.5,       # 50% chance if user ignores objections
                        'too_long_pitch': 0.4,           # 40% chance if pitch over 40 words
                        'no_questions': 0.3               # 30% chance if no discovery questions
                    },
                    'silence_hangup': {
                        'silence_15_seconds': 1.0        # 100% chance after 15 seconds silence
                    }
                }
                
                # ===== DYNAMIC DIFFICULTY ADJUSTMENT =====
                
                DIFFICULTY_LEVELS = {
                    'beginner_mode': {
                        'prospect_patience': 'high',
                        'objection_intensity': 'low',
                        'hang_up_probability': 0.5,      # Reduce all hang-up chances by 50%
                        'coaching_detail': 'high'
                    },
                    'standard_mode': {
                        'prospect_patience': 'medium',
                        'objection_intensity': 'medium',
                        'hang_up_probability': 1.0,      # Normal hang-up chances
                        'coaching_detail': 'medium'
                    },
                    'expert_mode': {
                        'prospect_patience': 'low',
                        'objection_intensity': 'high',
                        'hang_up_probability': 1.5,      # Increase hang-up chances by 50%
                        'coaching_detail': 'low'
                    }
                }
            
            # ===== IMPLEMENTATION NOTES =====
            """
            CRITICAL IMPROVEMENTS IN THIS VERSION:
            
            1. WEIGHTED SCORING SYSTEM:
               - Different criteria have different weights based on importance
               - Empathy gets highest weight in opener evaluation
               - Outcome-focus gets highest weight in pitch evaluation
            
            2. ENHANCED PROSPECT BEHAVIOR:
               - More nuanced responses based on user performance
               - Gradual warming up based on good performance
               - Realistic conversation progression
            
            3. BETTER CONVERSATION FLOW:
               - Natural stage transitions
               - Extended conversation phase for practice
               - Quality indicators for overall conversation assessment
            
            4. COMPREHENSIVE COACHING:
               - Specific feedback for each performance level
               - Actionable next steps for improvement
               - Templates that address exact issues
            
            5. LOGICAL HANG-UP SYSTEM:
               - Multiple trigger types (immediate, gradual, silence)
               - Realistic probability based on actual poor performance
               - Weighted by conversation quality
            
            TO USE THIS CONFIG:
            1. Replace the existing roleplay_1_1_config.py with this version
            2. Restart the roleplay service
            3. Test with various conversation styles to validate scoring
            4. Monitor for logical conversation flow and appropriate AI responses
            
            EXPECTED IMPROVEMENTS:
            - More accurate scoring based on actual sales effectiveness
            - More logical and natural AI responses
            - Better coaching that helps users improve specific skills
            - Reduced false hang-ups while maintaining realism
            """

      📄 roleplay_1_2_config.py (2.6KB)
          Content:
            # services/roleplay/configs/roleplay_1_2_config.py
            class Roleplay12Config:
                """Configuration for Roleplay 1.2 - Marathon Mode"""
                
                ROLEPLAY_ID = "1.2"
                NAME = "Marathon Mode"
                DESCRIPTION = "10 calls, need 6 to pass"
                
                # Marathon specific settings
                TOTAL_CALLS = 10
                CALLS_TO_PASS = 6
                RANDOM_HANGUP_CHANCE = 0.25  # 20-30% as specified
                
                # Stage flow (simpler than 1.1)
                STAGE_FLOW = {
                    'phone_pickup': 'opener_evaluation',
                    'opener_evaluation': 'early_objection',
                    'early_objection': 'objection_handling',
                    'objection_handling': 'mini_pitch',
                    'mini_pitch': 'soft_discovery',
                    'soft_discovery': 'call_ended'
                }
                
                # Silence thresholds (same as 1.1)
                IMPATIENCE_THRESHOLD = 10000
                HANGUP_THRESHOLD = 15000
                
                # Pass thresholds (same rubrics as 1.1)
                PASS_THRESHOLDS = {
                    'opener': 3,
                    'objection_handling': 3,
                    'mini_pitch': 3,
                    'soft_discovery': 2
                }
                
                # Objection list (29 items as specified)
                EARLY_OBJECTIONS = [
                    "What's this about?",
                    "I'm not interested",
                    "We don't take cold calls",
                    "Now is not a good time",
                    "I have a meeting",
                    "Can you call me later?",
                    "I'm about to go into a meeting",
                    "Send me an email",
                    "Can you send me the information?",
                    "Can you message me on WhatsApp?",
                    "Who gave you this number?",
                    "This is my personal number",
                    "Where did you get my number?",
                    "What are you trying to sell me?",
                    "Is this a sales call?",
                    "Is this a cold call?",
                    "Are you trying to sell me something?",
                    "We are ok for the moment",
                    "We are all good / all set",
                    "We're not looking for anything right now",
                    "We are not changing anything",
                    "How long is this going to take?",
                    "Is this going to take long?",
                    "What company are you calling from?",
                    "Who are you again?",
                    "Where are you calling from?",
                    "I never heard of you",
                    "Not interested right now",
                    "Just send me the details"
                ]
                
                # Impatience phrases
                IMPATIENCE_PHRASES = [
                    "Hello? Are you still with me?",
                    "Can you hear me?",
                    "Just checking you're thereâ€¦",
                    "Still on the line?",
                    "I don't have much time for this.",
                    "Sounds like you are gone.",
                    "Are you an idiot.",
                    "What is going on.",
                    "Are you okay to continue?",
                    "I am afraid I have to go"
                ]

📁 static/
  📁 audio/
    📁 temp/
  📁 css/
    📄 admin.css (0KB)
        (Empty file)

    📄 dashboard.css (11.4KB)
        Content:
          /* ===== STATIC/CSS/DASHBOARD.CSS (COMPLETE) ===== */
          
          /* Dashboard Layout */
          .dashboard-container {
              background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
              min-height: 100vh;
              padding: 2rem 0;
          }
          
          .dashboard-card {
              background: white;
              border-radius: 20px;
              padding: 2rem;
              box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
              border: 1px solid rgba(255, 255, 255, 0.8);
              transition: all 0.3s ease;
          }
          
          .dashboard-card:hover {
              transform: translateY(-2px);
              box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
          }
          
          /* Welcome Section */
          .welcome-section {
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              color: white;
              border-radius: 20px;
              padding: 2rem;
              margin-bottom: 2rem;
              position: relative;
              overflow: hidden;
          }
          
          .welcome-section::before {
              content: '';
              position: absolute;
              top: -50%;
              right: -50%;
              width: 100%;
              height: 100%;
              background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
              animation: float 6s ease-in-out infinite;
          }
          
          @keyframes float {
              0%, 100% { transform: translateY(0px) rotate(0deg); }
              50% { transform: translateY(-20px) rotate(180deg); }
          }
          
          .welcome-section h1 {
              font-weight: 700;
              margin-bottom: 0.5rem;
              text-shadow: 0 2px 4px rgba(0,0,0,0.1);
          }
          
          .welcome-section .lead {
              opacity: 0.9;
              font-weight: 300;
          }
          
          /* Access Level Badge */
          .access-level-badge {
              background: rgba(255, 255, 255, 0.2);
              backdrop-filter: blur(10px);
              border: 1px solid rgba(255, 255, 255, 0.3);
              border-radius: 25px;
              padding: 0.5rem 1rem;
              display: inline-flex;
              align-items: center;
              color: white;
              font-weight: 500;
              transition: all 0.3s ease;
          }
          
          .access-level-badge:hover {
              background: rgba(255, 255, 255, 0.3);
              transform: scale(1.05);
          }
          
          .access-level-badge.access-level-limited_trial {
              background: linear-gradient(45deg, #ffc107, #fd7e14);
              border-color: #ffc107;
          }
          
          .access-level-badge.access-level-unlimited_basic {
              background: linear-gradient(45deg, #17a2b8, #007bff);
              border-color: #17a2b8;
          }
          
          .access-level-badge.access-level-unlimited_pro {
              background: linear-gradient(45deg, #28a745, #20c997);
              border-color: #28a745;
          }
          
          /* Stats Grid */
          .stats-grid {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
              gap: 1.5rem;
              margin-bottom: 2rem;
          }
          
          .stat-card {
              background: white;
              border-radius: 15px;
              padding: 1.5rem;
              box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
              text-align: center;
              transition: all 0.3s ease;
              border: 1px solid rgba(0, 0, 0, 0.05);
              position: relative;
              overflow: hidden;
          }
          
          .stat-card::before {
              content: '';
              position: absolute;
              top: 0;
              left: 0;
              right: 0;
              height: 3px;
              background: linear-gradient(90deg, #667eea, #764ba2);
              opacity: 0;
              transition: opacity 0.3s ease;
          }
          
          .stat-card:hover {
              transform: translateY(-5px);
              box-shadow: 0 15px 35px rgba(0, 0, 0, 0.15);
          }
          
          .stat-card:hover::before {
              opacity: 1;
          }
          
          .stat-icon {
              font-size: 2rem;
              margin-bottom: 1rem;
              display: block;
          }
          
          .stat-number {
              font-size: 2rem;
              font-weight: 700;
              line-height: 1;
              margin-bottom: 0.5rem;
          }
          
          .stat-label {
              color: #6c757d;
              font-size: 0.9rem;
              text-transform: uppercase;
              letter-spacing: 0.5px;
              font-weight: 500;
          }
          
          /* Usage Meter */
          .usage-meter {
              background: white;
              border-radius: 15px;
              padding: 1.5rem;
              box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
              margin-bottom: 2rem;
          }
          
          .usage-meter h6 {
              color: #495057;
              font-weight: 600;
              margin-bottom: 1rem;
          }
          
          .progress {
              height: 12px;
              border-radius: 10px;
              background: #e9ecef;
              overflow: hidden;
              box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
          }
          
          .progress-bar {
              border-radius: 10px;
              transition: all 0.5s ease;
              background: linear-gradient(90deg, #28a745, #20c997);
              position: relative;
              overflow: hidden;
          }
          
          .progress-bar.bg-warning {
              background: linear-gradient(90deg, #ffc107, #fd7e14);
          }
          
          .progress-bar.bg-danger {
              background: linear-gradient(90deg, #dc3545, #c82333);
          }
          
          .progress-bar::after {
              content: '';
              position: absolute;
              top: 0;
              left: 0;
              right: 0;
              bottom: 0;
              background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.2) 50%, transparent 70%);
              animation: shimmer 2s infinite;
          }
          
          @keyframes shimmer {
              0% { transform: translateX(-100%); }
              100% { transform: translateX(100%); }
          }
          
          /* Roleplay Grid */
          .roleplay-grid {
              margin-bottom: 3rem;
          }
          
          .roleplay-card {
              transition: all 0.3s ease;
              cursor: pointer;
              height: 100%;
          }
          
          .roleplay-card .card {
              border: none;
              border-radius: 20px;
              box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
              transition: all 0.3s ease;
              height: 100%;
              overflow: hidden;
              position: relative;
          }
          
          .roleplay-card.unlocked .card {
              border: 2px solid transparent;
              background: linear-gradient(white, white) padding-box,
                          linear-gradient(45deg, #28a745, #20c997) border-box;
          }
          
          .roleplay-card.locked .card {
              opacity: 0.7;
              background: #f8f9fa;
          }
          
          .roleplay-card:hover .card {
              transform: translateY(-8px);
              box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
          }
          
          .roleplay-card.locked:hover .card {
              transform: translateY(-3px);
          }
          
          .roleplay-icon {
              font-size: 2.5rem;
              margin-bottom: 1rem;
          }
          
          .card-title {
              font-weight: 700;
              color: #2c3e50;
              margin-bottom: 1rem;
              font-size: 1.1rem;
          }
          
          .card-text {
              font-size: 0.9rem;
              line-height: 1.5;
              margin-bottom: 1rem;
          }
          
          .difficulty-badge .badge {
              font-size: 0.75rem;
              padding: 0.4rem 0.8rem;
              border-radius: 12px;
              font-weight: 500;
          }
          
          .card-footer {
              border-top: 1px solid rgba(0,0,0,0.05);
              background: rgba(0,0,0,0.02);
              padding: 1rem;
          }
          
          .card-footer .btn {
              border-radius: 12px;
              font-weight: 600;
              padding: 0.7rem 1.5rem;
              transition: all 0.3s ease;
          }
          
          .card-footer .btn:hover {
              transform: translateY(-2px);
              box-shadow: 0 5px 15px rgba(0,0,0,0.2);
          }
          
          /* Unlock Status */
          .unlock-status {
              position: absolute;
              top: 1rem;
              right: 1rem;
              font-size: 1.2rem;
          }
          
          .unlock-status.unlocked {
              color: #28a745;
          }
          
          .unlock-status.locked {
              color: #6c757d;
          }
          
          /* Recent Sessions Table */
          .sessions-table {
              background: white;
              border-radius: 20px;
              box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
              overflow: hidden;
          }
          
          .sessions-table .table {
              margin-bottom: 0;
          }
          
          .sessions-table .table thead th {
              border-top: none;
              border-bottom: 2px solid #e9ecef;
              background: #f8f9fa;
              font-weight: 600;
              color: #495057;
              text-transform: uppercase;
              font-size: 0.8rem;
              letter-spacing: 0.5px;
              padding: 1rem;
          }
          
          .sessions-table .table tbody td {
              border-top: 1px solid #f1f3f4;
              padding: 1rem;
              vertical-align: middle;
          }
          
          .sessions-table .table tbody tr {
              transition: background-color 0.2s ease;
          }
          
          .sessions-table .table tbody tr:hover {
              background-color: rgba(0,0,0,0.02);
          }
          
          /* Session Result Icons */
          .result-icon {
              width: 20px;
              height: 20px;
              border-radius: 50%;
              display: inline-flex;
              align-items: center;
              justify-content: center;
              font-size: 0.8rem;
              margin-right: 0.5rem;
          }
          
          .result-icon.success {
              background: #d4edda;
              color: #155724;
          }
          
          .result-icon.danger {
              background: #f8d7da;
              color: #721c24;
          }
          
          /* Badge Styles */
          .badge {
              font-weight: 500;
              padding: 0.5rem 0.75rem;
              border-radius: 10px;
          }
          
          .badge.bg-success {
              background: linear-gradient(45deg, #28a745, #20c997) !important;
          }
          
          .badge.bg-secondary {
              background: linear-gradient(45deg, #6c757d, #495057) !important;
          }
          
          .badge.bg-primary {
              background: linear-gradient(45deg, #007bff, #0056b3) !important;
          }
          
          /* Loading States */
          .loading-skeleton {
              background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
              background-size: 200% 100%;
              animation: loading 1.5s infinite;
              border-radius: 8px;
              height: 20px;
          }
          
          @keyframes loading {
              0% { background-position: 200% 0; }
              100% { background-position: -200% 0; }
          }
          
          .spinner-border {
              border-color: #667eea;
              border-right-color: transparent;
          }
          
          /* Responsive Design */
          @media (max-width: 768px) {
              .dashboard-container {
                  padding: 1rem 0;
              }
              
              .welcome-section,
              .dashboard-card,
              .usage-meter,
              .sessions-table {
                  border-radius: 15px;
                  padding: 1.5rem;
                  margin-bottom: 1.5rem;
              }
              
              .stats-grid {
                  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                  gap: 1rem;
              }
              
              .stat-card {
                  padding: 1rem;
              }
              
              .stat-number {
                  font-size: 1.5rem;
              }
              
              .stat-icon {
                  font-size: 1.5rem;
              }
              
              .roleplay-icon {
                  font-size: 2rem;
              }
              
              .card-title {
                  font-size: 1rem;
              }
              
              .sessions-table .table thead th,
              .sessions-table .table tbody td {
                  padding: 0.75rem 0.5rem;
                  font-size: 0.9rem;
              }
          }
          
          @media (max-width: 576px) {
              .stats-grid {
                  grid-template-columns: repeat(2, 1fr);
              }
              
              .welcome-section h1 {
                  font-size: 1.5rem;
              }
              
              .welcome-section .lead {
                  font-size: 1rem;
              }
              
              .access-level-badge {
                  font-size: 0.8rem;
                  padding: 0.4rem 0.8rem;
              }
          }
          
          /* Dark Mode Support */
          @media (prefers-color-scheme: dark) {
              .dashboard-container {
                  background: linear-gradient(135deg, #1a1a1a 0%, #2d3748 100%);
              }
              
              .dashboard-card,
              .usage-meter,
              .sessions-table {
                  background: #2d3748;
                  color: #e2e8f0;
                  border-color: #4a5568;
              }
              
              .stat-card {
                  background: #2d3748;
                  color: #e2e8f0;
                  border-color: #4a5568;
              }
              
              .card-title {
                  color: #e2e8f0;
              }
              
              .sessions-table .table thead th {

    📄 main.css (5.1KB)
        Content:
          
          :root {
              --primary-color: #007bff;
              --secondary-color: #6c757d;
              --success-color: #28a745;
              --danger-color: #dc3545;
              --warning-color: #ffc107;
              --info-color: #17a2b8;
              --light-color: #f8f9fa;
              --dark-color: #343a40;
          }
          
          body {
              font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
              line-height: 1.6;
          }
          
          .bg-gradient-primary {
              background: linear-gradient(135deg, var(--primary-color) 0%, #0056b3 100%);
          }
          
          .hero-section {
              min-height: 80vh;
              display: flex;
              align-items: center;
          }
          
          .card {
              transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
          }
          
          .card:hover {
              transform: translateY(-5px);
              box-shadow: 0 10px 25px rgba(0,0,0,0.1) !important;
          }
          
          .roleplay-card {
              border-radius: 15px;
              overflow: hidden;
              transition: all 0.3s ease;
          }
          
          .roleplay-card:hover {
              transform: scale(1.02);
              box-shadow: 0 15px 35px rgba(0,0,0,0.1);
          }
          
          .roleplay-card.locked {
              opacity: 0.6;
              filter: grayscale(50%);
          }
          
          .progress-bar {
              transition: width 0.5s ease-in-out;
          }
          
          .voice-controls {
              background: white;
              border-radius: 20px;
              padding: 2rem;
              box-shadow: 0 10px 30px rgba(0,0,0,0.1);
              margin: 2rem 0;
          }
          
          .mic-button {
              width: 100px;
              height: 100px;
              border-radius: 50%;
              border: none;
              font-size: 2rem;
              transition: all 0.3s ease;
              position: relative;
              overflow: hidden;
          }
          
          .mic-button:hover {
              transform: scale(1.1);
          }
          
          .mic-button.recording {
              animation: pulse 1.5s infinite;
          }
          
          @keyframes pulse {
              0% {
                  box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7);
              }
              70% {
                  box-shadow: 0 0 0 20px rgba(220, 53, 69, 0);
              }
              100% {
                  box-shadow: 0 0 0 0 rgba(220, 53, 69, 0);
              }
          }
          
          .prospect-avatar {
              width: 150px;
              height: 150px;
              border-radius: 50%;
              object-fit: cover;
              border: 5px solid white;
              box-shadow: 0 5px 15px rgba(0,0,0,0.2);
          }
          
          .conversation-log {
              max-height: 400px;
              overflow-y: auto;
              padding: 1rem;
              background: var(--light-color);
              border-radius: 10px;
          }
          
          .message {
              margin-bottom: 1rem;
              padding: 0.75rem 1rem;
              border-radius: 15px;
              max-width: 80%;
          }
          
          .message.user {
              background: var(--primary-color);
              color: white;
              margin-left: auto;
              text-align: right;
          }
          
          .message.ai {
              background: white;
              color: var(--dark-color);
              border: 1px solid #dee2e6;
          }
          
          .coaching-panel {
              background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
              border-radius: 15px;
              padding: 2rem;
              margin-top: 2rem;
          }
          
          .feedback-category {
              background: white;
              border-radius: 10px;
              padding: 1rem;
              margin-bottom: 1rem;
              border-left: 4px solid var(--primary-color);
          }
          
          .usage-meter {
              background: var(--light-color);
              border-radius: 20px;
              padding: 1rem;
              margin: 1rem 0;
          }
          
          .access-level-badge {
              padding: 0.5rem 1rem;
              border-radius: 20px;
              font-weight: 600;
              text-transform: uppercase;
              font-size: 0.75rem;
          }
          
          .access-level-trial {
              background: var(--warning-color);
              color: var(--dark-color);
          }
          
          .access-level-basic {
              background: var(--info-color);
              color: white;
          }
          
          .access-level-pro {
              background: var(--success-color);
              color: white;
          }
          
          /* Responsive adjustments */
          @media (max-width: 768px) {
              .hero-section {
                  min-height: 60vh;
                  text-align: center;
              }
              
              .prospect-avatar {
                  width: 100px;
                  height: 100px;
              }
              
              .mic-button {
                  width: 80px;
                  height: 80px;
                  font-size: 1.5rem;
              }
              
              .voice-controls {
                  padding: 1rem;
              }
          }
          
          /* Loading animations */
          .loading-spinner {
              display: inline-block;
              width: 20px;
              height: 20px;
              border: 3px solid rgba(255,255,255,.3);
              border-radius: 50%;
              border-top-color: #fff;
              animation: spin 1s ease-in-out infinite;
          }
          
          @keyframes spin {
              to { transform: rotate(360deg); }
          }
          
          /* Form styling */
          .form-control:focus {
              border-color: var(--primary-color);
              box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
          }
          
          .btn {
              border-radius: 8px;
              padding: 0.75rem 1.5rem;
              font-weight: 600;
              transition: all 0.2s ease;
          }
          
          .btn:hover {
              transform: translateY(-1px);
          }
          
          /* Dashboard specific styles */
          .dashboard-card {
              background: white;
              border-radius: 15px;
              padding: 2rem;
              box-shadow: 0 5px 15px rgba(0,0,0,0.08);
              margin-bottom: 2rem;
          }
          
          .stats-grid {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
              gap: 1.5rem;
              margin-bottom: 2rem;
          }
          
          .stat-card {
              text-align: center;
              padding: 1.5rem;
              background: white;
              border-radius: 12px;
              box-shadow: 0 3px 10px rgba(0,0,0,0.1);
          }
          
          .stat-number {
              font-size: 2.5rem;
              font-weight: 700;
              margin-bottom: 0.5rem;
          }
          
          .stat-label {
              color: var(--secondary-color);
              font-size: 0.9rem;
              text-transform: uppercase;
              letter-spacing: 0.5px;
          }

    📄 roleplay.css (36.2KB)
        Content:
          body {
              background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
              min-height: 100vh;
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
              margin: 0;
          }
          
          .training-container {
              min-height: 100vh;
              display: flex;
              align-items: center;
              justify-content: center;
              padding: 20px;
          }
          
          /* Phone Container with Roleplay 1.1 enhancements */
          .phone-container {
              width: 380px;
              height: 680px;
              background: #000;
              border-radius: 40px;
              padding: 20px;
              box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
              position: relative;
              overflow: hidden;
              transition: all 0.3s ease;
          }
          
          .phone-container.roleplay-11-active {
              box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4), 0 0 30px rgba(34, 197, 94, 0.3);
              border: 2px solid rgba(34, 197, 94, 0.5);
          }
          
          .phone-screen {
              width: 100%;
              height: 100%;
              background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
              border-radius: 25px;
              position: relative;
              overflow: hidden;
          }
          
          /* Status Bar with Roleplay 1.1 indicator */
          .status-bar {
              display: flex;
              justify-content: space-between;
              align-items: center;
              padding: 10px 20px;
              color: white;
              font-size: 14px;
              font-weight: 600;
          }
          
          .status-bar.roleplay-11-active::after {
              content: "R1.1";
              background: rgba(34, 197, 94, 0.9);
              color: white;
              padding: 2px 6px;
              border-radius: 8px;
              font-size: 10px;
              font-weight: bold;
          }
          
          .time {
              font-size: 16px;
          }
          
          .status-icons {
              display: flex;
              gap: 5px;
          }
          
          /* Call Interface */
          .call-interface {
              height: calc(100% - 50px);
              display: flex;
              flex-direction: column;
              align-items: center;
              justify-content: space-between;
              padding: 20px;
              color: white;
              text-align: center;
          }
          
          /* Call Status */
          .call-status {
              flex: 1;
              display: flex;
              flex-direction: column;
              align-items: center;
              justify-content: center;
              transition: all 0.3s ease;
          }
          
          .contact-avatar {
              width: 150px;
              height: 150px;
              border-radius: 50%;
              border: 4px solid rgba(255, 255, 255, 0.3);
              object-fit: cover;
              margin-bottom: 20px;
              transition: all 0.3s ease;
              box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
          }
          
          .contact-avatar.calling {
              animation: pulse-avatar 2s infinite;
          }
          
          /* Roleplay 1.1 specific avatar styling */
          .contact-avatar.roleplay-11-active {
              border: 4px solid rgba(34, 197, 94, 0.8);
              box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3), 0 0 20px rgba(34, 197, 94, 0.3);
              animation: roleplay-11-glow 3s ease-in-out infinite alternate;
          }
          
          @keyframes pulse-avatar {
              0%, 100% { 
                  transform: scale(1);
                  border-color: rgba(255, 255, 255, 0.3);
              }
              50% { 
                  transform: scale(1.05);
                  border-color: rgba(34, 197, 94, 0.8);
              }
          }
          
          @keyframes roleplay-11-glow {
              from { 
                  border-color: rgba(34, 197, 94, 0.5);
                  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3), 0 0 15px rgba(34, 197, 94, 0.3);
              }
              to { 
                  border-color: rgba(34, 197, 94, 0.9);
                  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3), 0 0 25px rgba(34, 197, 94, 0.6);
              }
          }
          
          .contact-name {
              font-size: 28px;
              font-weight: 300;
              margin-bottom: 10px;
              letter-spacing: 0.5px;
          }
          
          .contact-info {
              font-size: 16px;
              color: rgba(255, 255, 255, 0.7);
              margin-bottom: 20px;
          }
          
          .call-status-text {
              font-size: 18px;
              color: rgba(255, 255, 255, 0.9);
              margin-bottom: 10px;
              min-height: 25px;
          }
          
          .call-duration {
              font-size: 16px;
              color: rgba(34, 197, 94, 1);
              font-weight: 500;
              font-variant-numeric: tabular-nums;
          }
          
          /* Call Controls with Roleplay 1.1 enhancements */
          .call-controls {
              display: flex;
              justify-content: center;
              align-items: center;
              gap: 40px;
              margin-bottom: 30px;
          }
          
          .control-btn {
              width: 65px;
              height: 65px;
              border-radius: 50%;
              border: none;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 24px;
              color: white;
              cursor: pointer;
              transition: all 0.3s ease;
              position: relative;
              overflow: hidden;
          }
          
          .control-btn:hover {
              transform: scale(1.1);
          }
          
          .control-btn:active {
              transform: scale(0.95);
          }
          
          .control-btn.mute {
              background: rgba(255, 255, 255, 0.2);
          }
          
          .control-btn.mute.active {
              background: rgba(239, 68, 68, 0.9);
          }
          
          .control-btn.speaker {
              background: rgba(255, 255, 255, 0.2);
          }
          
          .control-btn.speaker.active {
              background: rgba(59, 130, 246, 0.9);
          }
          
          .control-btn.mic {
              background: rgba(34, 197, 94, 0.9);
              box-shadow: 0 4px 20px rgba(34, 197, 94, 0.4);
          }
          
          .control-btn.mic.recording {
              background: rgba(239, 68, 68, 0.9);
              animation: pulse-record 1.5s infinite;
          }
          
          /* Enhanced recording animation for Roleplay 1.1 */
          @keyframes pulse-record {
              0%, 100% { 
                  box-shadow: 0 4px 20px rgba(239, 68, 68, 0.4);
                  transform: scale(1);
              }
              50% { 
                  box-shadow: 0 4px 30px rgba(239, 68, 68, 0.8), 0 0 0 10px rgba(239, 68, 68, 0.2);
                  transform: scale(1.05);
              }
          }
          
          /* End Call Button */
          .end-call-container {
              display: flex;
              justify-content: center;
          }
          
          .end-call-btn {
              width: 65px;
              height: 65px;
              border-radius: 50%;
              border: none;
              background: rgba(239, 68, 68, 0.9);
              color: white;
              font-size: 28px;
              cursor: pointer;
              transition: all 0.3s ease;
              box-shadow: 0 4px 20px rgba(239, 68, 68, 0.4);
          }
          
          .end-call-btn:hover {
              transform: scale(1.1);
              background: rgba(220, 38, 38, 1);
          }
          
          .end-call-btn:active {
              transform: scale(0.95);
          }
          
          /* Call States */
          .call-interface.dialing .call-status-text {
              color: rgba(59, 130, 246, 1);
          }
          
          .call-interface.ringing .call-status-text {
              color: rgba(251, 191, 36, 1);
              animation: blink 1s infinite;
          }
          
          .call-interface.connected .call-status-text {
              color: rgba(34, 197, 94, 1);
          }
          
          .call-interface.ended .call-status-text {
              color: rgba(239, 68, 68, 1);
          }
          
          @keyframes blink {
              0%, 50% { opacity: 1; }
              51%, 100% { opacity: 0.5; }
          }
          
          /* Mode Selection enhanced for Roleplay 1.1 */
          .mode-selection {
              position: absolute;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
              border-radius: 25px;
              display: flex;
              flex-direction: column;
              align-items: center;
              justify-content: center;
              padding: 20px;
              z-index: 10;
          }
          
          .mode-selection h3 {
              color: white;
              margin-bottom: 10px;
              text-align: center;
              font-weight: 300;
          }
          
          .mode-selection .roleplay-version {
              color: rgba(34, 197, 94, 1);
              font-size: 14px;
              margin-bottom: 20px;
              font-weight: 500;
          }
          
          .mode-grid {
              display: grid;
              grid-template-columns: 1fr;
              gap: 15px;
              width: 100%;
              max-width: 280px;
          }
          
          .mode-option {
              background: rgba(255, 255, 255, 0.1);
              border: 2px solid rgba(255, 255, 255, 0.2);
              border-radius: 15px;
              padding: 20px;
              color: white;
              text-align: center;
              cursor: pointer;
              transition: all 0.3s ease;
              position: relative;
          }
          
          .mode-option:hover {
              background: rgba(255, 255, 255, 0.2);
              border-color: rgba(255, 255, 255, 0.4);
              transform: translateY(-2px);
          }
          
          .mode-option.selected {
              background: rgba(34, 197, 94, 0.3);
              border-color: rgba(34, 197, 94, 0.8);
          }
          
          /* Roleplay 1.1 specific mode option styling */
          .mode-option.roleplay-11::after {
              content: "New!";
              position: absolute;
              top: -5px;
              right: -5px;
              background: rgba(34, 197, 94, 0.9);
              color: white;
              padding: 2px 6px;
              border-radius: 8px;
              font-size: 10px;
              font-weight: bold;
          }
          
          .mode-option h5 {
              margin: 10px 0 5px 0;
              font-weight: 500;
          }
          
          .mode-option small {
              opacity: 0.8;
          }
          
          .start-call-btn {
              margin-top: 20px;
              background: rgba(34, 197, 94, 0.9);
              border: none;
              border-radius: 25px;
              padding: 15px 40px;
              color: white;
              font-size: 16px;
              font-weight: 500;
              cursor: pointer;
              transition: all 0.3s ease;
              width: 100%;
          }
          
          .start-call-btn:hover:not(:disabled) {
              background: rgba(34, 197, 94, 1);
              transform: translateY(-2px);
          }
          
          .start-call-btn:disabled {
              background: rgba(255, 255, 255, 0.2);
              cursor: not-allowed;
              opacity: 0.6;
          }
          
          /* Feedback Section enhanced for Roleplay 1.1 */
          .feedback-section {
              position: absolute;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
              border-radius: 25px;
              display: none;
              flex-direction: column;
              padding: 20px;
              z-index: 10;
              overflow-y: auto;
          }
          
          .feedback-header {
              text-align: center;
              color: white;
              margin-bottom: 20px;
          }
          
          .feedback-header .roleplay-badge {
              background: rgba(34, 197, 94, 0.9);
              color: white;
              padding: 4px 8px;
              border-radius: 10px;
              font-size: 12px;
              font-weight: bold;
              margin-bottom: 10px;
          }
          
          .score-circle {
              width: 80px;
              height: 80px;
              border-radius: 50%;
              background: rgba(34, 197, 94, 0.9);
              display: flex;
              align-items: center;
              justify-content: center;
              margin: 0 auto 10px;
              font-size: 24px;
              font-weight: bold;
              color: white;
              transition: all 0.3s ease;
          }
          
          .score-circle.excellent {
              background: rgba(34, 197, 94, 0.9);
          }
          
          .score-circle.good {
              background: rgba(59, 130, 246, 0.9);
          }
          
          .score-circle.needs-improvement {
              background: rgba(251, 191, 36, 0.9);
          }
          
          .feedback-item {
              background: rgba(255, 255, 255, 0.1);
              border-radius: 10px;
              padding: 15px;
              margin-bottom: 10px;
              color: white;
              transition: all 0.3s ease;
          }
          
          .feedback-item:hover {
              background: rgba(255, 255, 255, 0.15);
          }
          
          .feedback-item h6 {
              margin-bottom: 8px;
              color: rgba(34, 197, 94, 1);
              display: flex;
              align-items: center;
          }
          
          /* Special styling for consecutive passes message */
          .feedback-item.consecutive-passes {
              background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(16, 185, 129, 0.1));
              border: 2px solid #22c55e;
              animation: celebrate 2s ease-in-out;
          }
          
          @keyframes celebrate {
              0%, 100% { transform: scale(1); }
              50% { transform: scale(1.02); }
          }
          
          .feedback-actions {
              margin-top: auto;
              display: flex;
              gap: 10px;
          }
          
          .feedback-btn {
              flex: 1;
              background: rgba(255, 255, 255, 0.2);
              border: none;
              border-radius: 10px;
              padding: 12px;
              color: white;

    📄 voice.css (10.2KB)
        Content:
          /* ===== STATIC/CSS/VOICE.CSS - Voice Interface Styles ===== */
          
          /* Microphone Button Styles */
          .mic-button {
              width: 80px;
              height: 80px;
              border-radius: 50%;
              border: none;
              font-size: 1.8rem;
              transition: all 0.3s ease;
              position: relative;
              overflow: hidden;
              box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
          }
          
          .mic-button:hover {
              transform: translateY(-2px);
              box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
          }
          
          .mic-button:active {
              transform: translateY(0);
          }
          
          .mic-button.listening {
              animation: pulse 1.5s infinite;
              box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7);
          }
          
          @keyframes pulse {
              0% {
                  transform: scale(1);
                  box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7);
              }
              70% {
                  transform: scale(1.05);
                  box-shadow: 0 0 0 10px rgba(220, 53, 69, 0);
              }
              100% {
                  transform: scale(1);
                  box-shadow: 0 0 0 0 rgba(220, 53, 69, 0);
              }
          }
          
          .mic-button:disabled {
              opacity: 0.6;
              cursor: not-allowed;
              transform: none !important;
          }
          
          .mic-button:disabled:hover {
              transform: none;
              box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
          }
          
          /* Live Transcript Display */
          .transcript-display {
              background: #f8f9fa;
              border: 2px solid #e9ecef;
              border-radius: 15px;
              padding: 1.5rem;
              min-height: 100px;
              position: relative;
              transition: border-color 0.3s ease;
          }
          
          .transcript-display.active {
              border-color: #007bff;
              background: rgba(0, 123, 255, 0.05);
          }
          
          .live-transcript {
              font-size: 1.1rem;
              line-height: 1.6;
              color: #495057;
              min-height: 60px;
              display: flex;
              align-items: center;
              justify-content: center;
              text-align: center;
              position: relative;
          }
          
          .live-transcript.listening {
              color: #007bff;
              font-weight: 500;
          }
          
          .live-transcript.speaking {
              color: #28a745;
              font-weight: 500;
          }
          
          /* Voice Status Indicator */
          .voice-status {
              display: flex;
              align-items: center;
              justify-content: center;
              gap: 0.5rem;
              margin-bottom: 1rem;
              font-weight: 500;
          }
          
          .voice-status.listening {
              color: #007bff;
          }
          
          .voice-status.speaking {
              color: #28a745;
          }
          
          .voice-status.error {
              color: #dc3545;
          }
          
          .voice-status i {
              font-size: 1.2rem;
          }
          
          /* AI Status Indicator */
          .ai-status-indicator {
              margin-bottom: 1rem;
          }
          
          .ai-status {
              display: inline-flex;
              align-items: center;
              padding: 0.5rem 1rem;
              border-radius: 20px;
              font-size: 0.9rem;
              font-weight: 500;
              transition: all 0.3s ease;
          }
          
          .ai-status.listening {
              background: rgba(0, 123, 255, 0.1);
              color: #007bff;
              border: 1px solid rgba(0, 123, 255, 0.2);
          }
          
          .ai-status.speaking {
              background: rgba(40, 167, 69, 0.1);
              color: #28a745;
              border: 1px solid rgba(40, 167, 69, 0.2);
              animation: speakingPulse 1s infinite;
          }
          
          @keyframes speakingPulse {
              0%, 100% { opacity: 1; }
              50% { opacity: 0.7; }
          }
          
          .ai-status.error {
              background: rgba(220, 53, 69, 0.1);
              color: #dc3545;
              border: 1px solid rgba(220, 53, 69, 0.2);
          }
          
          .ai-status i {
              margin-right: 0.5rem;
              animation: none;
          }
          
          .ai-status.listening i {
              animation: listening 2s infinite;
          }
          
          @keyframes listening {
              0%, 100% { transform: scale(1); }
              50% { transform: scale(1.1); }
          }
          
          /* Voice Error Display */
          .voice-error {
              border-radius: 10px;
              border-left: 4px solid #dc3545;
              animation: slideInDown 0.3s ease;
          }
          
          @keyframes slideInDown {
              from {
                  opacity: 0;
                  transform: translateY(-10px);
              }
              to {
                  opacity: 1;
                  transform: translateY(0);
              }
          }
          
          /* Permission Instructions */
          .permission-instructions {
              text-align: center;
              padding: 2rem;
              background: #fff3cd;
              border: 1px solid #ffeaa7;
              border-radius: 10px;
              color: #856404;
          }
          
          .permission-instructions h6 {
              color: #856404;
              margin-bottom: 1rem;
          }
          
          .permission-instructions ol {
              text-align: left;
              display: inline-block;
              margin: 1rem 0;
          }
          
          .permission-instructions li {
              margin-bottom: 0.5rem;
          }
          
          /* Keyboard Shortcuts Display */
          .keyboard-shortcuts {
              background: rgba(0, 0, 0, 0.05);
              border-radius: 8px;
              padding: 1rem;
              margin-top: 1rem;
              font-size: 0.9rem;
          }
          
          .keyboard-shortcuts h6 {
              margin-bottom: 0.5rem;
              color: #495057;
          }
          
          .shortcut {
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 0.25rem;
          }
          
          .shortcut kbd {
              background-color: #e9ecef;
              border: 1px solid #adb5bd;
              border-radius: 3px;
              box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2);
              color: #495057;
              display: inline-block;
              font-size: 0.8rem;
              font-weight: 700;
              line-height: 1;
              padding: 0.2rem 0.4rem;
              white-space: nowrap;
          }
          
          /* Voice Waveform Animation */
          .voice-waveform {
              display: flex;
              align-items: center;
              justify-content: center;
              gap: 2px;
              height: 30px;
              margin: 1rem 0;
          }
          
          .voice-waveform.active .wave-bar {
              animation: waveform 1.5s infinite ease-in-out;
          }
          
          .wave-bar {
              width: 3px;
              height: 10px;
              background: #007bff;
              border-radius: 2px;
              opacity: 0.3;
          }
          
          .wave-bar:nth-child(1) { animation-delay: 0s; }
          .wave-bar:nth-child(2) { animation-delay: 0.1s; }
          .wave-bar:nth-child(3) { animation-delay: 0.2s; }
          .wave-bar:nth-child(4) { animation-delay: 0.3s; }
          .wave-bar:nth-child(5) { animation-delay: 0.4s; }
          .wave-bar:nth-child(6) { animation-delay: 0.5s; }
          .wave-bar:nth-child(7) { animation-delay: 0.4s; }
          .wave-bar:nth-child(8) { animation-delay: 0.3s; }
          .wave-bar:nth-child(9) { animation-delay: 0.2s; }
          .wave-bar:nth-child(10) { animation-delay: 0.1s; }
          
          @keyframes waveform {
              0%, 100% {
                  height: 10px;
                  opacity: 0.3;
              }
              50% {
                  height: 25px;
                  opacity: 1;
              }
          }
          
          /* Conversation Log Enhancements */
          .conversation-log {
              max-height: 400px;
              overflow-y: auto;
              padding: 1rem;
              scroll-behavior: smooth;
          }
          
          .message {
              margin-bottom: 1rem;
              padding: 0.75rem;
              border-radius: 10px;
              position: relative;
              animation: messageSlideIn 0.3s ease;
          }
          
          @keyframes messageSlideIn {
              from {
                  opacity: 0;
                  transform: translateY(10px);
              }
              to {
                  opacity: 1;
                  transform: translateY(0);
              }
          }
          
          .message.user {
              background: rgba(0, 123, 255, 0.1);
              border-left: 4px solid #007bff;
              margin-left: 1rem;
          }
          
          .message.ai {
              background: rgba(40, 167, 69, 0.1);
              border-left: 4px solid #28a745;
              margin-right: 1rem;
          }
          
          .message-content {
              margin-bottom: 0.25rem;
              line-height: 1.5;
          }
          
          .message-time {
              font-size: 0.75rem;
              opacity: 0.7;
              color: #6c757d;
          }
          
          /* Training Controls */
          .training-controls {
              display: flex;
              gap: 1rem;
              justify-content: center;
              margin-top: 2rem;
              flex-wrap: wrap;
          }
          
          .training-controls .btn {
              border-radius: 25px;
              padding: 0.75rem 1.5rem;
              font-weight: 500;
              transition: all 0.3s ease;
          }
          
          .training-controls .btn:hover {
              transform: translateY(-2px);
              box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
          }
          
          /* Responsive Design */
          @media (max-width: 768px) {
              .mic-button {
                  width: 70px;
                  height: 70px;
                  font-size: 1.5rem;
              }
              
              .transcript-display {
                  padding: 1rem;
                  min-height: 80px;
              }
              
              .live-transcript {
                  font-size: 1rem;
                  min-height: 50px;
              }
              
              .training-controls {
                  gap: 0.5rem;
              }
              
              .training-controls .btn {
                  padding: 0.5rem 1rem;
                  font-size: 0.9rem;
              }
              
              .conversation-log {
                  max-height: 250px;
                  padding: 0.75rem;
              }
              
              .message {
                  padding: 0.5rem;
                  margin-bottom: 0.75rem;
              }
              
              .voice-waveform {
                  height: 25px;
              }
              
              .wave-bar {
                  width: 2px;
                  height: 8px;
              }
          }
          
          @media (max-width: 480px) {
              .mic-button {
                  width: 60px;
                  height: 60px;
                  font-size: 1.3rem;
              }
              
              .transcript-display {
                  padding: 0.75rem;
              }
              
              .permission-instructions {
                  padding: 1.5rem;
              }
              
              .keyboard-shortcuts {
                  padding: 0.75rem;
                  font-size: 0.85rem;
              }
          }
          
          /* Dark Mode Support */
          @media (prefers-color-scheme: dark) {
              .transcript-display {
                  background: #343a40;
                  border-color: #495057;
                  color: #f8f9fa;
              }
              
              .transcript-display.active {
                  background: rgba(0, 123, 255, 0.1);
                  border-color: #007bff;
              }
              
              .live-transcript {
                  color: #f8f9fa;
              }
              
              .conversation-log {
                  background: #212529;
              }
              
              .message.user {
                  background: rgba(0, 123, 255, 0.2);
              }
              
              .message.ai {
                  background: rgba(40, 167, 69, 0.2);
              }
              
              .keyboard-shortcuts {
                  background: rgba(255, 255, 255, 0.1);
              }
              
              .keyboard-shortcuts kbd {
                  background-color: #495057;
                  border-color: #6c757d;
                  color: #f8f9fa;
              }
          }
          
          /* Accessibility Enhancements */
          .mic-button:focus {
              outline: 3px solid rgba(0, 123, 255, 0.5);
              outline-offset: 2px;
          }
          
          .voice-status[aria-live="polite"] {
              position: absolute;
              left: -10000px;
              width: 1px;
              height: 1px;
              overflow: hidden;
          }
          
          /* High contrast mode support */
          @media (prefers-contrast: high) {
              .mic-button {
                  border: 2px solid currentColor;
              }
              
              .transcript-display {
                  border-width: 3px;
              }
              
              .ai-status {
                  border-width: 2px;
              }
          }

  📁 images/
    📁 icons/
    📁 prospect-avatars/
      📄 preview.html (1.7KB)
          Content:
            <!DOCTYPE html>
            <html>
            <head>
                <title>Avatar Previews</title>
                <style>
                    body { font-family: Arial, sans-serif; padding: 20px; }
                    .avatar { display: inline-block; margin: 10px; text-align: center; }
                    .avatar img { width: 100px; height: 100px; border-radius: 50%; }
                    .avatar p { margin: 5px 0; }
                </style>
            </head>
            <body>
                <h1>Prospect Avatars</h1>
                <div>
                    <div class="avatar">
                        <img src="default.svg" alt="Default">
                        <p>Default</p>
                    </div>
                    <div class="avatar">
                        <img src="technology.svg" alt="Technology">
                        <p>Technology</p>
                    </div>
                    <div class="avatar">
                        <img src="tech.svg" alt="Tech">
                        <p>Tech</p>
                    </div>
                    <div class="avatar">
                        <img src="finance.svg" alt="Finance">
                        <p>Finance</p>
                    </div>
                    <div class="avatar">
                        <img src="healthcare.svg" alt="Healthcare">
                        <p>Healthcare</p>
                    </div>
                    <div class="avatar">
                        <img src="manufacturing.svg" alt="Manufacturing">
                        <p>Manufacturing</p>
                    </div>
                    <div class="avatar">
                        <img src="education.svg" alt="Education">
                        <p>Education</p>
                    </div>
                    <div class="avatar">
                        <img src="executive.svg" alt="Executive">
                        <p>Executive</p>
                    </div>
                    <div class="avatar">
                        <img src="technical.svg" alt="Technical">
                        <p>Technical</p>
                    </div>
                    <div class="avatar">
                        <img src="manager.svg" alt="Manager">
                        <p>Manager</p>
                    </div>
                </div>
            </body>
            </html>

      📄 serve_avatars.py (0.9KB)
          Content:
            # Simple script to serve SVG avatars as images
            from flask import Flask, send_file, abort
            import os
            from pathlib import Path
            
            app = Flask(__name__)
            AVATAR_DIR = Path("static/images/prospect-avatars")
            
            @app.route('/static/images/prospect-avatars/<filename>')
            def serve_avatar(filename):
                """Serve SVG files as images"""
                # Try to find the corresponding SVG file
                svg_filename = filename.replace('.jpg', '.svg').replace('.png', '.svg')
                svg_path = AVATAR_DIR / svg_filename
                
                if svg_path.exists():
                    return send_file(svg_path, mimetype='image/svg+xml')
                
                # Fallback to a default SVG
                default_path = AVATAR_DIR / 'default.svg'
                if default_path.exists():
                    return send_file(default_path, mimetype='image/svg+xml')
                
                abort(404)
            
            if __name__ == '__main__':
                print("This would serve avatars. Integrate into your main Flask app instead.")
            

  📁 js/
    📄 admin.js (0KB)
        (Empty file)

    📄 auth.js (0KB)
        (Empty file)

    📄 dashboard.js (25KB)
        Content:
          // ===== FIXED: STATIC/JS/DASHBOARD.JS =====
          
          class Dashboard {
              constructor() {
                  this.userProfile = null;
                  this.userStats = null;
                  this.roleplayAccess = null;
                  this.isLoading = false;
                  
                  this.initialize();
              }
          
              initialize() {
                  console.log('Initializing Dashboard');
                  
                  // Set up event listeners
                  this.setupEventListeners();
                  
                  // Load dashboard data
                  this.loadDashboard();
                  
                  // Load progress data
                  this.loadDashboardProgress();
              }
          
              setupEventListeners() {
                  // Refresh button
                  const refreshBtn = document.getElementById('refresh-dashboard');
                  if (refreshBtn) {
                      refreshBtn.addEventListener('click', () => this.loadDashboard());
                  }
                  
                  // Roleplay card clicks
                  document.addEventListener('click', (e) => {
                      const roleplayCard = e.target.closest('.roleplay-card');
                      if (roleplayCard) {
                          const roleplayId = parseInt(roleplayCard.dataset.roleplayId);
                          if (roleplayCard.classList.contains('unlocked')) {
                              this.navigateToRoleplay(roleplayId);
                          } else {
                              this.showUnlockInfo(roleplayId);
                          }
                      }
                  });
                  
                  // Stats refresh
                  setInterval(() => {
                      if (!this.isLoading) {
                          this.loadUserStats();
                      }
                  }, 60000); // Refresh stats every minute
              }
          
              async loadDashboard() {
                  if (this.isLoading) return;
                  
                  this.isLoading = true;
                  this.showLoading(true);
          
                  try {
                      // Load all dashboard data
                      await Promise.all([
                          this.loadUserProfile(),
                          this.loadUserStats(),
                          this.loadRoleplayAccess(),
                          this.loadRecentSessions()
                      ]);
          
                      // Update UI
                      this.updateUserInfo();
                      this.updateStatsDisplay();
                      this.updateUsageMeter();
                      this.updateRoleplayGrid();
                      this.updateRecentSessions();
          
                  } catch (error) {
                      console.error('Error loading dashboard:', error);
                      this.showError('Failed to load dashboard data');
                  } finally {
                      this.isLoading = false;
                      this.showLoading(false);
                  }
              }
          
              async loadUserProfile() {
                  try {
                      const response = await fetch('/api/user/profile', {
                          headers: {
                              'Authorization': `Bearer ${localStorage.getItem('access_token') || ''}`
                          }
                      });
          
                      if (response.ok) {
                          const data = await response.json();
                          this.userProfile = data.profile;
                          this.roleplayAccess = data.roleplay_access;
                      } else if (response.status === 401) {
                          // Redirect to login if unauthorized
                          window.location.href = '/login';
                      } else {
                          throw new Error('Failed to load user profile');
                      }
                  } catch (error) {
                      console.error('Error loading user profile:', error);
                      throw error;
                  }
              }
          
              async loadUserStats() {
                  try {
                      const response = await fetch('/api/user/stats', {
                          headers: {
                              'Authorization': `Bearer ${localStorage.getItem('access_token') || ''}`
                          }
                      });
          
                      if (response.ok) {
                          this.userStats = await response.json();
                      } else {
                          throw new Error('Failed to load user stats');
                      }
                  } catch (error) {
                      console.error('Error loading user stats:', error);
                      // Don't throw - stats are not critical
                  }
              }
          
              async loadRoleplayAccess() {
                  // Access info is loaded with profile
                  // Individual roleplay unlock status will be checked when needed
              }
          
              async loadRecentSessions() {
                  try {
                      const response = await fetch('/api/user/sessions?limit=5', {
                          headers: {
                              'Authorization': `Bearer ${localStorage.getItem('access_token') || ''}`
                          }
                      });
          
                      if (response.ok) {
                          const data = await response.json();
                          this.recentSessions = data.sessions || [];
                      } else {
                          throw new Error('Failed to load recent sessions');
                      }
                  } catch (error) {
                      console.error('Error loading recent sessions:', error);
                      this.recentSessions = [];
                  }
              }
          
              updateUserInfo() {
                  if (!this.userProfile) return;
          
                  // Update user name
                  const nameElement = document.getElementById('user-first-name');
                  if (nameElement) {
                      nameElement.textContent = this.userProfile.first_name;
                  }
          
                  // Update access level badge
                  const accessBadge = document.getElementById('access-level-badge');
                  const accessText = document.getElementById('access-level-text');
                  
                  if (accessBadge && accessText) {
                      const accessLevel = this.userProfile.access_level;
                      const levelNames = {
                          'limited_trial': 'Trial',
                          'unlimited_basic': 'Basic',
                          'unlimited_pro': 'Pro'
                      };
                      
                      accessText.textContent = levelNames[accessLevel] || accessLevel;
                      
                      // Update badge styling
                      accessBadge.className = 'access-level-badge';
                      accessBadge.classList.add(`access-level-${accessLevel}`);
                  }
              }
          
              updateStatsDisplay() {
                  if (!this.userStats) {
                      this.setDefaultStats();
                      return;
                  }
          
                  const statsGrid = document.getElementById('stats-grid');
                  if (!statsGrid) return;
          
                  const stats = [
                      {
                          icon: 'fas fa-phone',
                          number: this.userStats.total_sessions,
                          label: 'Total Sessions',
                          color: 'primary'
                      },
                      {
                          icon: 'fas fa-clock',
                          number: `${Math.floor(this.userStats.total_minutes / 60)}h ${this.userStats.total_minutes % 60}m`,
                          label: 'Total Practice',
                          color: 'info'
                      },
                      {
                          icon: 'fas fa-chart-line',
                          number: `${this.userStats.success_rate}%`,
                          label: 'Success Rate',
                          color: this.userStats.success_rate >= 70 ? 'success' : this.userStats.success_rate >= 50 ? 'warning' : 'danger'
                      },
                      {
                          icon: 'fas fa-trophy',
                          number: this.userStats.successful_sessions,
                          label: 'Successful Calls',
                          color: 'success'
                      },
                      {
                          icon: 'fas fa-calendar-week',
                          number: this.userStats.sessions_this_week,
                          label: 'This Week',
                          color: 'secondary'
                      },
                      {
                          icon: 'fas fa-star',
                          number: this.userStats.favorite_roleplay || 'None yet',
                          label: 'Favorite Module',
                          color: 'warning'
                      }
                  ];
          
                  statsGrid.innerHTML = stats.map(stat => `
                      <div class="stat-card">
                          <div class="stat-icon text-${stat.color}">
                              <i class="${stat.icon}"></i>
                          </div>
                          <div class="stat-number text-${stat.color}">${stat.number}</div>
                          <div class="stat-label">${stat.label}</div>
                      </div>
                  `).join('');
              }
          
              setDefaultStats() {
                  const statsGrid = document.getElementById('stats-grid');
                  if (!statsGrid) return;
          
                  statsGrid.innerHTML = `
                      <div class="stat-card">
                          <div class="stat-icon text-primary">
                              <i class="fas fa-phone"></i>
                          </div>
                          <div class="stat-number text-primary">0</div>
                          <div class="stat-label">Total Sessions</div>
                      </div>
                      <div class="stat-card">
                          <div class="stat-icon text-info">
                              <i class="fas fa-clock"></i>
                          </div>
                          <div class="stat-number text-info">0m</div>
                          <div class="stat-label">Total Practice</div>
                      </div>
                      <div class="stat-card">
                          <div class="stat-icon text-secondary">
                              <i class="fas fa-chart-line"></i>
                          </div>
                          <div class="stat-number text-secondary">0%</div>
                          <div class="stat-label">Success Rate</div>
                      </div>
                  `;
              }
          
              updateUsageMeter() {
                  if (!this.userProfile) return;
          
                  const usageText = document.getElementById('usage-text');
                  const usageProgress = document.getElementById('usage-progress');
                  
                  if (!usageText || !usageProgress) return;
          
                  const accessLevel = this.userProfile.access_level;
                  const monthlyUsage = this.userProfile.monthly_usage_minutes || 0;
                  const lifetimeUsage = this.userProfile.lifetime_usage_minutes || 0;
          
                  let usageInfo = '';
                  let percentage = 0;
                  let progressClass = 'bg-success';
          
                  if (accessLevel === 'limited_trial') {
                      const trialLimit = 180; // 3 hours
                      const remaining = Math.max(0, trialLimit - lifetimeUsage);
                      percentage = Math.min((lifetimeUsage / trialLimit) * 100, 100);
                      
                      usageInfo = `${Math.floor(remaining / 60)}h ${remaining % 60}m remaining`;
                      
                      if (percentage > 80) progressClass = 'bg-danger';
                      else if (percentage > 60) progressClass = 'bg-warning';
                  } else {
                      const monthlyLimit = 3000; // 50 hours
                      const remaining = Math.max(0, monthlyLimit - monthlyUsage);
                      percentage = Math.min((monthlyUsage / monthlyLimit) * 100, 100);
                      
                      usageInfo = `${Math.floor(remaining / 60)}h ${remaining % 60}m remaining this month`;
                      
                      if (percentage > 80) progressClass = 'bg-warning';
                      else if (percentage > 90) progressClass = 'bg-danger';
                  }
          
                  usageText.textContent = usageInfo;
                  usageProgress.style.width = `${percentage}%`;
                  usageProgress.className = `progress-bar ${progressClass}`;
              }
          
              updateRoleplayGrid() {
                  const roleplayGrid = document.getElementById('roleplay-grid');
                  if (!roleplayGrid) return;
          
                  const roleplays = [
                      {
                          id: 1,
                          name: 'Opener + Early Objections',
                          description: 'Master call openings and handle early objections with confidence',
                          icon: 'fas fa-phone-alt',
                          difficulty: 'Beginner',
                          color: 'success'
                      },
                      {
                          id: 2,
                          name: 'Pitch + Objections + Close',
                          description: 'Perfect your pitch and close more meetings',
                          icon: 'fas fa-bullseye',
                          difficulty: 'Intermediate',
                          color: 'primary'
                      },
                      {
                          id: 3,
                          name: 'Warm-up Challenge',
                          description: '25 rapid-fire questions to sharpen your skills',
                          icon: 'fas fa-fire',
                          difficulty: 'Quick',
                          color: 'warning'
                      },
                      {
                          id: 4,
                          name: 'Full Cold Call Simulation',
                          description: 'Complete end-to-end cold call practice',
                          icon: 'fas fa-headset',
                          difficulty: 'Advanced',
                          color: 'info'
                      },
                      {
                          id: 5,
                          name: 'Power Hour Challenge',
                          description: '10 consecutive calls to test your endurance',
                          icon: 'fas fa-bolt',
                          difficulty: 'Expert',
                          color: 'danger'
                      }
                  ];
          
                  roleplayGrid.innerHTML = roleplays.map(roleplay => {
                      const isUnlocked = this.isRoleplayUnlocked(roleplay.id);
                      const unlockInfo = this.getRoleplayUnlockInfo(roleplay.id);
                      
                      return this.createRoleplayCard(roleplay, isUnlocked, unlockInfo);
                  }).join('');
              }
          
              isRoleplayUnlocked(roleplayId) {
                  if (!this.roleplayAccess) return roleplayId === 1; // Roleplay 1 always unlocked
                  
                  const access = this.roleplayAccess[roleplayId];
                  return access ? access.unlocked : false;
              }
          
              getRoleplayUnlockInfo(roleplayId) {
                  if (!this.roleplayAccess) return null;
                  
                  const access = this.roleplayAccess[roleplayId];
                  return access || null;
              }
          
              createRoleplayCard(roleplay, isUnlocked, unlockInfo) {
                  const lockIcon = isUnlocked ? 'fas fa-unlock text-success' : 'fas fa-lock text-muted';
                  const cardClass = isUnlocked ? 'roleplay-card unlocked' : 'roleplay-card locked';
                  
                  let statusBadge = '';
                  let footer = '';
                  
                  if (isUnlocked) {
                      statusBadge = '<span class="badge bg-success">Unlocked</span>';
                      footer = `
                          <div class="card-footer">
                              <button class="btn btn-${roleplay.color} w-100">
                                  <i class="fas fa-play me-2"></i>Start Training
                              </button>
                          </div>
                      `;
                  } else {
                      statusBadge = '<span class="badge bg-secondary">Locked</span>';
                      const condition = unlockInfo ? unlockInfo.unlock_condition : 'Complete previous modules';
                      footer = `
                          <div class="card-footer text-muted">
                              <small><i class="fas fa-info-circle me-1"></i>${condition}</small>
                          </div>
                      `;
                  }
          
                  return `
                      <div class="col-lg-6 col-xl-4 mb-4">
                          <div class="${cardClass}" data-roleplay-id="${roleplay.id}">
                              <div class="card h-100">
                                  <div class="card-body">
                                      <div class="d-flex justify-content-between align-items-start mb-3">
                                          <div class="roleplay-icon text-${roleplay.color}">
                                              <i class="${roleplay.icon}"></i>
                                          </div>
                                          <div class="d-flex flex-column align-items-end">
                                              ${statusBadge}
                                              <i class="${lockIcon} mt-2"></i>
                                          </div>
                                      </div>
                                      <h5 class="card-title">${roleplay.name}</h5>
                                      <p class="card-text text-muted">${roleplay.description}</p>
                                      <div class="difficulty-badge">
                                          <span class="badge bg-light text-dark">${roleplay.difficulty}</span>
                                      </div>
                                  </div>
                                  ${footer}
                              </div>
                          </div>
                      </div>
                  `;
              }
          
              updateRecentSessions() {
                  const sessionsTable = document.getElementById('recent-sessions');
                  if (!sessionsTable) return;
          
                  if (!this.recentSessions || this.recentSessions.length === 0) {
                      sessionsTable.innerHTML = `
                          <tr>
                              <td colspan="6" class="text-center text-muted py-4">
                                  No sessions yet. Start your first roleplay to see your progress!
                              </td>
                          </tr>
                      `;
                      return;
                  }
          
                  sessionsTable.innerHTML = this.recentSessions.map(session => {
                      const date = new Date(session.created_at || session.started_at).toLocaleDateString();
                      const time = new Date(session.created_at || session.started_at).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                      const duration = session.duration_minutes ? `${session.duration_minutes}m` : 'N/A';
                      const resultIcon = session.success ? 
                          '<i class="fas fa-check-circle text-success"></i>' : 
                          '<i class="fas fa-times-circle text-danger"></i>';
                      const resultText = session.success ? 'Pass' : 'Needs Work';
                      const score = session.score || 'N/A';
                      
                      const roleplayNames = {
                          1: 'Opener + Objections',
                          2: 'Pitch + Close',
                          3: 'Warm-up',
                          4: 'Full Call',
                          5: 'Power Hour'
                      };
                      
                      const roleplayName = roleplayNames[session.roleplay_id] || `Roleplay ${session.roleplay_id}`;
                      const mode = session.mode.charAt(0).toUpperCase() + session.mode.slice(1);
          
                      return `
                          <tr>
                              <td>
                                  <div>${date}</div>
                                  <small class="text-muted">${time}</small>
                              </td>
                              <td>
                                  <div>${roleplayName}</div>
                                  <small class="text-muted">${mode} Mode</small>
                              </td>
                              <td>
                                  <span class="badge bg-primary">${mode}</span>
                              </td>
                              <td>${duration}</td>
                              <td>
                                  <div class="d-flex align-items-center">
                                      ${resultIcon}
                                      <span class="ms-1">${resultText}</span>
                                  </div>
                              </td>
                              <td>
                                  <span class="fw-medium">${score}</span>
                              </td>
                          </tr>
                      `;
                  }).join('');
              }
          
              navigateToRoleplay(roleplayId) {
                  window.location.href = `/roleplay/${roleplayId}`;
              }
          
              showUnlockInfo(roleplayId) {

    📄 main.js (12.6KB)
        Content:
          // ===== STATIC/JS/MAIN.JS (FIXED) =====
          class ColdCallingApp {
              constructor() {
                  this.currentUser = null;
                  this.accessToken = localStorage.getItem('access_token');
                  this.init();
              }
          
              init() {
                  this.setupEventListeners();
                  this.checkAuthStatus();
              }
          
              setupEventListeners() {
                  // Auth buttons
                  const loginBtn = document.getElementById('login-btn');
                  const logoutBtn = document.getElementById('logout-btn');
          
                  if (logoutBtn) {
                      logoutBtn.addEventListener('click', (e) => {
                          e.preventDefault();
                          this.logout();
                      });
                  }
          
                  // Check for auth forms
                  this.setupAuthForms();
              }
          
              setupAuthForms() {
                  // Login form
                  const loginForm = document.getElementById('login-form');
                  if (loginForm) {
                      loginForm.addEventListener('submit', (e) => {
                          e.preventDefault();
                          this.handleLogin(new FormData(loginForm));
                      });
                  }
          
                  // Email verification form
                  const verifyForm = document.getElementById('verify-form');
                  if (verifyForm) {
                      verifyForm.addEventListener('submit', (e) => {
                          e.preventDefault();
                          this.handleEmailVerification(new FormData(verifyForm));
                      });
                  }
          
                  // Send verification code button (this now handles the complete registration flow)
                  const sendCodeBtn = document.getElementById('send-verification-btn');
                  if (sendCodeBtn) {
                      sendCodeBtn.addEventListener('click', () => {
                          this.sendVerificationCode();
                      });
                  }
              }
          
              async checkAuthStatus() {
                  if (!this.accessToken) {
                      this.updateAuthUI(false);
                      return;
                  }
          
                  try {
                      const response = await fetch('/api/auth/me', {
                          headers: {
                              'Authorization': `Bearer ${this.accessToken}`
                          }
                      });
          
                      if (response.ok) {
                          const data = await response.json();
                          this.currentUser = data.user;
                          this.updateAuthUI(true);
                      } else {
                          this.logout();
                      }
                  } catch (error) {
                      console.error('Auth check failed:', error);
                      this.logout();
                  }
              }
          
              updateAuthUI(isAuthenticated) {
                  const loginBtn = document.getElementById('login-btn');
                  const logoutBtn = document.getElementById('logout-btn');
          
                  if (isAuthenticated) {
                      if (loginBtn) loginBtn.style.display = 'none';
                      if (logoutBtn) logoutBtn.style.display = 'block';
                  } else {
                      if (loginBtn) loginBtn.style.display = 'block';
                      if (logoutBtn) logoutBtn.style.display = 'none';
                  }
              }
          
              validateRegistrationForm() {
                  const email = document.getElementById('register-email')?.value?.trim();
                  const password = document.getElementById('register-password')?.value;
                  const firstName = document.getElementById('register-first-name')?.value?.trim();
                  const jobTitle = document.getElementById('prospect-job-title')?.value;
                  const industry = document.getElementById('prospect-industry')?.value;
          
                  if (!email) {
                      this.showMessage('Please enter your email address', 'error');
                      return false;
                  }
          
                  if (!password || password.length < 6) {
                      this.showMessage('Password must be at least 6 characters long', 'error');
                      return false;
                  }
          
                  if (!firstName) {
                      this.showMessage('Please enter your first name', 'error');
                      return false;
                  }
          
                  if (!jobTitle) {
                      this.showMessage('Please select a prospect job title', 'error');
                      return false;
                  }
          
                  if (!industry) {
                      this.showMessage('Please select a prospect industry', 'error');
                      return false;
                  }
          
                  return true;
              }
          
              async sendVerificationCode() {
                  // Validate all form fields first
                  if (!this.validateRegistrationForm()) {
                      return;
                  }
          
                  // Collect all form data
                  const email = document.getElementById('register-email').value.trim();
                  const password = document.getElementById('register-password').value;
                  const firstName = document.getElementById('register-first-name').value.trim();
                  const jobTitle = document.getElementById('prospect-job-title').value;
                  const industry = document.getElementById('prospect-industry').value;
                  const customNotes = document.getElementById('custom-ai-notes')?.value?.trim() || '';
          
                  const button = document.getElementById('send-verification-btn');
                  const originalText = button.textContent;
                  button.disabled = true;
                  button.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Sending...';
          
                  try {
                      const response = await fetch('/api/auth/send-verification', {
                          method: 'POST',
                          headers: { 'Content-Type': 'application/json' },
                          body: JSON.stringify({
                              email: email,
                              password: password,
                              first_name: firstName,
                              prospect_job_title: jobTitle,
                              prospect_industry: industry,
                              custom_ai_notes: customNotes
                          })
                      });
          
                      const data = await response.json();
          
                      if (response.ok) {
                          this.showMessage('Verification code sent! Check your email.', 'success');
                          
                          // Update step indicator
                          document.getElementById('step-1')?.classList.remove('active');
                          document.getElementById('step-1')?.classList.add('completed');
                          document.getElementById('step-2')?.classList.add('active');
                          
                          // Show verification form
                          const verificationSection = document.getElementById('verification-section');
                          if (verificationSection) {
                              verificationSection.style.display = 'block';
                              // Copy email to verification form
                              const verifyEmailInput = document.getElementById('verify-email');
                              if (verifyEmailInput) {
                                  verifyEmailInput.value = email;
                              }
                              // Scroll to verification section
                              verificationSection.scrollIntoView({ behavior: 'smooth' });
                          }
                      } else {
                          this.showMessage(data.error || 'Failed to send verification code', 'error');
                      }
                  } catch (error) {
                      console.error('Network error:', error);
                      this.showMessage('Network error. Please try again.', 'error');
                  } finally {
                      button.disabled = false;
                      button.innerHTML = originalText;
                  }
              }
          
              async handleEmailVerification(formData) {
                  const button = document.querySelector('#verify-form button[type="submit"]');
                  const originalText = button.textContent;
                  button.disabled = true;
                  button.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Verifying...';
          
                  try {
                      const response = await fetch('/api/auth/verify-and-register', {
                          method: 'POST',
                          headers: { 'Content-Type': 'application/json' },
                          body: JSON.stringify({
                              email: formData.get('email'),
                              code: formData.get('code')
                          })
                      });
          
                      const data = await response.json();
          
                      if (response.ok) {
                          // Update step indicator
                          document.getElementById('step-2')?.classList.remove('active');
                          document.getElementById('step-2')?.classList.add('completed');
                          document.getElementById('step-3')?.classList.add('active');
                          
                          this.showMessage('Account created successfully! You can now log in.', 'success');
                          
                          // Redirect to login after a brief delay
                          setTimeout(() => {
                              window.location.href = '/login';
                          }, 2000);
                      } else {
                          this.showMessage(data.error || 'Verification failed', 'error');
                      }
                  } catch (error) {
                      console.error('Network error:', error);
                      this.showMessage('Network error. Please try again.', 'error');
                  } finally {
                      button.disabled = false;
                      button.innerHTML = originalText;
                  }
              }
          
              async handleLogin(formData) {
                  const button = document.querySelector('#login-form button[type="submit"]');
                  const originalText = button.textContent;
                  button.disabled = true;
                  button.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Logging In...';
          
                  try {
                      const response = await fetch('/api/auth/login', {
                          method: 'POST',
                          headers: { 'Content-Type': 'application/json' },
                          body: JSON.stringify({
                              email: formData.get('email'),
                              password: formData.get('password')
                          })
                      });
          
                      const data = await response.json();
          
                      if (response.ok) {
                          this.accessToken = data.access_token;
                          localStorage.setItem('access_token', this.accessToken);
                          this.currentUser = data.user;
                          
                          this.showMessage('Login successful!', 'success');
                          
                          setTimeout(() => {
                              window.location.href = '/dashboard';
                          }, 1000);
                      } else {
                          this.showMessage(data.error || 'Login failed', 'error');
                      }
                  } catch (error) {
                      console.error('Network error:', error);
                      this.showMessage('Network error. Please try again.', 'error');
                  } finally {
                      button.disabled = false;
                      button.innerHTML = originalText;
                  }
              }
          
              async logout() {
                  try {
                      await fetch('/api/auth/logout', {
                          method: 'POST',
                          headers: {
                              'Authorization': `Bearer ${this.accessToken}`
                          }
                      });
                  } catch (error) {
                      console.error('Logout error:', error);
                  }
          
                  this.accessToken = null;
                  this.currentUser = null;
                  localStorage.removeItem('access_token');
                  this.updateAuthUI(false);
                  
                  window.location.href = '/';
              }
          
              showMessage(message, type = 'info') {
                  // Remove existing messages
                  const existingMessages = document.querySelectorAll('.alert-message');
                  existingMessages.forEach(msg => msg.remove());
          
                  // Create new message
                  const alertDiv = document.createElement('div');
                  alertDiv.className = `alert alert-${type === 'error' ? 'danger' : type} alert-dismissible fade show alert-message`;
                  alertDiv.style.position = 'fixed';
                  alertDiv.style.top = '20px';
                  alertDiv.style.right = '20px';
                  alertDiv.style.zIndex = '9999';
                  alertDiv.style.minWidth = '300px';
                  
                  alertDiv.innerHTML = `
                      ${message}
                      <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                  `;
                  
                  document.body.appendChild(alertDiv);
          
                  // Auto-remove after 5 seconds
                  setTimeout(() => {
                      if (alertDiv.parentNode) {
                          alertDiv.remove();
                      }
                  }, 5000);
              }
          
              // Utility method for API calls
              async apiCall(endpoint, options = {}) {
                  const defaultOptions = {
                      headers: {
                          'Content-Type': 'application/json',
                          ...(this.accessToken && { 'Authorization': `Bearer ${this.accessToken}` })
                      }
                  };
          
                  const response = await fetch(endpoint, { ...defaultOptions, ...options });
                  
                  if (response.status === 401) {
                      this.logout();
                      throw new Error('Authentication required');
                  }
          
                  return response;
              }
          }
          
          // Initialize app when DOM is loaded
          document.addEventListener('DOMContentLoaded', () => {
              window.coldCallingApp = new ColdCallingApp();
          });

    📄 roleplay.js (35.5KB)
        Content:
          // ===== FIXED roleplay.js - Remove parseInt() for roleplay IDs =====
          
          class PhoneRoleplayManager {
              constructor() {
                  this.selectedMode = null;
                  this.callState = 'idle'; // idle, dialing, ringing, connected, ended
                  this.callStartTime = null;
                  this.durationInterval = null;
                  this.isRecording = false;
                  this.isMuted = false;
                  this.speakerOn = false;
                  this.currentSession = null;
                  this.isActive = false;
                  this.voiceHandler = null;
                  this.aiIsSpeaking = false;
                  this.isProcessing = false;
                  this.conversationHistory = [];
                  
                  // Natural conversation state
                  this.currentAudio = null;  // Track current AI audio
                  this.naturalMode = true;   // Enable natural conversation features
                  
                  // Debug flag
                  this.debugMode = true;
                  
                  this.init();
              }
          
              init() {
                  console.log('ðŸš€ Initializing Natural Conversation Roleplay Manager...');
                  
                  this.updateTime();
                  setInterval(() => this.updateTime(), 1000);
                  
                  this.loadRoleplayData();
                  this.setupEventListeners();
                  this.initializeModeSelection();
                  
                  // Initialize natural voice handler
                  if (typeof VoiceHandler !== 'undefined') {
                      this.voiceHandler = new VoiceHandler(this);
                      console.log('âœ… Natural Voice Handler initialized');
                  } else {
                      console.warn('âš ï¸ VoiceHandler not available');
                  }
              }
          
              updateTime() {
                  const now = new Date();
                  const time = now.toLocaleTimeString('en-US', { 
                      hour: 'numeric', 
                      minute: '2-digit',
                      hour12: false 
                  });
                  const timeElement = document.getElementById('current-time');
                  if (timeElement) {
                      timeElement.textContent = time;
                  }
              }
          
              loadRoleplayData() {
                  const roleplayData = document.getElementById('roleplay-data');
                  if (roleplayData) {
                      // CRITICAL FIX: Do not use parseInt(). Roleplay IDs are strings like "1.1".
                      const roleplayId = roleplayData.dataset.roleplayId || '1.1';
                      const isAuthenticated = roleplayData.dataset.userAuthenticated === 'true';
                      
                      console.log('ðŸ“Š Roleplay data:', { roleplayId, isAuthenticated });
                      
                      if (!isAuthenticated) {
                          this.showError('Please log in to access Roleplay training');
                          setTimeout(() => {
                              window.location.href = '/login';
                          }, 2000);
                          return;
                      }
                      
                      if (roleplayId) {
                          this.loadRoleplayInfo(roleplayId);
                      }
                  }
              }
          
              async loadRoleplayInfo(roleplayId) {
                  try {
                      console.log('ðŸ“¡ Loading Roleplay info for ID:', roleplayId);
                      const response = await this.apiCall(`/api/roleplay/info/${roleplayId}`);
                      if (response.ok) {
                          const data = await response.json();
                          console.log('âœ… Roleplay info loaded:', data);
                          this.updateRoleplayUI(data);
                      } else {
                          console.error('âŒ Failed to load roleplay info:', await response.text());
                          // Fallback to default if API fails
                          this.updateRoleplayUI({
                              name: `Roleplay ${roleplayId}`,
                              job_title: 'CTO',
                              industry: 'Technology'
                          });
                      }
                  } catch (error) {
                      console.error('âŒ Error loading Roleplay info:', error);
                      // Fallback to default
                      this.updateRoleplayUI({
                          name: `Roleplay ${roleplayId}`,
                          job_title: 'CTO', 
                          industry: 'Technology'
                      });
                  }
              }
          
              updateRoleplayUI(roleplayData) {
                  const titleElement = document.getElementById('roleplay-title');
                  if (titleElement) {
                      titleElement.textContent = 'Natural Conversation: ' + (roleplayData.name || 'Phone Training');
                  }
          
                  this.updateProspectInfo(roleplayData);
              }
          
              updateProspectInfo(roleplayData) {
                  const avatarElement = document.getElementById('contact-avatar');
                  const nameElement = document.getElementById('contact-name');
                  const infoElement = document.getElementById('contact-info');
          
                  if (nameElement) {
                      nameElement.textContent = this.generateProspectName(roleplayData.job_title || 'CTO');
                  }
          
                  if (infoElement) {
                      infoElement.textContent = `${roleplayData.job_title || 'CTO'} â€¢ ${roleplayData.industry || 'Technology'}`;
                  }
          
                  if (avatarElement) {
                      const avatarUrl = this.getAvatarUrl(roleplayData.job_title || 'CTO');
                      avatarElement.src = avatarUrl;
                      avatarElement.alt = `Natural Roleplay prospect`;
                      
                      avatarElement.onerror = function() {
                          this.src = 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=150&h=150&fit=crop&crop=face';
                          this.onerror = null;
                      };
                  }
              }
          
              getAvatarUrl(jobTitle) {
                  const avatarMapping = {
                      'CEO': 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=150&h=150&fit=crop&crop=face',
                      'CTO': 'https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=150&h=150&fit=crop&crop=face',
                      'VP of Sales': 'https://images.unsplash.com/photo-1519345182560-3f2917c472ef?w=150&h=150&fit=crop&crop=face'
                  };
                  
                  return avatarMapping[jobTitle] || avatarMapping['CTO'];
              }
          
              generateProspectName(jobTitle) {
                  const names = {
                      'CEO': ['Alex Morgan', 'Sarah Chen', 'Michael Rodriguez'],
                      'CTO': ['David Kim', 'Jennifer Walsh', 'Robert Singh'],
                      'VP of Sales': ['Lisa Thompson', 'Mark Johnson', 'Amanda Garcia']
                  };
                  
                  const nameList = names[jobTitle] || ['Jordan Smith', 'Taylor Brown', 'Casey Jones'];
                  return nameList[Math.floor(Math.random() * nameList.length)];
              }
          
              setupEventListeners() {
                  console.log('ðŸ”§ Setting up event listeners for natural conversation...');
                  
                  // Mode selection
                  document.querySelectorAll('.mode-option').forEach(option => {
                      option.addEventListener('click', (e) => {
                          e.preventDefault();
                          const mode = option.dataset.mode;
                          console.log('ðŸ”˜ Mode selected:', mode);
                          this.selectMode(mode);
                      });
                  });
          
                  // Start call button
                  const startBtn = document.getElementById('start-call-btn');
                  if (startBtn) {
                      startBtn.addEventListener('click', (e) => {
                          e.preventDefault();
                          console.log('ðŸš€ Start call button clicked');
                          if (!this.isProcessing) {
                              this.startCall();
                          }
                      });
                  }
          
                  // Microphone button - now shows natural conversation status
                  const micBtn = document.getElementById('mic-btn');
                  if (micBtn) {
                      micBtn.addEventListener('click', (e) => {
                          e.preventDefault();
                          console.log('ðŸŽ™ï¸ Mic button clicked (natural mode)');
                          
                          if (this.voiceHandler) {
                              if (this.voiceHandler.isListening) {
                                  this.voiceHandler.stopListening();
                              } else {
                                  this.voiceHandler.startListening(false); // Manual start
                              }
                          }
                      });
                  }
          
                  // End call button
                  const endCallBtn = document.getElementById('end-call-btn');
                  if (endCallBtn) {
                      endCallBtn.addEventListener('click', (e) => {
                          e.preventDefault();
                          console.log('ðŸ“ž End call button clicked');
                          this.endCall();
                      });
                  }
          
                  // Feedback actions
                  const tryAgainBtn = document.getElementById('try-again-btn');
                  if (tryAgainBtn) {
                      tryAgainBtn.addEventListener('click', (e) => {
                          e.preventDefault();
                          console.log('ðŸ”„ Try again clicked');
                          this.tryAgain();
                      });
                  }
          
                  const newModeBtn = document.getElementById('new-mode-btn');
                  if (newModeBtn) {
                      newModeBtn.addEventListener('click', (e) => {
                          e.preventDefault();
                          console.log('ðŸ†• New mode clicked');
                          this.showModeSelection();
                      });
                  }
          
                  // Keyboard shortcuts for natural conversation
                  document.addEventListener('keydown', (e) => {
                      // Space bar to interrupt or start speaking
                      if (e.code === 'Space' && this.callState === 'connected' && !e.target.matches('input, textarea')) {
                          e.preventDefault();
                          
                          if (this.aiIsSpeaking) {
                              console.log('âš¡ Space pressed - interrupting AI');
                              this.handleUserInterruption();
                          } else if (this.voiceHandler && !this.voiceHandler.isListening) {
                              console.log('ðŸŽ™ï¸ Space pressed - manual start listening');
                              this.voiceHandler.startListening(false);
                          }
                      }
                      
                      // Escape to end call
                      if (e.code === 'Escape' && this.callState === 'connected') {
                          e.preventDefault();
                          console.log('ESC key pressed - end call');
                          this.endCall();
                      }
                  });
          
                  console.log('âœ… Natural conversation event listeners setup complete');
              }
          
              initializeModeSelection() {
                  console.log('ðŸŽ¯ Initializing mode selection...');
                  
                  document.getElementById('mode-selection').style.display = 'flex';
                  document.getElementById('call-interface').style.display = 'none';
                  document.getElementById('feedback-section').style.display = 'none';
                  
                  this.callState = 'idle';
                  this.isActive = false;
                  this.aiIsSpeaking = false;
                  this.isProcessing = false;
                  this.conversationHistory = [];
                  
                  // Stop any active audio or voice recognition
                  this.stopCurrentAudio();
                  if (this.voiceHandler) {
                      this.voiceHandler.stopListening();
                  }
              }
          
              selectMode(mode) {
                  if (!mode || this.isProcessing) return;
                  
                  console.log('âœ… Natural Roleplay mode selected:', mode);
                  this.selectedMode = mode;
                  
                  // Update UI
                  document.querySelectorAll('.mode-option').forEach(option => {
                      option.classList.remove('selected');
                  });
                  
                  const selectedOption = document.querySelector(`[data-mode="${mode}"]`);
                  if (selectedOption) {
                      selectedOption.classList.add('selected');
                  }
                  
                  // Update start button
                  const startBtn = document.getElementById('start-call-btn');
                  if (startBtn) {
                      startBtn.disabled = false;
                      startBtn.textContent = `Start Natural Roleplay ${this.capitalizeFirst(mode)}`;
                  }
              }
          
              async startCall() {
                  if (!this.selectedMode || this.isProcessing) {
                      console.log('âŒ Cannot start call: missing mode or already processing');
                      return;
                  }
          
                  const roleplayId = this.getRoleplayId();
                  if (!roleplayId) {
                      this.showError('Invalid Roleplay configuration');
                      return;
                  }
          
                  console.log('ðŸš€ Starting Natural Roleplay call:', { roleplayId, mode: this.selectedMode });
          
                  this.isProcessing = true;
                  const startBtn = document.getElementById('start-call-btn');
                  if (startBtn) {
                      startBtn.disabled = true;
                      startBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Connecting to Natural Roleplay...';
                  }
          
                  try {
                      const response = await this.apiCall('/api/roleplay/start', {
                          method: 'POST',
                          body: JSON.stringify({
                              roleplay_id: roleplayId,
                              mode: this.selectedMode
                          })
                      });
          
                      if (response.ok) {
                          const data = await response.json();
                          console.log('âœ… Natural Roleplay started successfully:', data);
                          
                          this.currentSession = data;
                          this.isActive = true;
                          
                          await this.startPhoneCallSequence(data.initial_response);
                          
                      } else {
                          const errorData = await response.json();
                          console.error('âŒ Failed to start Natural Roleplay:', errorData);
                          this.showError(errorData.error || 'Failed to start Natural Roleplay call');
                      }
                  } catch (error) {
                      console.error('âŒ Error starting Natural Roleplay:', error);
                      this.showError('Network error. Please try again.');
                  } finally {
                      this.isProcessing = false;
                      
                      if (!this.isActive && startBtn) {
                          startBtn.disabled = false;
                          startBtn.textContent = `Start Natural Roleplay ${this.capitalizeFirst(this.selectedMode)}`;
                      }
                  }
              }
          
              async startPhoneCallSequence(initialResponse) {
                  console.log('ðŸ“ž Starting Natural Roleplay call sequence...');
                  
                  // Hide mode selection, show call interface
                  document.getElementById('mode-selection').style.display = 'none';
                  document.getElementById('call-interface').style.display = 'flex';
          
                  await this.dialingState();
                  await this.ringingState();
                  await this.connectedState(initialResponse);
              }
          
              async dialingState() {
                  console.log('ðŸ“± Dialing state...');
                  this.callState = 'dialing';
                  this.updateCallStatus('Calling...', 'dialing');
                  
                  const avatar = document.getElementById('contact-avatar');
                  if (avatar) {
                      avatar.classList.add('calling');
                  }
                  
                  await this.delay(2000);
              }
          
              async ringingState() {
                  console.log('ðŸ“³ Ringing state...');
                  this.callState = 'ringing';
                  this.updateCallStatus('Ringing...', 'ringing');
                  
                  await this.delay(3000);
              }
          
              async connectedState(initialResponse) {
                  console.log('âœ… Connected - Natural Roleplay active!');
                  this.callState = 'connected';
                  this.updateCallStatus('Connected - Natural Conversation Active', 'connected');
                  
                  // Update UI
                  const avatar = document.getElementById('contact-avatar');
                  if (avatar) {
                      avatar.classList.remove('calling');
                      avatar.classList.add('roleplay-active');
                  }
                  
                  // Start call timer
                  this.callStartTime = Date.now();
                  this.startCallTimer();
                  
                  // Show live transcript
                  const transcript = document.getElementById('live-transcript');
                  if (transcript) {
                      transcript.classList.add('show');
                      transcript.classList.add('roleplay-active');
                  }
                  
                  // Enable natural conversation features
                  this.enableNaturalConversation();
                  
                  // Clear conversation history
                  this.conversationHistory = [];
                  
                  // Play initial AI response
                  if (initialResponse) {
                      console.log('ðŸŽ¯ Playing initial AI response:', initialResponse);
                      await this.playAIResponseAndWaitForUser(initialResponse);
                  } else {
                      console.log('ðŸŽ¤ No initial response, starting auto-listening');
                      this.startUserTurn();
                  }
              }
          
              enableNaturalConversation() {
                  console.log('ðŸ¤– Enabling natural conversation features...');
                  
                  // Enable interruption capability
                  if (this.voiceHandler) {
                      this.voiceHandler.enableInterruption();
                  }
                  
                  // Update UI to show natural mode
                  const micBtn = document.getElementById('mic-btn');
                  if (micBtn) {
                      micBtn.disabled = false;
                      micBtn.title = 'Natural conversation active - speak anytime or use Space bar';
                      micBtn.classList.add('natural-mode');
                  }
                  
                  // Show natural conversation instructions
                  this.updateTranscript('ðŸ¤– Natural conversation ready - speak when you want!');
              }
          
              updateCallStatus(text, state) {
                  const callInterface = document.getElementById('call-interface');
                  const statusText = document.getElementById('call-status-text');
                  
                  if (callInterface) {
                      callInterface.className = `call-interface ${state}`;
                  }
                  
                  if (statusText) {
                      statusText.textContent = text;
                  }
              }
          
              startCallTimer() {
                  this.durationInterval = setInterval(() => {
                      const elapsed = Date.now() - this.callStartTime;
                      const minutes = Math.floor(elapsed / 60000);
                      const seconds = Math.floor((elapsed % 60000) / 1000);
                      
                      const durationElement = document.getElementById('call-duration');
                      if (durationElement) {
                          durationElement.textContent = 
                              `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                      }
                  }, 1000);
              }
          
              // ===== NATURAL CONVERSATION METHODS =====
          
              startUserTurn() {
                  console.log('ðŸ‘¤ Starting user turn - auto-listening activated');
                  
                  this.aiIsSpeaking = false;
                  
                  // Start auto-listening for natural conversation
                  if (this.voiceHandler) {
                      this.voiceHandler.startAutoListening();
                  }
                  
                  // Update UI
                  this.updateTranscript('ðŸŽ¤ Your turn - speak naturally...');
                  this.addPulseTomicButton();
              }
          
              handleUserInterruption() {

    📄 simple-roleplay-manager.js (42.9KB)
        Content:
          // ===== COMPLETE FIXED: simple-roleplay-manager.js - ROBUST SESSION MANAGEMENT =====
          
          class FixedSimpleRoleplayManager {
              constructor() {
                  this.isActive = false;
                  this.sessionId = null;
                  this.currentRoleplayId = this.extractRoleplayId();
                  this.mode = 'practice';
                  this.callTimer = null;
                  this.callStartTime = null;
                  this.voiceHandler = null;
                  
                  // Enhanced conversation state management
                  this.conversationState = {
                      isProcessing: false,
                      isAIResponding: false,
                      isUserTurn: false,
                      lastResponse: null,
                      turnCount: 0,
                      sessionRecovered: false
                  };
                  
                  // Audio management
                  this.audioManager = {
                      currentAudio: null,
                      isPlaying: false,
                      queue: []
                  };
                  
                  // Session recovery settings
                  this.sessionRecovery = {
                      maxRetries: 3,
                      retryDelay: 2000,
                      enabled: true
                  };
                  
                  console.log(`ðŸš€ Fixed Simple Roleplay Manager initialized for: ${this.currentRoleplayId}`);
                  
                  this.initializeElements();
                  this.bindEvents();
                  this.setupInterface();
                  this.initializeVoiceHandler();
                  this.attemptSessionRecovery();
              }
          
              // ===== SESSION RECOVERY =====
          
              async attemptSessionRecovery() {
                  //Attempt to recover any existing session on page load
                  try {
                      console.log('ðŸ”„ Attempting session recovery...');
                      
                      const response = await fetch('/api/roleplay/session/status', {
                          method: 'GET',
                          headers: {
                              'Content-Type': 'application/json',
                          },
                          credentials: 'include'
                      });
                      
                      if (response.ok) {
                          const data = await response.json();
                          
                          if (data.active && data.session) {
                              console.log('ðŸ“¡ Active session found, attempting recovery...');
                              
                              this.sessionId = data.session.session_id;
                              this.isActive = true;
                              this.conversationState.sessionRecovered = true;
                              
                              // Update UI to show recovered session
                              this.showRecoveredSession(data.session);
                              
                              return true;
                          }
                      }
                      
                      console.log('â„¹ï¸ No active session to recover');
                      return false;
                      
                  } catch (error) {
                      console.warn('âš ï¸ Session recovery failed:', error);
                      return false;
                  }
              }
          
              showRecoveredSession(sessionData) {
                  //Show UI for recovered session
                  try {
                      // Show call interface
                      this.showCallInterface();
                      
                      // Update UI with session info
                      this.addSystemMessage(`ðŸ”„ Session recovered! Continuing from ${sessionData.current_stage || 'previous state'}...`);
                      
                      // Start user turn since we don't know the exact state
                      setTimeout(() => {
                          this.transitionToUserTurn();
                      }, 1000);
                      
                      console.log('âœ… Session UI recovered successfully');
                      
                  } catch (error) {
                      console.error('âŒ Failed to show recovered session:', error);
                      this.forceRestart();
                  }
              }
          
              // ===== ENHANCED INITIALIZATION =====
          
              initializeVoiceHandler() {
                  try {
                      if (typeof VoiceHandler !== 'undefined') {
                          this.voiceHandler = new VoiceHandler(this);
                          console.log('ðŸŽ¤ Voice handler initialized successfully');
                          
                          // Set up proper callbacks
                          this.voiceHandler.onTranscript = (transcript) => this.handleVoiceInput(transcript);
                          this.voiceHandler.onError = (error) => this.handleVoiceError(error);
                          
                          if (this.voiceHandler.isSupported) {
                              console.log('âœ… Voice recognition supported and ready');
                          } else {
                              console.warn('âš ï¸ Voice recognition not supported in this browser');
                          }
                      } else {
                          console.warn('âš ï¸ VoiceHandler class not available');
                          setTimeout(() => this.initializeVoiceHandler(), 1000);
                      }
                  } catch (error) {
                      console.error('âŒ Failed to initialize voice handler:', error);
                  }
              }
              
              extractRoleplayId() {
                  const pathParts = window.location.pathname.split('/');
                  const roleplayIndex = pathParts.indexOf('roleplay');
                  
                  if (roleplayIndex !== -1 && pathParts[roleplayIndex + 1]) {
                      return pathParts[roleplayIndex + 1];
                  }
                  
                  const dataElement = document.getElementById('roleplay-data');
                  if (dataElement) {
                      return dataElement.dataset.roleplayId || '1.1';
                  }
                  
                  return '1.1';
              }
              
              initializeElements() {
                  this.elements = {
                      modeSelection: document.getElementById('mode-selection'),
                      callInterface: document.getElementById('call-interface'),
                      feedbackSection: document.getElementById('feedback-section'),
                      startCallBtn: document.getElementById('start-call-btn'),
                      endCallBtn: document.getElementById('end-call-btn'),
                      liveTranscript: document.getElementById('live-transcript'),
                      roleplayTitle: document.getElementById('roleplay-title'),
                      roleplayVersion: document.getElementById('roleplay-version'),
                      modeGrid: document.getElementById('mode-grid'),
                      contactName: document.getElementById('contact-name'),
                      contactInfo: document.getElementById('contact-info'),
                      callDuration: document.getElementById('call-duration'),
                      scoreCircle: document.getElementById('score-circle'),
                      feedbackContent: document.getElementById('feedback-content'),
                      tryAgainBtn: document.getElementById('try-again-btn'),
                      newModeBtn: document.getElementById('new-mode-btn'),
                      micBtn: document.getElementById('mic-btn'),
                      currentTime: document.getElementById('current-time')
                  };
                  
                  const foundElements = Object.keys(this.elements).filter(key => this.elements[key]);
                  const missingElements = Object.keys(this.elements).filter(key => !this.elements[key]);
                  
                  console.log(`âœ… Found elements: ${foundElements.join(', ')}`);
                  if (missingElements.length > 0) {
                      console.warn(`âš ï¸ Missing elements: ${missingElements.join(', ')}`);
                  }
              }
              
              bindEvents() {
                  if (this.elements.startCallBtn) {
                      this.elements.startCallBtn.addEventListener('click', () => this.startCall());
                  }
                  
                  if (this.elements.endCallBtn) {
                      this.elements.endCallBtn.addEventListener('click', () => this.endCall());
                  }
                  
                  if (this.elements.tryAgainBtn) {
                      this.elements.tryAgainBtn.addEventListener('click', () => this.resetInterface());
                  }
                  
                  if (this.elements.newModeBtn) {
                      this.elements.newModeBtn.addEventListener('click', () => {
                          window.location.href = '/dashboard';
                      });
                  }
                  
                  console.log('ðŸ“Ž Events bound successfully');
              }
              
              setupInterface() {
                  this.updateRoleplayInfo();
                  this.createModeSelection();
                  this.updateTime();
                  setInterval(() => this.updateTime(), 1000);
                  
                  console.log('ðŸŽ¯ Interface setup complete');
              }
          
              // ===== ENHANCED CALL MANAGEMENT =====
              
              async startCall() {
                  if (this.isActive) {
                      console.warn('âš ï¸ Call already active');
                      return;
                  }
                  
                  try {
                      console.log(`ðŸš€ Starting call: ${this.currentRoleplayId} (${this.mode})`);
                      
                      // Reset conversation state
                      this.conversationState = {
                          isProcessing: false,
                          isAIResponding: false,
                          isUserTurn: false,
                          lastResponse: null,
                          turnCount: 0,
                          sessionRecovered: false
                      };
                      
                      if (this.elements.startCallBtn) {
                          this.elements.startCallBtn.textContent = 'Connecting...';
                          this.elements.startCallBtn.disabled = true;
                      }
                      
                      const response = await this.makeAPICall('/api/roleplay/start', {
                          method: 'POST',
                          body: JSON.stringify({
                              roleplay_id: this.currentRoleplayId,
                              mode: this.mode
                          })
                      });
                      
                      if (!response.ok) {
                          const errorData = await response.json();
                          throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
                      }
                      
                      const data = await response.json();
                      console.log('âœ… Call start response:', data);
                      
                      if (!data.session_id) {
                          throw new Error('No session ID received from server');
                      }
                      
                      if (!data.initial_response) {
                          console.warn('âš ï¸ No initial response, using fallback');
                          data.initial_response = 'Hello, this is Alex speaking.';
                      }
                      
                      this.sessionId = data.session_id;
                      this.isActive = true;
                      
                      // Show call interface
                      this.showCallInterface();
                      this.startCallTimer();
                      
                      // Handle initial AI response properly
                      setTimeout(() => {
                          this.handleAIResponse(data.initial_response, true);
                      }, 500);
                      
                      console.log('âœ… Call started successfully:', this.sessionId);
                      
                  } catch (error) {
                      console.error('âŒ Failed to start call:', error);
                      this.showError(`Failed to start call: ${error.message}`);
                      
                      if (this.elements.startCallBtn) {
                          this.elements.startCallBtn.textContent = 'Start Practice Call';
                          this.elements.startCallBtn.disabled = false;
                      }
                  }
              }
          
              // ===== ENHANCED VOICE INPUT HANDLING =====
          
              async handleVoiceInput(transcript) {
                  // Validate state
                  if (!this.isActive || !this.sessionId) {
                      console.warn('âš ï¸ Cannot process voice input: call not active');
                      this.showError('Call not active. Please start a new call.');
                      return;
                  }
                  
                  if (this.conversationState.isProcessing || this.conversationState.isAIResponding) {
                      console.warn('âš ï¸ Cannot process voice input: already processing');
                      return;
                  }
                  
                  // Handle special triggers
                  if (transcript.startsWith('[SILENCE_')) {
                      await this.handleSilenceTrigger(transcript);
                      return;
                  }
                  
                  try {
                      console.log(`ðŸŽ¤ Processing voice input: "${transcript}"`);
                      
                      // Set processing state
                      this.conversationState.isProcessing = true;
                      this.conversationState.isUserTurn = false;
                      
                      // Stop listening while processing
                      if (this.voiceHandler) {
                          this.voiceHandler.stopListening();
                          this.voiceHandler.setUserTurn(false);
                      }
                      
                      // Add user input to conversation
                      this.addToTranscript('You', transcript);
                      this.addSystemMessage('ðŸ¤– Processing your response...');
                      
                      // Send to API with retry logic
                      const response = await this.makeAPICallWithRetry('/api/roleplay/respond', {
                          method: 'POST',
                          body: JSON.stringify({
                              user_input: transcript
                          })
                      });
                      
                      if (!response.ok) {
                          const errorData = await response.json();
                          
                          // Handle specific error cases
                          if (response.status === 404 || errorData.session_expired) {
                              await this.handleSessionExpired();
                              return;
                          }
                          
                          throw new Error(errorData.error || 'Failed to process response');
                      }
                      
                      const data = await response.json();
                      console.log('âœ… API response received:', data);
                      
                      // Verify session consistency
                      if (data.session_id && data.session_id !== this.sessionId) {
                          console.warn('âš ï¸ Session ID mismatch, updating...');
                          this.sessionId = data.session_id;
                      }
                      
                      // Reset processing state
                      this.conversationState.isProcessing = false;
                      
                      // Handle response based on call continuation
                      if (data.call_continues) {
                          // Continue conversation with AI response
                          await this.handleAIResponse(data.ai_response);
                      } else {
                          // Call is ending
                          console.log('ðŸ“ž Call ending...');
                          this.addToTranscript('AI', data.ai_response);
                          
                          // End call after brief delay
                          setTimeout(() => {
                              this.handleCallEnd(data);
                          }, 2000);
                      }
                      
                  } catch (error) {
                      console.error('âŒ Failed to process voice input:', error);
                      this.showError('Failed to process your response');
                      
                      // Reset state and restart listening
                      this.conversationState.isProcessing = false;
                      setTimeout(() => {
                          if (this.isActive && !this.conversationState.isAIResponding) {
                              this.transitionToUserTurn();
                          }
                      }, 3000);
                  }
              }
          
              // ===== SESSION RECOVERY METHODS =====
          
              async handleSessionExpired() {
                  //Handle expired/lost session
                  console.log('ðŸ“ž Session expired, attempting recovery...');
                  
                  this.addSystemMessage('ðŸ”„ Session lost, attempting to recover...');
                  
                  try {
                      // Try to recover session
                      const recovered = await this.attemptSessionRecovery();
                      
                      if (recovered) {
                          this.addSystemMessage('âœ… Session recovered! Please continue...');
                          this.transitionToUserTurn();
                      } else {
                          // Recovery failed, force restart
                          this.addSystemMessage('âŒ Session recovery failed. Please start a new call.');
                          this.forceRestart();
                      }
                      
                  } catch (error) {
                      console.error('âŒ Session recovery error:', error);
                      this.forceRestart();
                  }
              }
          
              forceRestart() {
                  //Force restart the interface
                  console.log('ðŸ”„ Forcing interface restart...');
                  
                  this.isActive = false;
                  this.sessionId = null;
                  this.conversationState = {
                      isProcessing: false,
                      isAIResponding: false,
                      isUserTurn: false,
                      lastResponse: null,
                      turnCount: 0,
                      sessionRecovered: false
                  };
                  
                  // Stop voice and audio
                  if (this.voiceHandler) {
                      this.voiceHandler.stopListening();
                      this.voiceHandler.stopAllAudio();
                  }
                  
                  // Reset UI
                  this.resetInterface();
                  
                  // Show user guidance
                  this.showError('Session ended. Please start a new call.');
              }
          
              // ===== ENHANCED API CALLS =====
          
              async makeAPICall(url, options) {
                  //Enhanced API call with proper error handling
                  const defaultOptions = {
                      headers: {
                          'Content-Type': 'application/json',
                      },
                      credentials: 'include',
                      ...options
                  };
                  
                  try {
                      const response = await fetch(url, defaultOptions);
                      return response;
                  } catch (error) {
                      console.error(`âŒ API call failed to ${url}:`, error);
                      throw new Error(`Network error: ${error.message}`);
                  }
              }
          
              async makeAPICallWithRetry(url, options, maxRetries = 3) {
                  //API call with retry logic for session recovery
                  for (let attempt = 1; attempt <= maxRetries; attempt++) {
                      try {
                          const response = await this.makeAPICall(url, options);
                          
                          if (response.ok) {
                              return response;
                          }
                          
                          // Handle session errors with recovery
                          if (response.status === 404) {
                              const errorData = await response.json();
                              if (errorData.session_expired && attempt < maxRetries) {
                                  console.log(`ðŸ”„ Session expired, attempting recovery (attempt ${attempt}/${maxRetries})...`);
                                  
                                  const recovered = await this.attemptSessionRecovery();
                                  if (recovered) {
                                      console.log('âœ… Session recovered, retrying API call...');
                                      continue; // Retry with recovered session
                                  }
                              }
                          }
                          
                          // Return the response for other errors
                          return response;
                          
                      } catch (error) {
                          console.error(`âŒ API call attempt ${attempt} failed:`, error);
                          
                          if (attempt === maxRetries) {
                              throw error;
                          }
                          
                          // Wait before retry
                          await new Promise(resolve => setTimeout(resolve, this.sessionRecovery.retryDelay));
                      }
                  }

    📄 todelete.js (0KB)
        (Empty file)

    📄 voice-handler.js (29.8KB)
        Content:
          // ===== SIMPLE & RELIABLE: voice-handler.js (Mobile-First Design) =====
          
          class VoiceHandler {
              constructor(roleplayManager) {
                  this.roleplayManager = roleplayManager;
                  this.recognition = null;
                  this.isListening = false;
                  this.isSupported = false;
                  
                  // Device detection
                  this.isMobile = this.detectMobile();
                  this.isIOS = this.detectIOS();
                  
                  // Audio state management
                  this.currentAudio = null;
                  this.isAudioPlaying = false;
                  
                  // Conversation state
                  this.isUserTurn = false;
                  this.isAITurn = false;
                  this.isInterruptible = false; // ADDED: Flag for enabling interruptions
                  
                  // Callback interface
                  this.onTranscript = null;
                  this.onError = null;
                  
                  // SIMPLE APPROACH: Minimal auto-restart, maximum reliability
                  this.autoRestartEnabled = !this.isMobile; // MOBILE: No auto-restart
                  this.shouldRestart = false;
                  this.restartTimeout = null;
                  this.lastSuccessfulStart = 0;
                  this.consecutiveFailures = 0;
                  this.maxConsecutiveFailures = 2;
                  
                  // Recognition settings (optimized for reliability)
                  this.settings = {
                      continuous: true,
                      interimResults: !this.isMobile, // MOBILE: Final results only
                      language: 'en-US',
                      maxAlternatives: 1
                  };
                  
                  // State management
                  this.currentTranscript = '';
                  this.finalTranscript = '';
                  this.isAutoListening = false;
                  
                  // Simplified silence detection
                  this.silenceThreshold = this.isMobile ? 3000 : 2000; // Longer on mobile
                  this.lastSpeechTime = null;
                  this.silenceTimer = null;
                  
                  // Hang-up silence (disabled on mobile for reliability)
                  this.impatience_threshold = 10000;
                  this.hangup_threshold = 15000;
                  this.total_silence_start = null;
                  this.impatience_triggered = false;
                  this.hangupSilenceTimer = null;
                  this.hangupDetectionEnabled = !this.isMobile; // MOBILE: Disabled
                  
                  console.log(`Ã°Å¸Å½Â¤ Simple Voice Handler - Mobile: ${this.isMobile}, Auto-restart: ${this.autoRestartEnabled}`);
                  this.init();
              }
          
              enableInterruption() {
                  console.log('Ã¢Å¡Â¡Ã¯Â¸  Interruptions enabled for AI speech.');
                  this.isInterruptible = true;
              }
          
              setAITurn(isAITurn) {
                  this.isAITurn = isAITurn;
                  if (isAITurn) {
                      this.isUserTurn = false;
                      // Stop listening if AI is about to speak
                      if (this.isListening) {
                          this.stopListening(false); // don't trigger restart
                      }
                  }
              }
          
              setUserTurn(isUserTurn) {
                  this.isUserTurn = isUserTurn;
                  if (isUserTurn) {
                      this.isAITurn = false;
                  }
              }
              detectMobile() {
                  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                         (window.innerWidth <= 768 && 'ontouchstart' in window);
              }
          
              detectIOS() {
                  return /iPad|iPhone|iPod/.test(navigator.userAgent);
              }
          
              init() {
                  console.log('ðŸŽ¤ Initializing Simple Voice Handler...');
                  
                  this.checkBrowserSupport();
                  this.initializeUIElements();
                  this.setupEventListeners();
                  
                  if (this.isSupported) {
                      this.initializeSpeechRecognition();
                  }
                  
                  console.log(`âœ… Simple Voice Handler ready. Mobile mode: ${this.isMobile}`);
              }
          
              checkBrowserSupport() {
                  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                  
                  if (SpeechRecognition) {
                      this.isSupported = true;
                      this.SpeechRecognition = SpeechRecognition;
                      console.log('âœ… Speech recognition supported');
                  } else {
                      this.isSupported = false;
                      console.error('âŒ Speech recognition not supported');
                  }
                  
                  this.updateSupportUI();
              }
          
              updateSupportUI() {
                  const micButton = document.getElementById('mic-button') || document.getElementById('mic-btn');
                  
                  if (!this.isSupported) {
                      if (micButton) {
                          micButton.disabled = true;
                          micButton.innerHTML = '<i class="fas fa-microphone-slash"></i>';
                          micButton.title = 'Voice recognition not supported';
                      }
                      this.triggerError('Voice recognition not supported. Please use Chrome, Edge, or Safari.');
                  } else {
                      if (micButton) {
                          micButton.title = this.isMobile ? 
                              'Voice ready - will auto-start when it\'s your turn' : 
                              'Voice recognition ready';
                      }
                  }
              }
          
              initializeUIElements() {
                  this.micButton = document.getElementById('mic-button') || document.getElementById('mic-btn');
                  this.transcriptElement = document.getElementById('live-transcript');
                  this.errorElement = document.getElementById('voice-error');
                  
                  if (this.transcriptElement) {
                      this.transcriptElement.textContent = this.isMobile ? 
                          'Voice ready for mobile - will start automatically' : 
                          'Voice recognition ready...';
                  }
              }
          
              setupEventListeners() {
                  // Microphone button (manual trigger)
                  if (this.micButton) {
                      this.micButton.addEventListener('click', () => {
                          console.log('ðŸŽ¤ Manual mic button clicked');
                          this.handleManualMicClick();
                      });
                  }
                  
                  // Keyboard shortcuts (desktop only)
                  if (!this.isMobile) {
                      this.handleKeydown = (e) => {
                          if (e.code === 'Space' && !e.target.matches('input, textarea')) {
                              e.preventDefault();
                              if (!this.isListening && this.isUserTurn) {
                                  this.startListening();
                              }
                          }
                          
                          if (e.code === 'Escape' && this.isListening) {
                              this.stopListening();
                          }
                      };
                      
                      document.addEventListener('keydown', this.handleKeydown);
                  }
                  
                  // Page visibility (simple handling)
                  this.handleVisibilityChange = () => {
                      if (document.hidden && this.isListening) {
                          console.log('ðŸ“± Page hidden - stopping recognition');
                          this.stopListening();
                      }
                  };
                  
                  document.addEventListener('visibilitychange', this.handleVisibilityChange);
              }
          
              handleManualMicClick() {
                  if (this.isListening) {
                      console.log('ðŸ›‘ Manual stop requested');
                      this.stopListening();
                  } else if (this.isUserTurn && !this.isAudioPlaying) {
                      console.log('ðŸŽ¤ Manual start requested');
                      this.startListening();
                  } else if (this.isAudioPlaying) {
                      console.log('âš¡ User wants to interrupt AI');
                      this.stopAllAudio();
                  } else {
                      console.log('â³ Not user turn yet');
                      this.showMessage('Wait for your turn to speak', 'info');
                  }
              }
          
              initializeSpeechRecognition() {
                  if (!this.isSupported) return;
                  
                  try {
                      this.recognition = new this.SpeechRecognition();
                      
                      // Simple, reliable configuration
                      this.recognition.continuous = this.settings.continuous;
                      this.recognition.interimResults = this.settings.interimResults;
                      this.recognition.lang = this.settings.language;
                      this.recognition.maxAlternatives = this.settings.maxAlternatives;
                      
                      this.setupRecognitionEventHandlers();
                      
                      console.log('ðŸŽ¤ Speech recognition configured');
                  } catch (error) {
                      console.error('âŒ Failed to initialize speech recognition:', error);
                      this.triggerError('Failed to initialize voice recognition');
                  }
              }
          
              setupRecognitionEventHandlers() {
                  if (!this.recognition) return;
                  
                  // ... (keep onstart, onend handlers)
                  
                  this.recognition.onstart = () => {
                      console.log('Ã°Å¸Å½Â¤ Voice recognition started');
                      this.isListening = true;
                      this.updateMicrophoneUI(true);
                      this.clearError();
                      this.lastSuccessfulStart = Date.now();
                      this.consecutiveFailures = 0; // Reset on successful start
                      
                      if (this.hangupDetectionEnabled && this.isUserTurn) {
                          this.total_silence_start = Date.now();
                          this.impatience_triggered = false;
                          this.startHangupSilenceDetection();
                      }
                  };
                  
                  this.recognition.onend = () => {
                      console.log('Ã°Å¸â€ºâ€˜ Voice recognition ended');
                      this.isListening = false;
                      this.updateMicrophoneUI(false);
                      this.stopSilenceDetection();
                      this.stopHangupSilenceDetection();
                      
                      this.handleSimpleRestart();
                  };
          
                  this.recognition.onresult = (event) => {
                      this.handleRecognitionResult(event);
                  };
                  
                  this.recognition.onerror = (event) => {
                      this.handleRecognitionError(event);
                  };
          
                  // ===== MODIFIED onspeechstart HANDLER =====
                  this.recognition.onspeechstart = () => {
                      console.log('Ã°Å¸â€”Â£Ã¯Â¸  Speech detected');
                      this.lastSpeechTime = Date.now();
                      
                      // Use the new flag to check if interruption is allowed
                      if (this.isInterruptible && this.isAudioPlaying) {
                          console.log('Ã¢Å¡Â¡ User interrupted - stopping AI audio');
                          this.stopAllAudio();
                          
                          // Let the roleplay manager handle the turn change
                          if (this.roleplayManager && typeof this.roleplayManager.handleUserInterruption === 'function') {
                              this.roleplayManager.handleUserInterruption();
                          } else {
                              // Fallback if the manager doesn't have the specific handler
                              this.setAITurn(false);
                              this.setUserTurn(true);
                          }
                      }
                      
                      // Reset hang-up timer
                      this.total_silence_start = null;
                      this.impatience_triggered = false;
                  };
                  // ===== END OF MODIFICATION =====
                  
                  this.recognition.onspeechend = () => {
                      console.log('Ã°Å¸Â¤  Speech ended');
                      this.lastSpeechTime = Date.now();
                      this.startSilenceDetection();
                      if (this.hangupDetectionEnabled) {
                          this.total_silence_start = Date.now();
                      }
                  };
              }
          
              // ===== SIMPLE RESTART LOGIC =====
          
              handleSimpleRestart() {
                  // Clear any pending restart
                  if (this.restartTimeout) {
                      clearTimeout(this.restartTimeout);
                      this.restartTimeout = null;
                  }
                  
                  // Don't restart if conditions aren't perfect
                  if (!this.shouldRestart || 
                      !this.isUserTurn || 
                      this.isAudioPlaying || 
                      !this.isSupported ||
                      this.consecutiveFailures >= this.maxConsecutiveFailures) {
                      
                      if (this.consecutiveFailures >= this.maxConsecutiveFailures) {
                          console.log('ðŸ”´ Too many failures - manual restart required');
                          this.showManualRestartMessage();
                      }
                      return;
                  }
                  
                  // MOBILE: No auto-restart, show manual instruction
                  if (!this.autoRestartEnabled) {
                      console.log('ðŸ“± Mobile: No auto-restart - showing manual instruction');
                      this.showMobileInstruction();
                      return;
                  }
                  
                  // DESKTOP: Simple auto-restart with delay
                  const timeSinceLastStart = Date.now() - this.lastSuccessfulStart;
                  const restartDelay = Math.max(1000, 2000 - timeSinceLastStart); // At least 1 second delay
                  
                  console.log(`ðŸ”„ Auto-restart in ${restartDelay}ms`);
                  
                  this.restartTimeout = setTimeout(() => {
                      // Double-check conditions before restart
                      if (this.shouldRestart && this.isUserTurn && !this.isAudioPlaying && !this.isListening) {
                          console.log('ðŸ”„ Executing auto-restart');
                          this.startListening();
                      }
                  }, restartDelay);
              }
          
              showMobileInstruction() {
                  this.updateTranscript('ðŸ“± Your turn - tap the microphone to speak');
                  this.showMessage('Your turn! Tap the microphone', 'info');
              }
          
              showManualRestartMessage() {
                  this.updateTranscript('ðŸŽ¤ Voice recognition paused - click microphone to continue');
                  this.showMessage('Click the microphone to continue', 'info');
              }
          
              handleRecognitionResult(event) {
                  // Only process if it's user's turn
                  if (!this.isUserTurn) {
                      console.log('ðŸš« Ignoring speech - not user turn');
                      return;
                  }
                  
                  let interimTranscript = '';
                  let finalTranscript = '';
                  
                  // Process results
                  for (let i = event.resultIndex; i < event.results.length; i++) {
                      const result = event.results[i];
                      const transcript = result[0].transcript;
                      
                      if (result.isFinal) {
                          finalTranscript += transcript + ' ';
                          console.log(`âœ… Final transcript: "${transcript}"`);
                          this.lastSpeechTime = Date.now();
                      } else if (!this.isMobile) { // Only show interim on desktop
                          interimTranscript += transcript;
                          this.lastSpeechTime = Date.now();
                      }
                  }
                  
                  // Update transcript display
                  this.currentTranscript = finalTranscript + interimTranscript;
                  if (this.currentTranscript.trim()) {
                      this.updateTranscript(`ðŸŽ¤ You: "${this.currentTranscript.trim()}"`);
                  }
                  
                  // Process final results
                  if (finalTranscript.trim().length > 0) {
                      this.finalTranscript += finalTranscript;
                      this.startSilenceDetection();
                  }
              }
          
              handleRecognitionError(event) {
                  console.error('âŒ Voice recognition error:', event.error);
                  this.consecutiveFailures++;
                  
                  const errorMessages = {
                      'network': 'Network error. Check your internet connection.',
                      'not-allowed': 'Microphone access denied. Please allow microphone access and refresh.',
                      'no-speech': 'No speech detected. Try speaking louder or closer to the microphone.',
                      'aborted': 'Voice recognition was interrupted.',
                      'audio-capture': 'No microphone found. Please connect a microphone.',
                      'service-not-allowed': 'Voice service not allowed.',
                  };
                  
                  const message = errorMessages[event.error] || `Voice error: ${event.error}`;
                  this.triggerError(message);
                  
                  // Handle specific errors
                  if (event.error === 'not-allowed') {
                      this.handlePermissionDenied();
                  } else if (event.error === 'no-speech') {
                      // Don't count no-speech as a "real" failure
                      this.consecutiveFailures = Math.max(0, this.consecutiveFailures - 1);
                      
                      if (this.isMobile) {
                          this.showMessage('No speech heard. Tap mic to try again.', 'warning');
                      }
                  }
              }
          
              // ===== AUDIO MANAGEMENT =====
          
              async playAudio(text, isInterruptible = true) {
                  console.log(`ðŸ”Š Playing audio: "${text.substring(0, 50)}..."`);
                  
                  this.stopAllAudio();
                  this.setAITurn(true);
                  this.setUserTurn(false);
                  
                  try {
                      const response = await fetch('/api/roleplay/tts', {
                          method: 'POST',
                          headers: { 'Content-Type': 'application/json' },
                          body: JSON.stringify({ text: text })
                      });
                      
                      if (response.ok) {
                          const audioBlob = await response.blob();
                          
                          if (audioBlob.size > 100) {
                              const audioUrl = URL.createObjectURL(audioBlob);
                              this.currentAudio = new Audio(audioUrl);
                              this.isAudioPlaying = true;
                              
                              this.currentAudio.onended = () => {
                                  console.log('âœ… Audio finished');
                                  this.cleanupAudio(audioUrl);
                                  this.transitionToUserTurn();
                              };
                              
                              this.currentAudio.onerror = () => {
                                  console.log('âŒ Audio error');
                                  this.cleanupAudio(audioUrl);
                                  this.transitionToUserTurn();
                              };
                              
                              await this.currentAudio.play();
                              console.log('ðŸŽµ Audio playing');
                              
                          } else {
                              console.log('ðŸ“¢ Audio too small, simulating');
                              await this.simulateSpeakingTime(text);
                              this.transitionToUserTurn();
                          }
                      } else {
                          console.log('ðŸŽµ TTS failed, simulating');
                          await this.simulateSpeakingTime(text);
                          this.transitionToUserTurn();
                      }
                  } catch (error) {
                      console.error('âŒ Audio failed:', error);
                      await this.simulateSpeakingTime(text);
                      this.transitionToUserTurn();
                  }
              }
          
              transitionToUserTurn() {
                  this.setAITurn(false);
                  this.setUserTurn(true);
                  
                  // Start listening after a brief delay
                  setTimeout(() => {
                      if (this.isUserTurn && !this.isAudioPlaying) {
                          this.startAutoListening();
                      }
                  }, this.isMobile ? 1000 : 500); // Longer delay on mobile
              }
          
              stopAllAudio() {
                  if (this.currentAudio) {
                      try {
                          this.currentAudio.pause();
                          this.currentAudio.currentTime = 0;
                          this.currentAudio = null;
                      } catch (e) {

    📁 roleplay/
      📄 base-roleplay-manager.js (23.5KB)
          Content:
            // ===== FIXED static/js/roleplay/base-roleplay-manager.js =====
            
            class BaseRoleplayManager {
                constructor(options = {}) {
                    this.containerId = options.containerId || null;
                    this.selectedMode = null;
                    this.callState = 'idle'; // idle, dialing, ringing, connected, ended
                    this.callStartTime = null;
                    this.durationInterval = null;
                    this.currentSession = null;
                    this.isActive = false;
                    this.voiceHandler = null;
                    this.isProcessing = false;
                    this.conversationHistory = [];
                    
                    // Debug flag
                    this.debugMode = options.debugMode || true;
                    
                    this.init();
                }
                
                init() {
                    console.log('ðŸš€ Initializing Base Roleplay Manager...');
                    
                    this.updateTime();
                    setInterval(() => this.updateTime(), 1000);
                    
                    this.loadRoleplayData();
                    this.setupEventListeners();
                    this.initializeModeSelection();
                    
                    // Initialize voice handler
                    if (typeof VoiceHandler !== 'undefined') {
                        this.voiceHandler = new VoiceHandler(this);
                        console.log('âœ… Voice Handler initialized');
                    } else {
                        console.warn('âš ï¸ VoiceHandler not available');
                    }
                }
                
                updateTime() {
                    const now = new Date();
                    const time = now.toLocaleTimeString('en-US', { 
                        hour: 'numeric', 
                        minute: '2-digit',
                        hour12: false 
                    });
                    const timeElement = document.getElementById('current-time');
                    if (timeElement) {
                        timeElement.textContent = time;
                    }
                }
                async apiCall(endpoint, options = {}) {
                    const defaultOptions = {
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${localStorage.getItem('access_token') || ''}`
                        },
                        ...options
                    };
                    const response = await fetch(endpoint, defaultOptions);
                    if (!response.ok && response.status === 401) {
                        window.location.href = '/login';
                    }
                    return response;
                }
                loadRoleplayData() {
                    const roleplayData = document.getElementById('roleplay-data');
                    if (roleplayData) {
                        // FIXED: Don't use parseInt() - keep roleplay ID as string
                        const roleplayId = roleplayData.dataset.roleplayId || '1.1';
                        const isAuthenticated = roleplayData.dataset.userAuthenticated === 'true';
                        
                        console.log('ðŸ“Š Roleplay data:', { roleplayId, isAuthenticated });
                        
                        if (!isAuthenticated) {
                            this.showError('Please log in to access roleplay training');
                            setTimeout(() => {
                                window.location.href = '/login';
                            }, 2000);
                            return;
                        }
                        
                        if (roleplayId) {
                            this.loadRoleplayInfo(roleplayId);
                        }
                    }
                }
                
                async loadRoleplayInfo(roleplayId) {
                    try {
                        console.log('ðŸ“¡ Loading roleplay info for ID:', roleplayId);
                        const response = await this.apiCall(`/api/roleplay/info/${roleplayId}`);
                        if (response.ok) {
                            const data = await response.json();
                            console.log('âœ… Roleplay info loaded:', data);
                            this.updateRoleplayUI(data);
                        } else {
                            console.error('âŒ Failed to load roleplay info:', await response.text());
                            // Fallback to default if API fails
                            this.updateRoleplayUI({
                                name: `Roleplay ${roleplayId}`,
                                job_title: 'CTO',
                                industry: 'Technology'
                            });
                        }
                    } catch (error) {
                        console.error('âŒ Error loading roleplay info:', error);
                        // Fallback to default
                        this.updateRoleplayUI({
                            name: `Roleplay ${roleplayId}`,
                            job_title: 'CTO',
                            industry: 'Technology'
                        });
                    }
                }
                
                updateRoleplayUI(roleplayData) {
                    const titleElement = document.getElementById('roleplay-title');
                    if (titleElement) {
                        titleElement.textContent = `${roleplayData.name || 'Roleplay Training'}`;
                    }
                    
                    this.updateProspectInfo(roleplayData);
                }
                
                updateProspectInfo(roleplayData) {
                    const avatarElement = document.getElementById('contact-avatar');
                    const nameElement = document.getElementById('contact-name');
                    const infoElement = document.getElementById('contact-info');
                    
                    if (nameElement) {
                        nameElement.textContent = this.generateProspectName(roleplayData.job_title || 'CTO');
                    }
                    
                    if (infoElement) {
                        infoElement.textContent = `${roleplayData.job_title || 'CTO'} â€¢ ${roleplayData.industry || 'Technology'}`;
                    }
                    
                    if (avatarElement) {
                        const avatarUrl = this.getAvatarUrl(roleplayData.job_title || 'CTO');
                        avatarElement.src = avatarUrl;
                        avatarElement.alt = `Roleplay prospect`;
                        
                        avatarElement.onerror = function() {
                            this.src = 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=150&h=150&fit=crop&crop=face';
                            this.onerror = null;
                        };
                    }
                }
                
                getAvatarUrl(jobTitle) {
                    const avatarMapping = {
                        'CEO': 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=150&h=150&fit=crop&crop=face',
                        'CTO': 'https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=150&h=150&fit=crop&crop=face',
                        'VP of Sales': 'https://images.unsplash.com/photo-1519345182560-3f2917c472ef?w=150&h=150&fit=crop&crop=face'
                    };
                    
                    return avatarMapping[jobTitle] || avatarMapping['CTO'];
                }
                
                generateProspectName(jobTitle) {
                    const names = {
                        'CEO': ['Alex Morgan', 'Sarah Chen', 'Michael Rodriguez'],
                        'CTO': ['David Kim', 'Jennifer Walsh', 'Robert Singh'],
                        'VP of Sales': ['Lisa Thompson', 'Mark Johnson', 'Amanda Garcia']
                    };
                    
                    const nameList = names[jobTitle] || ['Jordan Smith', 'Taylor Brown', 'Casey Jones'];
                    return nameList[Math.floor(Math.random() * nameList.length)];
                }
                
                setupEventListeners() {
                    console.log('ðŸ”§ Setting up event listeners...');
                    
                    // Mode selection
                    document.querySelectorAll('.mode-option').forEach(option => {
                        option.addEventListener('click', (e) => {
                            e.preventDefault();
                            const mode = option.dataset.mode;
                            console.log('ðŸ“‹ Mode selected:', mode);
                            this.selectMode(mode);
                        });
                    });
                    
                    // Start call button
                    const startBtn = document.getElementById('start-call-btn');
                    if (startBtn) {
                        startBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            console.log('ðŸš€ Start call button clicked');
                            if (!this.isProcessing) {
                                this.startCall();
                            }
                        });
                    }
                    
                    // Microphone button
                    const micBtn = document.getElementById('mic-btn');
                    if (micBtn) {
                        micBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            console.log('ðŸŽ¤ Mic button clicked');
                            
                            if (this.voiceHandler) {
                                if (this.voiceHandler.isListening) {
                                    this.voiceHandler.stopListening();
                                } else {
                                    this.voiceHandler.startListening(false); // Manual start
                                }
                            }
                        });
                    }
                    
                    // End call button
                    const endCallBtn = document.getElementById('end-call-btn');
                    if (endCallBtn) {
                        endCallBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            console.log('ðŸ“ž End call button clicked');
                            this.endCall();
                        });
                    }
                    
                    // Feedback actions
                    const tryAgainBtn = document.getElementById('try-again-btn');
                    if (tryAgainBtn) {
                        tryAgainBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            console.log('ðŸ”„ Try again clicked');
                            this.tryAgain();
                        });
                    }
                    
                    const newModeBtn = document.getElementById('new-mode-btn');
                    if (newModeBtn) {
                        newModeBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            console.log('ðŸ†• New mode clicked');
                            this.showModeSelection();
                        });
                    }
                    
                    // Keyboard shortcuts
                    document.addEventListener('keydown', (e) => {
                        if (e.code === 'Space' && this.callState === 'connected' && !e.target.matches('input, textarea')) {
                            e.preventDefault();
                            this.handleSpacebarPress();
                        }
                        
                        if (e.code === 'Escape' && this.callState === 'connected') {
                            e.preventDefault();
                            console.log('âŒ¨ï¸ Escape key pressed - end call');
                            this.endCall();
                        }
                    });
                    
                    console.log('âœ… Event listeners setup complete');
                }
                
                handleSpacebarPress() {
                    // To be implemented by subclasses
                    console.log('Space pressed - implement in subclass');
                }
                
                initializeModeSelection() {
                    console.log('ðŸŽ¯ Initializing mode selection...');
                    
                    document.getElementById('mode-selection').style.display = 'flex';
                    document.getElementById('call-interface').style.display = 'none';
                    document.getElementById('feedback-section').style.display = 'none';
                    
                    this.callState = 'idle';
                    this.isActive = false;
                    this.isProcessing = false;
                    this.conversationHistory = [];
                    
                    // Stop any active audio or voice recognition
                    if (this.voiceHandler) {
                        this.voiceHandler.stopListening();
                    }
                }
                
                selectMode(mode) {
                    if (!mode || this.isProcessing) return;
                    
                    console.log('âœ… Mode selected:', mode);
                    this.selectedMode = mode;
                    
                    // Update UI
                    document.querySelectorAll('.mode-option').forEach(option => {
                        option.classList.remove('selected');
                    });
                    
                    const selectedOption = document.querySelector(`[data-mode="${mode}"]`);
                    if (selectedOption) {
                        selectedOption.classList.add('selected');
                    }
                    
                    // Update start button
                    const startBtn = document.getElementById('start-call-btn');
                    if (startBtn) {
                        startBtn.disabled = false;
                        startBtn.textContent = `Start ${this.capitalizeFirst(mode)} Mode`;
                    }
                }
                
                updateStartButton(text, disabled = false) {
                    const startBtn = document.getElementById('start-call-btn');
                    if (startBtn) {
                        startBtn.disabled = disabled;
                        if (disabled) {
                            startBtn.innerHTML = `<span class="spinner-border spinner-border-sm me-2"></span>${text}`;
                        } else {
                            startBtn.textContent = text;
                        }
                    }
                }
                
                async startPhoneCallSequence(initialResponse) {
                    console.log('Ã°Å¸â€œÅ¾ Starting phone call sequence...');
                    
                    // Hide mode selection, show call interface
                    document.getElementById('mode-selection').style.display = 'none';
                    document.getElementById('phone-container').style.display = 'block'; // Show the phone
                    document.getElementById('call-interface').style.display = 'flex';
                    
                    await this.dialingState();
                    await this.ringingState();
                    await this.connectedState(initialResponse);
                }
                async dialingState() {
                    console.log('ðŸ“± Dialing state...');
                    this.callState = 'dialing';
                    this.updateCallStatus('Calling...', 'dialing');
                    
                    const avatar = document.getElementById('contact-avatar');
                    if (avatar) {
                        avatar.classList.add('calling');
                    }
                    
                    await this.delay(2000);
                }
                
                async ringingState() {
                    console.log('ðŸ“³ Ringing state...');
                    this.callState = 'ringing';
                    this.updateCallStatus('Ringing...', 'ringing');
                    
                    await this.delay(3000);
                }
                
                async connectedState(initialResponse) {
                    console.log('âœ… Connected - Roleplay active!');
                    this.callState = 'connected';
                    this.updateCallStatus('Connected', 'connected');
                    
                    // Update UI
                    const avatar = document.getElementById('contact-avatar');
                    if (avatar) {
                        avatar.classList.remove('calling');
                        avatar.classList.add('roleplay-active');
                    }
                    
                    // Start call timer
                    this.callStartTime = Date.now();
                    this.startCallTimer();
                    
                    // Show live transcript
                    const transcript = document.getElementById('live-transcript');
                    if (transcript) {
                        transcript.classList.add('show');
                    }
                    
                    // Clear conversation history
                    this.conversationHistory = [];
                    
                    // Play initial AI response or start user turn
                    if (initialResponse) {
                        console.log('ðŸŽ¯ Playing initial AI response:', initialResponse);
                        await this.playAIResponseAndWaitForUser(initialResponse);
                    } else {
                        console.log('ðŸŽ¤ No initial response, starting user turn');
                        this.startUserTurn();
                    }
                }
                
                updateCallStatus(text, state) {
                    const callInterface = document.getElementById('call-interface');
                    const statusText = document.getElementById('call-status-text');
                    
                    if (callInterface) {
                        callInterface.className = `call-interface ${state}`;
                    }
                    
                    if (statusText) {
                        statusText.textContent = text;
                    }
                }
                
                startCallTimer() {
                    this.durationInterval = setInterval(() => {
                        const elapsed = Date.now() - this.callStartTime;
                        const minutes = Math.floor(elapsed / 60000);
                        const seconds = Math.floor((elapsed % 60000) / 1000);
                        
                        const durationElement = document.getElementById('call-duration');
                        if (durationElement) {
                            durationElement.textContent = 
                                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                        }
                    }, 1000);
                }
                
                addToConversationHistory(sender, message) {
                    this.conversationHistory.push({
                        sender: sender,
                        message: message,
                        timestamp: new Date()
                    });
                    
                    console.log(`ðŸ“ Added to conversation: ${sender} - ${message.substring(0, 50)}...`);
                }
                
                updateTranscript(text) {
                    const transcriptElement = document.getElementById('live-transcript');
                    if (transcriptElement) {
                        transcriptElement.textContent = text;
                    }
                }
                
                addPulseToMicButton() {
                    const micBtn = document.getElementById('mic-btn');
                    if (micBtn) {
                        micBtn.classList.add('pulse-animation');
                        setTimeout(() => {
                            micBtn.classList.remove('pulse-animation');
                        }, 3000);
                    }
                }
                
                async simulateSpeakingTime(text) {
                    const wordsPerMinute = 150;
                    const words = text.split(' ').length;
                    const speakingTimeMs = (words / wordsPerMinute) * 60 * 1000;
                    const minTime = 1000;
                    const maxTime = 5000;
                    
                    const delay = Math.max(minTime, Math.min(maxTime, speakingTimeMs));
                    console.log(`â±ï¸ Simulating speaking time: ${delay}ms for ${words} words`);
                    
                    return new Promise(resolve => setTimeout(resolve, delay));
                }
                
                updateUI(className) {
                    const container = document.getElementById('phone-container');
                    if (container) {
                        container.classList.add(className);
                    }
                }
                
                showError(message) {
                    console.error('âŒ Error:', message);
                    this.updateTranscript(`âŒ Error: ${message}`);
                    
                    const alertDiv = document.createElement('div');
                    alertDiv.className = 'alert alert-danger position-fixed';
                    alertDiv.style.cssText = 'top: 20px; right: 20px; z-index: 9999; max-width: 300px;';
                    alertDiv.innerHTML = `<strong>Error:</strong> ${message}`;
                    
                    document.body.appendChild(alertDiv);
                    
                    setTimeout(() => {
                        if (alertDiv.parentNode) {
                            alertDiv.remove();
                        }
                    }, 5000);
                }
                
                tryAgain() {
                    console.log('Ã°Å¸â€â€ž Trying again');
                    this.showModeSelection();
                }
            
                
                showModeSelection() {
                    console.log('Ã°Å¸Å½Â¯ Showing mode selection');
                    
                    // Hide phone and feedback, show mode selection
                    document.getElementById('phone-container').style.display = 'none';
                    document.getElementById('feedback-section').style.display = 'none';
                    document.getElementById('mode-selection').style.display = 'flex';
                    
                    this.initializeModeSelection(); // Re-initialize the selection state
                    
                    this.selectedMode = null;
                    this.currentSession = null;
                    
                    document.querySelectorAll('.mode-option').forEach(option => {
                        option.classList.remove('selected');
                    });

      📄 roleplay-1-1-manager.js (14.3KB)
          Content:
            // ===== FIXED: static/js/roleplay/roleplay-1-1-manager.js =====
            
            class Roleplay11Manager extends BaseRoleplayManager {
                constructor(options = {}) {
                    super(options);
                    this.roleplayId = "1.1";
                    this.roleplayType = "practice";
                    this.naturalMode = true;
                    this.conversationHistory = [];
                    this.currentAudio = null;
                    this.aiIsSpeaking = false;
                    
                }
                initializeModeSelection() {
                    console.log('Ã°Å¸Å½Â¯ Roleplay 1.1: Initializing specific mode selection.');
                    
                    // Define the modes for this specific roleplay
                    const modes = [
                        {
                            id: 'practice',
                            name: 'Practice Mode',
                            description: 'A single, detailed call with full AI coaching and feedback.',
                            icon: 'user-graduate'
                        }
                    ];
                    
                    // Use the helper from the base class to create the UI
                    this.createModeSelectionUI(modes);
                    
                    // Since there's only one mode, auto-select it
                    this.selectMode('practice');
                }
                init() {
                    console.log('Ã°Å¸Å¡â‚¬ Initializing Roleplay 1.1 Manager...');
                    super.init();
                    this.setupPracticeSpecificFeatures();
                }
                
                setupPracticeSpecificFeatures() {
                    // Enable natural conversation features
                    this.enableNaturalConversation();
                    
                    // Setup progress tracking
                    this.setupProgressTracking();
                    
                    // Setup interruption handling
                    this.setupInterruptionHandling();
                }
            
                // ===== ADD THESE TWO MISSING METHODS =====
                setupProgressTracking() {
                    console.log('Ã°Å¸â€œÅ  Practice Mode: Progress tracking setup.');
                    // This method makes the conversation quality indicator visible for practice mode.
                    const qualityElement = document.getElementById('conversation-quality');
                    if (qualityElement) {
                        qualityElement.style.display = 'block';
                    }
                }
            
                setupInterruptionHandling() {
                    console.log('Ã¢Å¡Â¡Ã¯Â¸  Practice Mode: Interruption handling setup confirmed.');
                    // The core logic is in the voice handler and handleUserInterruption method.
                    // This method is here to complete the initialization sequence.
                }
                // ===== END OF ADDED METHODS =====
                
                enableNaturalConversation() {
                    console.log('Ã°Å¸Â¤â€“ Enabling natural conversation features...');
                    
                    if (this.voiceHandler) {
                        this.voiceHandler.enableInterruption();
                    }
                    
                    // Show natural conversation indicators
                    this.updateUI('natural-mode-active');
                }
                
                async startCall() {
                    console.log('Ã°Å¸Å¡â‚¬ Starting Practice Mode call...');
                    
                    if (!this.selectedMode || this.isProcessing) {
                        console.log('Ã¢ Å’ Cannot start call: missing mode or already processing');
                        return;
                    }
                    
                    this.isProcessing = true;
                    this.updateStartButton('Connecting to Practice Mode...', true);
                    
                    try {
                        const response = await this.apiCall('/api/roleplay/start', {
                            method: 'POST',
                            body: JSON.stringify({
                                roleplay_id: this.roleplayId,
                                mode: this.selectedMode
                            })
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            console.log('Ã¢Å“â€¦ Practice Mode started successfully:', data);
                            
                            this.currentSession = data;
                            this.isActive = true;
                            
                            await this.startPhoneCallSequence(data.initial_response);
                            
                        } else {
                            const errorData = await response.json();
                            console.error('Ã¢ Å’ Failed to start Practice Mode:', errorData);
                            this.showError(errorData.error || 'Failed to start Practice Mode call');
                        }
                    } catch (error) {
                        console.error('Ã¢ Å’ Error starting Practice Mode:', error);
                        this.showError('Network error. Please try again.');
                    } finally {
                        this.isProcessing = false;
                        if (!this.isActive) {
                            this.updateStartButton(`Start Practice Mode ${this.capitalizeFirst(this.selectedMode)}`, false);
                        }
                    }
                }
                
                async processUserInput(transcript) {
                    if (!this.isActive || !this.currentSession || this.isProcessing) {
                        console.log('Ã¢ Å’ Cannot process user input - invalid state');
                        return;
                    }
                    
                    console.log('Ã°Å¸â€™Â¬ Processing Practice Mode input:', transcript);
                    this.isProcessing = true;
                    
                    this.addToConversationHistory('user', transcript);
                    this.updateTranscript('Ã°Å¸Â¤â€“ Processing your response...');
                    
                    try {
                        const response = await this.apiCall('/api/roleplay/respond', {
                            method: 'POST',
                            body: JSON.stringify({
                                user_input: transcript
                            })
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            console.log('Ã¢Å“â€¦ AI response received:', data);
                            
                            // Update conversation quality indicator
                            if (data.conversation_quality !== undefined) {
                                this.updateConversationQuality(data.conversation_quality);
                            }
                            
                            // Check if call should end
                            if (!data.call_continues) {
                                console.log('Ã°Å¸â€œÅ¾ Call ending...');
                                this.endCall(); // Let endCall handle the final data
                                return;
                            }
                            
                            // Play AI response and automatically start next user turn
                            await this.playAIResponseAndWaitForUser(data.ai_response);
                            
                        } else {
                            const errorData = await response.json();
                            console.error('Ã¢ Å’ API error:', errorData);
                            this.showError(errorData.error || 'Failed to process input');
                            this.startUserTurn(); // Resume user turn on error
                        }
                    } catch (error) {
                        console.error('Ã¢ Å’ Error processing user input:', error);
                        this.showError('Network error during call');
                        this.startUserTurn(); // Resume user turn on error
                    } finally {
                        this.isProcessing = false;
                    }
                }
                
                async playAIResponseAndWaitForUser(text) {
                    try {
                        console.log('Ã°Å¸Å½Â­ Playing AI response (interruptible):', text.substring(0, 50) + '...');
                        this.aiIsSpeaking = true;
                        
                        this.addToConversationHistory('ai', text);
                        this.updateTranscript(`Ã°Å¸Â¤â€“ Prospect: "${text}"`);
                        
                        // Try to play TTS audio (interruptible)
                        try {
                            const response = await this.apiCall('/api/roleplay/tts', {
                                method: 'POST',
                                body: JSON.stringify({ text: text })
                            });
                            
                            if (response.ok) {
                                const audioBlob = await response.blob();
                                
                                if (audioBlob.size > 100) {
                                    console.log('Ã°Å¸â€Å  Playing interruptible AI audio');
                                    const audioUrl = URL.createObjectURL(audioBlob);
                                    this.currentAudio = new Audio(audioUrl);
                                    
                                    // Setup audio event handlers
                                    this.currentAudio.onended = () => {
                                        console.log('Ã¢Å“â€¦ AI audio finished - starting user turn');
                                        URL.revokeObjectURL(audioUrl);
                                        this.currentAudio = null;
                                        
                                        // Only start user turn if AI is still speaking (not interrupted)
                                        if (this.aiIsSpeaking) {
                                            this.startUserTurn();
                                        }
                                    };
                                    
                                    this.currentAudio.onerror = () => {
                                        console.log('Ã¢ Å’ AI audio error - starting user turn');
                                        URL.revokeObjectURL(audioUrl);
                                        this.currentAudio = null;
                                        
                                        if (this.aiIsSpeaking) {
                                            this.startUserTurn();
                                        }
                                    };
                                    
                                    // Play the audio
                                    await this.currentAudio.play();
                                    
                                } else {
                                    console.log('Ã°Å¸â€œÂ¢ Audio too small, simulating speech time');
                                    await this.simulateSpeakingTime(text);
                                    if (this.aiIsSpeaking) {
                                        this.startUserTurn();
                                    }
                                }
                            } else {
                                console.log('Ã°Å¸Å½Âµ TTS failed, simulating speech time');
                                await this.simulateSpeakingTime(text);
                                if (this.aiIsSpeaking) {
                                    this.startUserTurn();
                                }
                            }
                        } catch (ttsError) {
                            console.log('Ã°Å¸â€Å  TTS error:', ttsError);
                            await this.simulateSpeakingTime(text);
                            if (this.aiIsSpeaking) {
                                this.startUserTurn();
                            }
                        }
                        
                    } catch (error) {
                        console.error('Ã¢ Å’ Error playing AI response:', error);
                        this.aiIsSpeaking = false;
                        await this.simulateSpeakingTime(text);
                        this.startUserTurn();
                    }
                }
                
                startUserTurn() {
                    console.log('Ã°Å¸â€˜Â¤ Starting user turn - auto-listening activated');
                    
                    this.aiIsSpeaking = false;
                    
                    // Start auto-listening for natural conversation
                    if (this.voiceHandler) {
                        this.voiceHandler.setUserTurn(true);
                        this.voiceHandler.startAutoListening();
                    }
                    
                    // Update UI
                    this.updateTranscript('Ã°Å¸Å½Â¤ Your turn - speak naturally...');
                    this.addPulseToMicButton();
                }
                
                handleUserInterruption() {
                    console.log('Ã¢Å¡Â¡ User interrupted AI - switching to user turn');
                    
                    // Stop AI audio immediately
                    this.stopCurrentAudio();
                    
                    // Mark AI as no longer speaking
                    this.aiIsSpeaking = false;
                    
                    // If voice handler not already listening, start it
                    if (this.voiceHandler && !this.voiceHandler.isListening) {
                        this.voiceHandler.setUserTurn(true);
                        this.voiceHandler.startAutoListening();
                    }
                    
                    // Update UI
                    this.updateTranscript('Ã¢Å¡Â¡ You interrupted - keep speaking...');
                }
                
                stopCurrentAudio() {
                    if (this.currentAudio) {
                        console.log('Ã°Å¸â€â€¡ Stopping current AI audio');
                        this.currentAudio.pause();
                        this.currentAudio.currentTime = 0;
                        this.currentAudio = null;
                    }
                }
                
                updateConversationQuality(quality) {
                    const qualityElement = document.getElementById('conversation-quality');
                    if (qualityElement) {
                        qualityElement.textContent = `${Math.round(quality)}%`;
                        qualityElement.className = 'conversation-quality';
                        
                        if (quality >= 70) {
                            qualityElement.classList.add('good');
                        } else if (quality >= 40) {
                            qualityElement.classList.add('fair');
                        } else {
                            qualityElement.classList.add('poor');
                        }
                    }
                }
                
                showFeedback(coaching, score = 75) {
                    console.log('Ã°Å¸â€œÅ  Showing Practice Mode feedback');
                    
                    document.getElementById('call-interface').style.display = 'none';
                    document.getElementById('feedback-section').style.display = 'flex';
                    
                    const feedbackHeader = document.querySelector('.feedback-header h4');
                    if (feedbackHeader) {
                        feedbackHeader.textContent = 'Practice Mode Complete!';
                    }
                    
                    if (coaching) {
                        this.populatePracticeCoaching(coaching);
                    }
                    
                    this.animateScore(score);
                    this.updateScoreCircleColor(score);
                }
                
                populatePracticeCoaching(coaching) {
                    const content = document.getElementById('feedback-content');
                    if (!content) return;
                    
                    content.innerHTML = '';
                    
                    if (coaching) {
                        const feedbackItems = [
                            { key: 'sales_coaching', icon: 'chart-line', title: 'Sales Performance (Natural Conversation)' },
                            { key: 'grammar_coaching', icon: 'spell-check', title: 'Grammar & Structure' },
                            { key: 'vocabulary_coaching', icon: 'book', title: 'Vocabulary' },
                            { key: 'pronunciation_coaching', icon: 'volume-up', title: 'Pronunciation' },
                            { key: 'rapport_assertiveness', icon: 'handshake', title: 'Rapport & Confidence' }
                        ];
                        
                        feedbackItems.forEach(item => {
                            if (coaching[item.key]) {
                                content.innerHTML += `
                                    <div class="feedback-item">
                                        <h6><i class="fas fa-${item.icon} me-2"></i>${item.title}</h6>
                                        <p style="margin: 0; font-size: 14px;">${coaching[item.key]}</p>
                                    </div>
                                `;
                            }
                        });
                    } else {
                        content.innerHTML = `
                            <div class="feedback-item">
                                <h6><i class="fas fa-info-circle me-2"></i>Practice Mode Complete</h6>
                                <p style="margin: 0; font-size: 14px;">Your natural conversation call is complete. Great job!</p>
                            </div>
                        `;
                    }
                }
            }
            
            // Export for global access
            window.Roleplay11Manager = Roleplay11Manager;

      📄 roleplay-1-2-manager.js (7.3KB)
          Content:
            
            
            // static/js/roleplay/roleplay-1-2-manager.js
            class Roleplay12Manager extends BaseRoleplayManager {
                constructor(containerId) {
                    super(containerId);
                    this.marathonState = {
                        currentCall: 1,
                        totalCalls: 10,
                        callsPassed: 0,
                        callsFailed: 0,
                        isComplete: false
                    };
                }
                
                async startCall() {
                    // Marathon-specific call start logic
                    console.log('ðŸƒ Starting Marathon Mode call...');
                    
                    // Implementation similar to Roleplay 1.1 but with marathon tracking
                    const response = await this.apiCall('/api/roleplay/start', {
                        method: 'POST',
                        body: JSON.stringify({
                            roleplay_id: '1.2',
                            mode: this.selectedMode
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        this.currentSession = data;
                        this.marathonState = data.marathon_status || this.marathonState;
                        
                        await this.startPhoneCallSequence(data.initial_response);
                    }
                }
                
                async processUserInput(transcript) {
                    console.log('ðŸƒ Processing Marathon input:', transcript);
                    
                    const response = await this.apiCall('/api/roleplay/respond', {
                        method: 'POST',
                        body: JSON.stringify({
                            user_input: transcript
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        
                        // Update marathon state
                        if (data.marathon_status) {
                            this.marathonState = data.marathon_status;
                            this.updateMarathonUI();
                        }
                        
                        // Handle marathon completion
                        if (data.marathon_complete) {
                            this.handleMarathonComplete(data);
                            return;
                        }
                        
                        // Handle new call started
                        if (data.new_call_started) {
                            this.handleNewCallStarted(data);
                            return;
                        }
                        
                        // Normal response handling
                        if (data.call_continues) {
                            await this.playAIResponseAndWaitForUser(data.ai_response);
                        } else {
                            this.endCall(data.call_result === 'passed');
                        }
                    }
                }
                
                handleNewCallStarted(data) {
                    console.log(`ðŸ”„ Starting call ${this.marathonState.currentCall}/${this.marathonState.totalCalls}`);
                    
                    // Show transition UI
                    this.updateTranscript(`ðŸ“ž Starting call ${this.marathonState.currentCall}/${this.marathonState.totalCalls}...`);
                    
                    setTimeout(async () => {
                        await this.playAIResponseAndWaitForUser(data.ai_response);
                    }, 1000);
                }
                
                handleMarathonComplete(data) {
                    console.log('ðŸ Marathon complete!', data.marathon_status);
                    
                    setTimeout(() => {
                        this.showMarathonResults(data);
                    }, 2000);
                }
                
                updateMarathonUI() {
                    // Update progress indicators
                    const progressElement = document.getElementById('marathon-progress');
                    if (progressElement) {
                        progressElement.innerHTML = `
                            <div class="marathon-stats">
                                <span>Call ${this.marathonState.currentCall}/${this.marathonState.totalCalls}</span>
                                <span>Passed: ${this.marathonState.callsPassed}</span>
                                <span>Failed: ${this.marathonState.callsFailed}</span>
                                <span>Need: ${this.marathonState.callsToPass}</span>
                            </div>
                        `;
                    }
                }
                
                showMarathonResults(data) {
                    console.log('ðŸ“Š Showing Marathon results');
                    
                    document.getElementById('call-interface').style.display = 'none';
                    document.getElementById('feedback-section').style.display = 'flex';
                    
                    const marathonResults = data.marathon_status;
                    const passed = marathonResults.is_passed;
                    
                    // Show results
                    const content = document.getElementById('feedback-content');
                    content.innerHTML = `
                        <div class="marathon-results">
                            <h3>${passed ? 'ðŸŽ‰ Marathon Passed!' : 'ðŸ“ˆ Marathon Complete'}</h3>
                            <div class="results-grid">
                                <div class="result-item">
                                    <strong>Calls Passed:</strong> ${marathonResults.callsPassed}/${marathonResults.totalCalls}
                                </div>
                                <div class="result-item">
                                    <strong>Target:</strong> ${marathonResults.callsToPass} calls
                                </div>
                                <div class="result-item">
                                    <strong>Success Rate:</strong> ${Math.round((marathonResults.callsPassed / marathonResults.totalCalls) * 100)}%
                                </div>
                            </div>
                            
                            ${passed ? 
                                '<p>ðŸ”“ You\'ve unlocked modules 2.1 & 2.2 for 24 hours and earned one Legend Mode attempt!</p>' :
                                '<p>Keep practicing! The more reps you get, the easier it becomes. Ready to try Marathon again?</p>'
                            }
                        </div>
                    `;
                    
                    // Show coaching if available
                    if (data.coaching) {
                        this.populateMarathonCoaching(data.coaching);
                    }
                }
                
                populateMarathonCoaching(coaching) {
                    const content = document.getElementById('feedback-content');
                    
                    const coachingHTML = `
                        <div class="marathon-coaching">
                            <h4>ðŸ“ Marathon Coaching</h4>
                            <div class="coaching-grid">
                                <div class="coaching-item">
                                    <h6>ðŸŽ¯ Sales Performance</h6>
                                    <p>${coaching.sales_coaching || 'Good job on completing the marathon!'}</p>
                                </div>
                                <div class="coaching-item">
                                    <h6>ðŸ“ Grammar</h6>
                                    <p>${coaching.grammar_coaching || 'Focus on using natural contractions.'}</p>
                                </div>
                                <div class="coaching-item">
                                    <h6>ðŸ“– Vocabulary</h6>
                                    <p>${coaching.vocabulary_coaching || 'Use simple, outcome-focused language.'}</p>
                                </div>
                                <div class="coaching-item">
                                    <h6>ðŸŽ¤ Pronunciation</h6>
                                    <p>${coaching.pronunciation_coaching || 'Practice speaking clearly and consistently.'}</p>
                                </div>
                                <div class="coaching-item">
                                    <h6>ðŸ¤ Rapport & Confidence</h6>
                                    <p>${coaching.rapport_assertiveness || 'Show empathy first, then be confident.'}</p>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    content.innerHTML += coachingHTML;
                }
                
                showFeedback(coaching, score = 75) {
                    // Marathon uses different feedback display
                    this.showMarathonResults({
                        marathon_status: this.marathonState,
                        coaching: coaching
                    });
                }
            }
            
            // Export for global access
            window.Roleplay12Manager = Roleplay12Manager;

      📄 roleplay-factory.js (2.5KB)
          Content:
            // ===== static/js/roleplay/roleplay-factory.js (Complete Implementation) =====
            
            class RoleplayFactory {
                static managerClasses = {};
                static initialized = false;
                
                static initialize() {
                    if (this.initialized) return;
                    
                    try {
                        // Register available manager classes
                        if (typeof Roleplay11Manager !== 'undefined') {
                            this.managerClasses["1.1"] = Roleplay11Manager;
                        }
                        if (typeof Roleplay12Manager !== 'undefined') {
                            this.managerClasses["1.2"] = Roleplay12Manager;
                        }
                        
                        console.log('ðŸ­ Roleplay Factory initialized with:', Object.keys(this.managerClasses));
                        this.initialized = true;
                        
                    } catch (error) {
                        console.error('âŒ Failed to initialize Roleplay Factory:', error);
                    }
                }
                
                static createManager(roleplayId, options = {}) {
                    this.initialize();
                    
                    const ManagerClass = this.managerClasses[roleplayId];
                    if (!ManagerClass) {
                        const available = Object.keys(this.managerClasses);
                        throw new Error(`Unknown roleplay ID: ${roleplayId}. Available: ${available.join(', ')}`);
                    }
                    
                    console.log(`ðŸ­ Creating ${roleplayId} manager`);
                    return new ManagerClass(options);
                }
                
                static getAvailableRoleplays() {
                    this.initialize();
                    return Object.keys(this.managerClasses);
                }
                
                static registerManager(roleplayId, managerClass) {
                    this.managerClasses[roleplayId] = managerClass;
                    console.log(`ðŸ­ Registered new manager: ${roleplayId}`);
                }
                
                static getManagerInfo(roleplayId) {
                    this.initialize();
                    
                    const infoMap = {
                        "1.1": {
                            name: "Practice Mode",
                            description: "Single call with detailed CEFR A2 coaching",
                            icon: "user-graduate",
                            color: "#60a5fa"
                        },
                        "1.2": {
                            name: "Marathon Mode", 
                            description: "10 calls, need 6 to pass",
                            icon: "running",
                            color: "#fbbf24"
                        }
                    };
                    
                    return infoMap[roleplayId] || {
                        name: `Roleplay ${roleplayId}`,
                        description: "Roleplay training",
                        icon: "phone",
                        color: "#6b7280"
                    };
                }
            }
            
            // Export for global access
            window.RoleplayFactory = RoleplayFactory;

    📁 utils/
      📄 api-client.js (1.8KB)
          Content:
            // ===== static/js/utils/api-client.js =====
            
            class ApiClient {
                constructor() {
                    this.baseUrl = '';
                    this.defaultHeaders = {
                        'Content-Type': 'application/json'
                    };
                }
                
                setAuthToken(token) {
                    this.defaultHeaders['Authorization'] = `Bearer ${token}`;
                }
                
                async request(endpoint, options = {}) {
                    const url = `${this.baseUrl}${endpoint}`;
                    const config = {
                        headers: { ...this.defaultHeaders, ...options.headers },
                        ...options
                    };
                    
                    console.log(`ðŸŒ API: ${options.method || 'GET'} ${endpoint}`);
                    
                    try {
                        const response = await fetch(url, config);
                        
                        if (response.status === 401) {
                            console.error('ðŸ” Authentication required');
                            window.location.href = '/login';
                            throw new Error('Authentication required');
                        }
                        
                        return response;
                        
                    } catch (error) {
                        console.error('âŒ API Error:', error);
                        throw error;
                    }
                }
                
                async get(endpoint, options = {}) {
                    return this.request(endpoint, { ...options, method: 'GET' });
                }
                
                async post(endpoint, data, options = {}) {
                    return this.request(endpoint, {
                        ...options,
                        method: 'POST',
                        body: JSON.stringify(data)
                    });
                }
                
                async put(endpoint, data, options = {}) {
                    return this.request(endpoint, {
                        ...options,
                        method: 'PUT',
                        body: JSON.stringify(data)
                    });
                }
                
                async delete(endpoint, options = {}) {
                    return this.request(endpoint, { ...options, method: 'DELETE' });
                }
            }
            
            // Global instance
            window.apiClient = new ApiClient();

      📄 ui-helpers.js (3.3KB)
          Content:
            // ===== static/js/utils/ui-helpers.js =====
            
            class UIHelpers {
                static showNotification(message, type = 'info', duration = 5000) {
                    const notification = document.createElement('div');
                    notification.className = `alert alert-${type} position-fixed`;
                    notification.style.cssText = 'top: 20px; right: 20px; z-index: 9999; max-width: 300px;';
                    notification.innerHTML = message;
                    
                    document.body.appendChild(notification);
                    
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, duration);
                }
                
                static showError(message) {
                    this.showNotification(`<strong>Error:</strong> ${message}`, 'danger');
                }
                
                static showSuccess(message) {
                    this.showNotification(`<strong>Success:</strong> ${message}`, 'success');
                }
                
                static showWarning(message) {
                    this.showNotification(`<strong>Warning:</strong> ${message}`, 'warning');
                }
                
                static showLoading(element, text = 'Loading...') {
                    if (element) {
                        element.disabled = true;
                        element.innerHTML = `<span class="spinner-border spinner-border-sm me-2"></span>${text}`;
                    }
                }
                
                static hideLoading(element, originalText) {
                    if (element) {
                        element.disabled = false;
                        element.innerHTML = originalText;
                    }
                }
                
                static animateScore(element, targetScore, duration = 2000) {
                    if (!element) return;
                    
                    let currentScore = 0;
                    const increment = targetScore / (duration / 50);
                    
                    const timer = setInterval(() => {
                        currentScore += increment;
                        if (currentScore >= targetScore) {
                            currentScore = targetScore;
                            clearInterval(timer);
                        }
                        element.textContent = Math.round(currentScore);
                    }, 50);
                }
                
                static capitalizeFirst(str) {
                    return str.charAt(0).toUpperCase() + str.slice(1);
                }
                
                static formatDuration(seconds) {
                    const minutes = Math.floor(seconds / 60);
                    const remainingSeconds = seconds % 60;
                    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
                }
                
                static debounce(func, wait) {
                    let timeout;
                    return function executedFunction(...args) {
                        const later = () => {
                            clearTimeout(timeout);
                            func(...args);
                        };
                        clearTimeout(timeout);
                        timeout = setTimeout(later, wait);
                    };
                }
                
                static throttle(func, limit) {
                    let lastFunc;
                    let lastRan;
                    return function executedFunction(...args) {
                        if (!lastRan) {
                            func(...args);
                            lastRan = Date.now();
                        } else {
                            clearTimeout(lastFunc);
                            lastFunc = setTimeout(() => {
                                if ((Date.now() - lastRan) >= limit) {
                                    func(...args);
                                    lastRan = Date.now();
                                }
                            }, limit - (Date.now() - lastRan));
                        }
                    };
                }
            }
            
            // Global access
            window.UIHelpers = UIHelpers;

📁 templates/
  📄 404.html (1.4KB)
      Content:
        <!-- ===== TEMPLATES/404.HTML ===== -->
        {% extends "base.html" %}
        
        {% block title %}Page Not Found - Cold Calling Coach{% endblock %}
        
        {% block content %}
        <div class="container py-5">
            <div class="row justify-content-center">
                <div class="col-md-6 text-center">
                    <div class="error-page">
                        <div class="error-icon mb-4">
                            <i class="fas fa-search fa-5x text-muted"></i>
                        </div>
                        <h1 class="display-4 fw-bold text-primary">404</h1>
                        <h2 class="mb-3">Page Not Found</h2>
                        <p class="lead text-muted mb-4">
                            Sorry, the page you're looking for doesn't exist or has been moved.
                        </p>
                        <div class="d-flex gap-3 justify-content-center">
                            <a href="{{ url_for('home') }}" class="btn btn-primary">
                                <i class="fas fa-home me-2"></i>Go Home
                            </a>
                            <a href="{{ url_for('dashboard_page') }}" class="btn btn-outline-primary">
                                <i class="fas fa-tachometer-alt me-2"></i>Dashboard
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <style>
        .error-page {
            padding: 3rem 2rem;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        
        .error-icon {
            opacity: 0.7;
        }
        </style>
        {% endblock %}
        

  📄 500.html (1.4KB)
      Content:
        <!-- ===== TEMPLATES/500.HTML (NEW) ===== -->
        {% extends "base.html" %}
        
        {% block title %}Server Error - Cold Calling Coach{% endblock %}
        
        {% block content %}
        <div class="container py-5">
            <div class="row justify-content-center">
                <div class="col-md-6 text-center">
                    <div class="error-page">
                        <div class="error-icon mb-4">
                            <i class="fas fa-exclamation-triangle fa-5x text-warning"></i>
                        </div>
                        <h1 class="display-4 fw-bold text-danger">500</h1>
                        <h2 class="mb-3">Server Error</h2>
                        <p class="lead text-muted mb-4">
                            Something went wrong on our end. We're working to fix it!
                        </p>
                        <div class="d-flex gap-3 justify-content-center">
                            <a href="{{ url_for('home') }}" class="btn btn-primary">
                                <i class="fas fa-home me-2"></i>Go Home
                            </a>
                            <button onclick="window.location.reload()" class="btn btn-outline-primary">
                                <i class="fas fa-sync-alt me-2"></i>Try Again
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <style>
        .error-page {
            padding: 3rem 2rem;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        
        .error-icon {
            opacity: 0.7;
        }
        </style>
        {% endblock %}

  📄 about.html (3.4KB)
      Content:
        <!-- ===== TEMPLATES/ABOUT.HTML ===== -->
        {% extends "base.html" %}
        
        {% block title %}About - Cold Calling Coach{% endblock %}
        
        {% block content %}
        <div class="container py-5">
            <div class="row justify-content-center">
                <div class="col-lg-8">
                    <div class="text-center mb-5">
                        <h1 class="display-4 fw-bold text-primary">About Cold Calling Coach</h1>
                        <p class="lead text-muted">Revolutionizing sales training with AI-powered simulations</p>
                    </div>
                    
                    <div class="about-content">
                        <div class="row mb-5">
                            <div class="col-md-6">
                                <h3 class="fw-bold mb-3">Our Mission</h3>
                                <p>
                                    We help non-native English speakers master cold calling through realistic AI-powered practice sessions. 
                                    Our platform provides a safe space to build confidence and improve sales skills.
                                </p>
                            </div>
                            <div class="col-md-6">
                                <h3 class="fw-bold mb-3">Why It Works</h3>
                                <p>
                                    Practice makes perfect. Our AI prospects respond like real decision-makers, giving you 
                                    the experience you need without the pressure of real calls.
                                </p>
                            </div>
                        </div>
                        
                        <div class="feature-highlight p-4 mb-5">
                            <h3 class="fw-bold mb-3">What Makes Us Different</h3>
                            <div class="row">
                                <div class="col-md-4 mb-3">
                                    <i class="fas fa-brain fa-2x text-primary mb-2"></i>
                                    <h5>Advanced AI</h5>
                                    <p class="text-muted">GPT-4 powered prospects that respond naturally</p>
                                </div>
                                <div class="col-md-4 mb-3">
                                    <i class="fas fa-microphone fa-2x text-success mb-2"></i>
                                    <h5>Voice Training</h5>
                                    <p class="text-muted">Real-time speech recognition and feedback</p>
                                </div>
                                <div class="col-md-4 mb-3">
                                    <i class="fas fa-chart-line fa-2x text-warning mb-2"></i>
                                    <h5>Progress Tracking</h5>
                                    <p class="text-muted">Detailed analytics to track improvement</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="text-center">
                            <h3 class="fw-bold mb-3">Ready to Get Started?</h3>
                            <p class="mb-4">Join thousands of sales professionals improving their cold calling skills.</p>
                            <a href="{{ url_for('register_page') }}" class="btn btn-primary btn-lg">
                                <i class="fas fa-rocket me-2"></i>Start Free Trial
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <style>
        .about-content {
            background: white;
            padding: 3rem;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        
        .feature-highlight {
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 5px solid var(--bs-primary);
        }
        </style>
        {% endblock %}

  📄 admin.html (26.2KB)
      Content:
        
        <!-- ===== TEMPLATES/ADMIN.HTML ===== -->
        {% extends "base.html" %}
        
        {% block title %}Admin Dashboard - Cold Calling Coach{% endblock %}
        
        {% block extra_css %}
        <link rel="stylesheet" href="{{ url_for('static', filename='css/admin.css') }}">
        <style>
        /* Admin-specific styles */
        .admin-header {
            background: linear-gradient(135deg, #dc3545, #c82333);
            color: white;
            padding: 2rem;
            border-radius: 15px;
            margin-bottom: 2rem;
        }
        
        .stats-card {
            background: white;
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            text-align: center;
            margin-bottom: 1.5rem;
            transition: transform 0.3s ease;
        }
        
        .stats-card:hover {
            transform: translateY(-5px);
        }
        
        .stats-number {
            font-size: 2.5rem;
            font-weight: 700;
            color: #dc3545;
            line-height: 1;
        }
        
        .stats-label {
            color: #6c757d;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 0.5rem;
        }
        
        .user-table {
            background: white;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .access-level-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        .access-level-trial {
            background: #fff3cd;
            color: #856404;
        }
        
        .access-level-basic {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .access-level-pro {
            background: #d4edda;
            color: #155724;
        }
        
        /* Fixed spinner and loading styles */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            backdrop-filter: blur(4px);
        }
        
        .loading-spinner {
            background: white;
            padding: 2rem;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            min-width: 200px;
        }
        
        /* Fix Bootstrap spinner */
        .spinner-border {
            width: 2rem;
            height: 2rem;
            border-width: 0.25em;
        }
        
        .spinner-border-sm {
            width: 1rem;
            height: 1rem;
            border-width: 0.125em;
        }
        
        /* Button loading state */
        .btn:disabled {
            opacity: 0.65;
            cursor: not-allowed;
        }
        
        /* Smooth transitions */
        .modal {
            transition: opacity 0.15s linear;
        }
        
        .fade {
            transition: opacity 0.15s linear;
        }
        
        .fade:not(.show) {
            opacity: 0;
        }
        
        .fade.show {
            opacity: 1;
        }
        
        /* Fix table responsiveness */
        .table-responsive {
            border-radius: 0;
        }
        
        /* Improve button group spacing */
        .btn-group .btn {
            margin-right: 0;
        }
        
        .btn-group .btn:not(:last-child) {
            border-right: none;
        }
        
        /* Better alert positioning */
        .alert-message {
            position: fixed !important;
            top: 20px !important;
            right: 20px !important;
            z-index: 10000 !important;
            min-width: 300px !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2) !important;
            border: none !important;
        }
        
        /* Access level modal improvements */
        .modal-dialog {
            margin: 1.75rem auto;
        }
        
        .modal-content {
            border: none;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .modal-header {
            border-bottom: 1px solid #dee2e6;
            border-radius: 15px 15px 0 0;
        }
        
        .modal-footer {
            border-top: 1px solid #dee2e6;
            border-radius: 0 0 15px 15px;
        }
        
        </style>
        {% endblock %}
        
        {% block content %}
        <div class="container-fluid py-4">
            <!-- Admin Header -->
            <div class="admin-header">
                <div class="row align-items-center">
                    <div class="col-md-8">
                        <h1 class="mb-2"><i class="fas fa-shield-alt me-2"></i>Admin Dashboard</h1>
                        <p class="mb-0 opacity-75">Manage users, monitor platform usage, and view analytics</p>
                    </div>
                    <div class="col-md-4 text-end">
                        <button class="btn btn-light btn-sm me-2" onclick="refreshDashboard()">
                            <i class="fas fa-sync-alt me-1"></i>Refresh
                        </button>
                        <button class="btn btn-outline-light btn-sm" onclick="exportData()">
                            <i class="fas fa-download me-1"></i>Export
                        </button>
                    </div>
                </div>
            </div>
        
            <!-- Platform Statistics -->
            <div class="row mb-4">
                <div class="col-12">
                    <h3 class="mb-3">Platform Overview</h3>
                </div>
            </div>
        
            <div class="row mb-4" id="stats-grid">
                <!-- Stats will be loaded here -->
                <div class="col-lg-2 col-md-4 col-sm-6">
                    <div class="stats-card">
                        <div class="stats-number" id="total-users">-</div>
                        <div class="stats-label">Total Users</div>
                    </div>
                </div>
                <div class="col-lg-2 col-md-4 col-sm-6">
                    <div class="stats-card">
                        <div class="stats-number" id="trial-users">-</div>
                        <div class="stats-label">Trial Users</div>
                    </div>
                </div>
                <div class="col-lg-2 col-md-4 col-sm-6">
                    <div class="stats-card">
                        <div class="stats-number" id="basic-users">-</div>
                        <div class="stats-label">Basic Users</div>
                    </div>
                </div>
                <div class="col-lg-2 col-md-4 col-sm-6">
                    <div class="stats-card">
                        <div class="stats-number" id="pro-users">-</div>
                        <div class="stats-label">Pro Users</div>
                    </div>
                </div>
                <div class="col-lg-2 col-md-4 col-sm-6">
                    <div class="stats-card">
                        <div class="stats-number" id="total-sessions">-</div>
                        <div class="stats-label">Total Sessions</div>
                    </div>
                </div>
                <div class="col-lg-2 col-md-4 col-sm-6">
                    <div class="stats-card">
                        <div class="stats-number" id="success-rate">-%</div>
                        <div class="stats-label">Success Rate</div>
                    </div>
                </div>
            </div>
        
            <!-- User Management -->
            <div class="row">
                <div class="col-12">
                    <div class="user-table">
                        <div class="card-header bg-light">
                            <div class="row align-items-center">
                                <div class="col-md-6">
                                    <h5 class="mb-0"><i class="fas fa-users me-2"></i>User Management</h5>
                                </div>
                                <div class="col-md-6">
                                    <div class="d-flex gap-2">
                                        <input type="text" class="form-control form-control-sm" 
                                               id="user-search" placeholder="Search users..." 
                                               onkeyup="searchUsers()">
                                        <button class="btn btn-primary btn-sm" onclick="loadUsers()">
                                            <i class="fas fa-search"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="card-body p-0">
                            <div class="table-responsive">
                                <table class="table table-hover mb-0">
                                    <thead class="bg-light">
                                        <tr>
                                            <th>User</th>
                                            <th>Email</th>
                                            <th>Access Level</th>
                                            <th>Usage</th>
                                            <th>Joined</th>
                                            <th>Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody id="users-table-body">
                                        <tr>
                                            <td colspan="6" class="text-center py-4">
                                                <div class="spinner-border text-primary" role="status">
                                                    <span class="visually-hidden">Loading...</span>
                                                </div>
                                                <div class="mt-2">Loading users...</div>
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <div class="card-footer bg-light">
                            <div class="row align-items-center">
                                <div class="col-md-6">
                                    <small class="text-muted" id="users-info">Loading...</small>
                                </div>
                                <div class="col-md-6">
                                    <nav>
                                        <ul class="pagination pagination-sm justify-content-end mb-0" id="users-pagination">
                                            <!-- Pagination will be generated here -->
                                        </ul>
                                    </nav>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Access Level Change Modal -->
        <div class="modal fade" id="accessLevelModal" tabindex="-1">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Change Access Level</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <p>Change access level for <strong id="modal-user-name"></strong>:</p>
                        <div class="form-group">
                            <label for="new-access-level">New Access Level:</label>
                            <select class="form-select" id="new-access-level">
                                <option value="limited_trial">Limited Trial</option>
                                <option value="unlimited_basic">Unlimited Basic</option>
                                <option value="unlimited_pro">Unlimited Pro</option>
                                <option value="admin">Admin</option>
                            </select>
                        </div>
                        <div class="alert alert-info mt-3">
                            <small>
                                <strong>Trial:</strong> 3 hours total, 7 days max<br>
                                <strong>Basic:</strong> 50 hours/month, 24h unlocks<br>
                                <strong>Pro:</strong> 50 hours/month, permanent unlocks<br>
                                <strong>Admin:</strong> Full access to admin panel
                            </small>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" onclick="updateAccessLevel()">
                            <span class="button-text">Update</span>
                            <span class="button-spinner" style="display: none;">
                                <span class="spinner-border spinner-border-sm me-1"></span>Updating...
                            </span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
        <!-- Loading Overlay -->
        <div class="loading-overlay" id="loading-overlay" style="display: none;">
            <div class="loading-spinner">
                <div class="spinner-border text-primary mb-2" role="status"></div>
                <div>Processing...</div>
            </div>
        </div>
        
        {% endblock %}
        
        {% block extra_js %}
        <script src="{{ url_for('static', filename='js/admin.js') }}"></script>
        <script>
        // Admin Dashboard JavaScript
        class AdminDashboard {
            constructor() {
                this.currentPage = 1;
                this.itemsPerPage = 20;
                this.currentSearch = '';
                this.selectedUserId = null;
                this.selectedUserName = '';
                
                this.initialize();
            }
            
            initialize() {
                this.loadStats();
                this.loadUsers();
                
                // Set up search debouncing
                let searchTimeout;
                document.getElementById('user-search').addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        this.currentSearch = e.target.value;
                        this.currentPage = 1;
                        this.loadUsers();
                    }, 500);
                });
            }
            
            async loadStats() {
                try {
                    const response = await fetch('/api/admin/stats', {
                        headers: {
                            'Authorization': `Bearer ${localStorage.getItem('access_token') || ''}`
                        }
                    });
                    
                    if (response.ok) {
                        const stats = await response.json();
                        this.displayStats(stats);
                    } else {
                        console.error('Failed to load stats');
                    }
                } catch (error) {
                    console.error('Error loading stats:', error);
                }
            }
            
            displayStats(stats) {
                document.getElementById('total-users').textContent = stats.total_users || 0;
                document.getElementById('trial-users').textContent = stats.trial_users || 0;
                document.getElementById('basic-users').textContent = stats.basic_users || 0;
                document.getElementById('pro-users').textContent = stats.pro_users || 0;
                document.getElementById('total-sessions').textContent = stats.total_sessions || 0;
                document.getElementById('success-rate').textContent = `${stats.success_rate || 0}%`;
            }
            
            async loadUsers() {
                try {
                    const params = new URLSearchParams({
                        page: this.currentPage,
                        limit: this.itemsPerPage,
                        search: this.currentSearch
                    });
                    
                    const response = await fetch(`/api/admin/users?${params}`, {
                        headers: {
                            'Authorization': `Bearer ${localStorage.getItem('access_token') || ''}`
                        }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        this.displayUsers(data);
                    } else {
                        console.error('Failed to load users');
                        this.showError('Failed to load users');
                    }
                } catch (error) {
                    console.error('Error loading users:', error);
                    this.showError('Error loading users');
                }
            }
            
            displayUsers(data) {
                const tbody = document.getElementById('users-table-body');
                const users = data.users || [];
                
                if (users.length === 0) {
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="6" class="text-center py-4 text-muted">
                                No users found
                            </td>
                        </tr>
                    `;
                    return;
                }
                
                tbody.innerHTML = users.map(user => this.createUserRow(user)).join('');
                
                // Update pagination and info
                this.updatePagination(data);
                this.updateUsersInfo(data);
            }
            
            createUserRow(user) {
                const joinDate = new Date(user.created_at).toLocaleDateString();
                const accessLevelClass = `access-level-${user.access_level.split('_')[0]}`;
                const usagePercent = this.calculateUsagePercent(user);
                
                return `
                    <tr>
                        <td>
                            <div class="d-flex align-items-center">
                                <div class="avatar-placeholder me-2">
                                    ${user.first_name.charAt(0).toUpperCase()}
                                </div>
                                <div>
                                    <div class="fw-medium">${user.first_name}</div>
                                    <small class="text-muted">${user.prospect_job_title}</small>
                                </div>
                            </div>
                        </td>
                        <td>
                            <div>${user.email || 'N/A'}</div>
                            <small class="text-muted">${user.prospect_industry}</small>
                        </td>
                        <td>
                            <span class="access-level-badge ${accessLevelClass}">
                                ${this.formatAccessLevel(user.access_level)}

  📄 base.html (3.6KB)
      Content:
        <!-- ===== TEMPLATES/BASE.HTML ===== -->
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>{% block title %}Cold Calling Coach{% endblock %}</title>
            
            <!-- Bootstrap CSS -->
            <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
            
            <!-- Font Awesome -->
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
            
            <!-- Custom CSS -->
            <link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}">
            
            <!-- Page-specific CSS -->
            {% block extra_css %}{% endblock %}
            
            <!-- Favicon -->
            <link rel="icon" type="image/x-icon" href="{{ url_for('static', filename='favicon.ico') }}">
        </head>
        <body>
            <!-- Navigation -->
            <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
                <div class="container">
                    <a class="navbar-brand fw-bold" href="{{ url_for('home') }}">
                        <i class="fas fa-phone me-2"></i>Cold Calling Coach
                    </a>
                    
                    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                        <span class="navbar-toggler-icon"></span>
                    </button>
                    
                    <div class="collapse navbar-collapse" id="navbarNav">
                        <ul class="navbar-nav me-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="{{ url_for('home') }}">Home</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="{{ url_for('about') }}">About</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="{{ url_for('pricing') }}">Pricing</a>
                            </li>
                        </ul>
                        
                        <ul class="navbar-nav">
                            <li class="nav-item" id="login-btn" style="display: none;">
                                <a class="nav-link" href="{{ url_for('login_page') }}">
                                    <i class="fas fa-sign-in-alt me-1"></i>Login
                                </a>
                            </li>
                            <li class="nav-item" id="logout-btn" style="display: none;">
                                <a class="nav-link" href="#" id="logout-link">
                                    <i class="fas fa-sign-out-alt me-1"></i>Logout
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>
            </nav>
        
            <!-- Main Content -->
            <main>
                {% block content %}{% endblock %}
            </main>
        
            <!-- Footer -->
            <footer class="bg-dark text-light py-4 mt-5">
                <div class="container">
                    <div class="row">
                        <div class="col-md-6">
                            <h5>Cold Calling Coach</h5>
                            <p class="text-muted">Master your cold calling skills with AI-powered training.</p>
                        </div>
                        <div class="col-md-6 text-end">
                            <p class="text-muted">&copy; {{ current_year() }} Cold Calling Coach. All rights reserved.</p>
                        </div>
                    </div>
                </div>
            </footer>
        
            <!-- Bootstrap JS -->
            <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
            
            <!-- Main JS -->
            <script src="{{ url_for('static', filename='js/main.js') }}"></script>
            
            <!-- Page-specific JS -->
            {% block extra_js %}{% endblock %}
        </body>
        </html>

  📄 dashboard.html (11.5KB)
      Content:
        <!-- ===== TEMPLATES/DASHBOARD.HTML ===== -->
        {% extends "base.html" %}
        
        {% block title %}Dashboard - Cold Calling Coach{% endblock %}
        
        {% block extra_css %}
        <link rel="stylesheet" href="{{ url_for('static', filename='css/dashboard.css') }}">
        {% endblock %}
        
        {% block content %}
        <div class="container-fluid py-4">
            <!-- Welcome Section -->
            <div class="row mb-4">
                <div class="col-12">
                    <div class="dashboard-card">
                        <div class="row align-items-center">
                            <div class="col-md-8">
                                <h1 class="mb-2">Welcome back, <span id="user-first-name">Loading...</span>!</h1>
                                <p class="lead text-muted mb-0">Ready to practice your cold calling skills?</p>
                            </div>
                            <div class="col-md-4 text-end">
                                <div class="access-level-badge" id="access-level-badge">
                                    <i class="fas fa-crown me-2"></i>
                                    <span id="access-level-text">Loading...</span>
                                </div>
                                <button class="btn btn-outline-primary btn-sm mt-2" id="refresh-dashboard">
                                    <i class="fas fa-sync-alt me-1"></i>Refresh
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        
            <!-- Stats Row -->
            <div class="stats-grid" id="stats-grid">
                <!-- Stats will be loaded here -->
                <div class="stat-card">
                    <div class="stat-icon text-primary">
                        <i class="fas fa-spinner fa-spin"></i>
                    </div>
                    <div class="stat-number text-primary">Loading...</div>
                    <div class="stat-label">Stats</div>
                </div>
            </div>
        
            <!-- Usage Meter -->
            <div class="row mb-4">
                <div class="col-12">
                    <div class="usage-meter">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <h6 class="mb-0">Usage This Month</h6>
                            <span class="text-muted" id="usage-text">Loading...</span>
                        </div>
                        <div class="progress" style="height: 10px;">
                            <div class="progress-bar" id="usage-progress" role="progressbar" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            </div>
        
            <!-- Roleplay Modules -->
            <div class="row">
                <div class="col-12">
                    <h3 class="mb-4">Training Modules</h3>
                </div>
            </div>
        
            <div class="row" id="roleplay-grid">
                <!-- Roleplay cards will be loaded here -->
                <div class="col-lg-6 col-xl-4 mb-4">
                    <div class="card">
                        <div class="card-body text-center">
                            <i class="fas fa-spinner fa-spin fa-2x mb-3 text-primary"></i>
                            <p class="text-muted">Loading roleplay modules...</p>
                        </div>
                    </div>
                </div>
            </div>
        
            <!-- Recent Sessions -->
            <div class="row mt-5">
                <div class="col-12">
                    <div class="dashboard-card">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h4>Recent Sessions</h4>
                            <a href="#" class="btn btn-outline-primary btn-sm">View All</a>
                        </div>
                        <div class="table-responsive">
                            <table class="table table-hover">
                                <thead>
                                    <tr>
                                        <th>Date</th>
                                        <th>Roleplay</th>
                                        <th>Mode</th>
                                        <th>Duration</th>
                                        <th>Result</th>
                                        <th>Score</th>
                                    </tr>
                                </thead>
                                <tbody id="recent-sessions">
                                    <tr>
                                        <td colspan="6" class="text-center text-muted">Loading...</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-lg-8">
                <div class="card bg-dark border-secondary">
                    <div class="card-header">
                        <h5 class="mb-0">
                            <i class="fas fa-chart-line me-2"></i>Your Training Progress
                        </h5>
                    </div>
                    <div class="card-body">
                        <!-- Progress Overview -->
                        <div class="row mb-4">
                            <div class="col-md-3">
                                <div class="text-center">
                                    <div class="display-6 text-success" id="completion-percentage">0%</div>
                                    <small class="text-muted">Completion Rate</small>
                                </div>
                            </div>
                            <div class="col-md-3">
                                <div class="text-center">
                                    <div class="display-6 text-info" id="average-score">--</div>
                                    <small class="text-muted">Average Score</small>
                                </div>
                            </div>
                            <div class="col-md-3">
                                <div class="text-center">
                                    <div class="display-6 text-warning" id="total-attempts">0</div>
                                    <small class="text-muted">Total Attempts</small>
                                </div>
                            </div>
                            <div class="col-md-3">
                                <div class="text-center">
                                    <div class="badge bg-primary fs-6" id="current-level">Beginner</div>
                                    <small class="text-muted d-block">Current Level</small>
                                </div>
                            </div>
                        </div>
        
                        <!-- Roleplay Progress Cards -->
                        <div class="row" id="roleplay-progress-cards">
                            <!-- Roleplay 1 -->
                            <div class="col-md-6 mb-3">
                                <div class="card bg-secondary">
                                    <div class="card-header d-flex justify-content-between align-items-center">
                                        <h6 class="mb-0">Roleplay 1: Opener & Objections</h6>
                                        <span class="badge bg-info" id="rp1-status">In Progress</span>
                                    </div>
                                    <div class="card-body">
                                        <div class="mb-2">
                                            <div class="d-flex justify-content-between">
                                                <span>Practice Mode (1.1)</span>
                                                <span class="text-success" id="rp1-1-score">Not attempted</span>
                                            </div>
                                            <div class="progress mb-1" style="height: 4px;">
                                                <div class="progress-bar bg-success" id="rp1-1-progress" style="width: 0%"></div>
                                            </div>
                                        </div>
                                        <div class="mb-2">
                                            <div class="d-flex justify-content-between">
                                                <span>Marathon Mode (1.2)</span>
                                                <span class="text-warning" id="rp1-2-score">Locked</span>
                                            </div>
                                            <div class="progress mb-1" style="height: 4px;">
                                                <div class="progress-bar bg-warning" id="rp1-2-progress" style="width: 0%"></div>
                                            </div>
                                        </div>
                                        <div class="mb-2">
                                            <div class="d-flex justify-content-between">
                                                <span>Legend Mode (1.3)</span>
                                                <span class="text-danger" id="rp1-3-score">Locked</span>
                                            </div>
                                            <div class="progress mb-1" style="height: 4px;">
                                                <div class="progress-bar bg-danger" id="rp1-3-progress" style="width: 0%"></div>
                                            </div>
                                        </div>
                                        <div class="mt-3">
                                            <a href="/roleplay/1" class="btn btn-primary btn-sm">
                                                <i class="fas fa-play me-1"></i>Continue Training
                                            </a>
                                        </div>
                                    </div>
                                </div>
                            </div>
        
                            <!-- Roleplay 2 -->
                            <div class="col-md-6 mb-3">
                                <div class="card bg-secondary">
                                    <div class="card-header d-flex justify-content-between align-items-center">
                                        <h6 class="mb-0">Roleplay 2: Pitch & Close</h6>
                                        <span class="badge bg-danger" id="rp2-status">Locked</span>
                                    </div>
                                    <div class="card-body">
                                        <div class="text-center text-muted">
                                            <i class="fas fa-lock fa-3x mb-2"></i>
                                            <p>Complete Roleplay 1 Legend Mode to unlock</p>
                                            <small>Master all objection handling first</small>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
        
                        <!-- Recommendations -->
                        <div class="mt-4" id="recommendations-section">
                            <h6>Recommended Next Steps:</h6>
                            <div id="recommendations-list">
                                <div class="alert alert-info">
                                    <i class="fas fa-lightbulb me-2"></i>
                                    Start with Practice Mode to learn the fundamentals!
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        
            <!-- Sidebar with Quick Actions -->
            <div class="col-lg-4">
                <div class="card bg-dark border-secondary">
                    <div class="card-header">
                        <h5 class="mb-0">
                            <i class="fas fa-trophy me-2"></i>Recent Achievements
                        </h5>
                    </div>
                    <div class="card-body" id="achievements-list">
                        <p class="text-muted">Complete your first roleplay to earn achievements!</p>
                    </div>
                </div>
        
                <div class="card bg-dark border-secondary mt-3">
                    <div class="card-header">
                        <h5 class="mb-0">
                            <i class="fas fa-chart-bar me-2"></i>Leaderboard
                        </h5>
                    </div>
                    <div class="card-body" id="leaderboard-section">
                        <p class="text-muted">Complete a roleplay to see your ranking!</p>
                    </div>
                </div>
            </div>
        </div>
        <div id="user-progress-data" style="display: none;">
            {{ user_progress | tojson if user_progress else '{}' }}
        </div>
        {% endblock %}
        
        {% block extra_js %}
        <script src="{{ url_for('static', filename='js/dashboard.js') }}"></script>
        {% endblock %}

  📄 index.html (8.2KB)
      Content:
        <!-- ===== TEMPLATES/INDEX.HTML ===== -->
        {% extends "base.html" %}
        
        {% block title %}Home - Cold Calling Coach{% endblock %}
        
        {% block content %}
        <!-- Hero Section -->
        <section class="hero-section bg-primary text-white py-5">
            <div class="container">
                <div class="row align-items-center min-vh-50">
                    <div class="col-lg-6">
                        <h1 class="display-4 fw-bold mb-4">Master Cold Calling with AI</h1>
                        <p class="lead mb-4">
                            Practice your cold calling skills with realistic AI-powered simulations. 
                            Perfect for non-native English speakers looking to excel in sales.
                        </p>
                        <div class="d-flex gap-3">
                            <a href="{{ url_for('register_page') }}" class="btn btn-light btn-lg">
                                <i class="fas fa-rocket me-2"></i>Start Free Trial
                            </a>
                            <a href="{{ url_for('about') }}" class="btn btn-outline-light btn-lg">
                                <i class="fas fa-info-circle me-2"></i>Learn More
                            </a>
                        </div>
                    </div>
                    <div class="col-lg-6 text-center">
                        <i class="fas fa-headset display-1 mb-4" style="font-size: 8rem; opacity: 0.8;"></i>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Features Section -->
        <section class="py-5">
            <div class="container">
                <div class="row text-center mb-5">
                    <div class="col-12">
                        <h2 class="display-5 fw-bold">Why Choose Our Platform?</h2>
                        <p class="lead text-muted">Advanced AI technology meets proven sales methodology</p>
                    </div>
                </div>
                
                <div class="row g-4">
                    <div class="col-md-4">
                        <div class="feature-card text-center p-4">
                            <div class="feature-icon mb-3">
                                <i class="fas fa-robot fa-3x text-primary"></i>
                            </div>
                            <h4>AI-Powered Prospects</h4>
                            <p class="text-muted">
                                Practice with realistic AI prospects that respond like real decision-makers
                            </p>
                        </div>
                    </div>
                    
                    <div class="col-md-4">
                        <div class="feature-card text-center p-4">
                            <div class="feature-icon mb-3">
                                <i class="fas fa-microphone fa-3x text-success"></i>
                            </div>
                            <h4>Voice Recognition</h4>
                            <p class="text-muted">
                                Real-time speech recognition and pronunciation feedback
                            </p>
                        </div>
                    </div>
                    
                    <div class="col-md-4">
                        <div class="feature-card text-center p-4">
                            <div class="feature-icon mb-3">
                                <i class="fas fa-chart-line fa-3x text-warning"></i>
                            </div>
                            <h4>Progress Tracking</h4>
                            <p class="text-muted">
                                Detailed analytics and performance insights to track your improvement
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Training Modules Preview -->
        <section class="py-5 bg-light">
            <div class="container">
                <div class="row text-center mb-5">
                    <div class="col-12">
                        <h2 class="display-5 fw-bold">5 Progressive Training Modules</h2>
                        <p class="lead text-muted">From basic openers to advanced sales conversations</p>
                    </div>
                </div>
                
                <div class="row g-4">
                    <div class="col-lg-6 col-xl-4">
                        <div class="training-card">
                            <div class="card-header bg-primary text-white">
                                <h5 class="mb-0"><i class="fas fa-play-circle me-2"></i>Module 1</h5>
                            </div>
                            <div class="card-body">
                                <h6>Opener + Early Objections</h6>
                                <p class="text-muted small">Master your cold call opener and handle early objections</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="col-lg-6 col-xl-4">
                        <div class="training-card">
                            <div class="card-header bg-success text-white">
                                <h5 class="mb-0"><i class="fas fa-bullseye me-2"></i>Module 2</h5>
                            </div>
                            <div class="card-body">
                                <h6>Pitch + Close</h6>
                                <p class="text-muted small">Deliver compelling pitches and close for meetings</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="col-lg-6 col-xl-4">
                        <div class="training-card">
                            <div class="card-header bg-warning text-white">
                                <h5 class="mb-0"><i class="fas fa-fire me-2"></i>Module 3</h5>
                            </div>
                            <div class="card-body">
                                <h6>Warm-up Challenge</h6>
                                <p class="text-muted small">25 rapid-fire questions covering all scenarios</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="col-lg-6 col-xl-4">
                        <div class="training-card">
                            <div class="card-header bg-info text-white">
                                <h5 class="mb-0"><i class="fas fa-phone-alt me-2"></i>Module 4</h5>
                            </div>
                            <div class="card-body">
                                <h6>Full Cold Call</h6>
                                <p class="text-muted small">Complete end-to-end cold call simulation</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="col-lg-6 col-xl-4">
                        <div class="training-card">
                            <div class="card-header bg-danger text-white">
                                <h5 class="mb-0"><i class="fas fa-bolt me-2"></i>Module 5</h5>
                            </div>
                            <div class="card-body">
                                <h6>Power Hour</h6>
                                <p class="text-muted small">10 consecutive full cold calls</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="col-lg-6 col-xl-4 d-flex align-items-center justify-content-center">
                        <div class="text-center">
                            <a href="{{ url_for('register_page') }}" class="btn btn-primary btn-lg">
                                <i class="fas fa-rocket me-2"></i>Start Training Now
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- CTA Section -->
        <section class="py-5 bg-primary text-white">
            <div class="container text-center">
                <h2 class="display-5 fw-bold mb-4">Ready to Transform Your Cold Calling?</h2>
                <p class="lead mb-4">Join thousands of sales professionals improving their skills</p>
                <a href="{{ url_for('register_page') }}" class="btn btn-light btn-lg">
                    <i class="fas fa-user-plus me-2"></i>Create Free Account
                </a>
            </div>
        </section>
        
        <style>
        .hero-section {
            background: linear-gradient(135deg, var(--bs-primary), #6610f2);
        }
        
        .min-vh-50 {
            min-height: 50vh;
        }
        
        .feature-card {
            background: white;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            transition: all 0.3s ease;
            height: 100%;
        }
        
        .feature-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }
        
        .training-card {
            background: white;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            transition: all 0.3s ease;
            height: 100%;
            overflow: hidden;
        }
        
        .training-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }
        
        .training-card .card-header {
            border: none;
            padding: 1rem;
        }
        
        .training-card .card-body {
            padding: 1.5rem;
        }
        </style>
        {% endblock %}

  📄 login.html (2.3KB)
      Content:
        <!-- 
        # ===== TEMPLATES/LOGIN.HTML ===== -->
        {% extends "base.html" %}
        
        {% block title %}Login - Cold Calling Coach{% endblock %}
        
        {% block extra_css %}
        <style>
        .login-container {
            max-width: 400px;
            margin: 3rem auto;
            padding: 2rem;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        
        .social-login {
            margin-bottom: 1.5rem;
        }
        
        .divider {
            text-align: center;
            margin: 1.5rem 0;
            position: relative;
        }
        
        .divider::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background: #dee2e6;
        }
        
        .divider span {
            background: white;
            padding: 0 1rem;
            color: #6c757d;
            font-size: 0.9rem;
        }
        </style>
        {% endblock %}
        
        {% block content %}
        <div class="container">
            <div class="login-container">
                <div class="text-center mb-4">
                    <h2><i class="fas fa-sign-in-alt me-2"></i>Welcome Back</h2>
                    <p class="text-muted">Sign in to continue your training</p>
                </div>
        
                <form id="login-form">
                    <div class="mb-3">
                        <label for="login-email" class="form-label">Email</label>
                        <input type="email" class="form-control" id="login-email" name="email" required>
                    </div>
        
                    <div class="mb-3">
                        <label for="login-password" class="form-label">Password</label>
                        <input type="password" class="form-control" id="login-password" name="password" required>
                    </div>
        
                    <div class="mb-3 form-check">
                        <input type="checkbox" class="form-check-input" id="remember-me">
                        <label class="form-check-label" for="remember-me">
                            Remember me
                        </label>
                    </div>
        
                    <div class="d-grid">
                        <button type="submit" class="btn btn-primary">
                            <i class="fas fa-sign-in-alt me-2"></i>Login
                        </button>
                    </div>
                </form>
        
                <div class="text-center mt-4">
                    <p><a href="#" class="text-decoration-none">Forgot your password?</a></p>
                    <p>Don't have an account? <a href="{{ url_for('register_page') }}">Register here</a></p>
                </div>
            </div>
        </div>
        {% endblock %}
        

  📄 pricing.html (5.3KB)
      Content:
        
        <!-- ===== TEMPLATES/PRICING.HTML ===== -->
        {% extends "base.html" %}
        
        {% block title %}Pricing - Cold Calling Coach{% endblock %}
        
        {% block content %}
        <div class="container py-5">
            <div class="text-center mb-5">
                <h1 class="display-4 fw-bold text-primary">Choose Your Plan</h1>
                <p class="lead text-muted">Start free, upgrade when you're ready</p>
            </div>
            
            <div class="row justify-content-center">
                <!-- Free Trial -->
                <div class="col-lg-4 mb-4">
                    <div class="pricing-card">
                        <div class="pricing-header bg-warning text-white">
                            <h4 class="fw-bold">Free Trial</h4>
                            <div class="price">
                                <span class="display-4 fw-bold">$0</span>
                                <span class="period">/7 days</span>
                            </div>
                        </div>
                        <div class="pricing-body">
                            <ul class="feature-list">
                                <li><i class="fas fa-check text-success me-2"></i>3 hours of practice</li>
                                <li><i class="fas fa-check text-success me-2"></i>Access to Module 1</li>
                                <li><i class="fas fa-check text-success me-2"></i>Basic progress tracking</li>
                                <li><i class="fas fa-check text-success me-2"></i>7 days access</li>
                            </ul>
                            <a href="{{ url_for('register_page') }}" class="btn btn-warning btn-lg w-100">
                                Start Free Trial
                            </a>
                        </div>
                    </div>
                </div>
                
                <!-- Basic Plan -->
                <div class="col-lg-4 mb-4">
                    <div class="pricing-card">
                        <div class="pricing-header bg-success text-white">
                            <h4 class="fw-bold">Basic Plan</h4>
                            <div class="price">
                                <span class="display-4 fw-bold">$29</span>
                                <span class="period">/month</span>
                            </div>
                        </div>
                        <div class="pricing-body">
                            <ul class="feature-list">
                                <li><i class="fas fa-check text-success me-2"></i>50 hours per month</li>
                                <li><i class="fas fa-check text-success me-2"></i>All 5 modules</li>
                                <li><i class="fas fa-check text-success me-2"></i>24-hour unlocks</li>
                                <li><i class="fas fa-check text-success me-2"></i>Detailed analytics</li>
                                <li><i class="fas fa-check text-success me-2"></i>Email support</li>
                            </ul>
                            <button class="btn btn-success btn-lg w-100" disabled>
                                Coming Soon
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Pro Plan -->
                <div class="col-lg-4 mb-4">
                    <div class="pricing-card featured">
                        <div class="pricing-header bg-primary text-white">
                            <div class="badge bg-warning text-dark position-absolute top-0 start-50 translate-middle">
                                Most Popular
                            </div>
                            <h4 class="fw-bold">Pro Plan</h4>
                            <div class="price">
                                <span class="display-4 fw-bold">$49</span>
                                <span class="period">/month</span>
                            </div>
                        </div>
                        <div class="pricing-body">
                            <ul class="feature-list">
                                <li><i class="fas fa-check text-success me-2"></i>50 hours per month</li>
                                <li><i class="fas fa-check text-success me-2"></i>All modules unlocked</li>
                                <li><i class="fas fa-check text-success me-2"></i>Permanent unlocks</li>
                                <li><i class="fas fa-check text-success me-2"></i>Advanced analytics</li>
                                <li><i class="fas fa-check text-success me-2"></i>Priority support</li>
                                <li><i class="fas fa-check text-success me-2"></i>Custom AI behavior</li>
                            </ul>
                            <button class="btn btn-primary btn-lg w-100" disabled>
                                Coming Soon
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="text-center mt-5">
                <h3 class="fw-bold mb-3">Questions?</h3>
                <p class="text-muted">Contact us at support@coldcallingcoach.com</p>
            </div>
        </div>
        
        <style>
        .pricing-card {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            overflow: hidden;
            transition: all 0.3s ease;
            height: 100%;
            position: relative;
        }
        
        .pricing-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.15);
        }
        
        .pricing-card.featured {
            border: 3px solid var(--bs-primary);
        }
        
        .pricing-header {
            padding: 2rem;
            text-align: center;
        }
        
        .price .period {
            font-size: 1rem;
            opacity: 0.8;
        }
        
        .pricing-body {
            padding: 2rem;
        }
        
        .feature-list {
            list-style: none;
            padding: 0;
            margin-bottom: 2rem;
        }
        
        .feature-list li {
            padding: 0.5rem 0;
            font-size: 0.95rem;
        }
        </style>
        {% endblock %}

  📄 register.html (12.2KB)
      Content:
        <!-- ===== TEMPLATES/REGISTER.HTML (FIXED) ===== -->
        {% extends "base.html" %}
        
        {% block title %}Register - Cold Calling Coach{% endblock %}
        
        {% block extra_css %}
        <style>
        .register-container {
            max-width: 600px;
            margin: 2rem auto;
            padding: 2rem;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        
        .step-indicator {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2rem;
        }
        
        .step {
            flex: 1;
            text-align: center;
            padding: 1rem;
            border-radius: 8px;
            background: #f8f9fa;
            margin: 0 0.5rem;
            transition: all 0.3s ease;
        }
        
        .step.active {
            background: var(--primary-color, #007bff);
            color: white;
        }
        
        .step.completed {
            background: var(--success-color, #28a745);
            color: white;
        }
        
        #verification-section {
            display: none;
        }
        
        .verification-code-input {
            font-size: 1.5rem;
            letter-spacing: 0.5rem;
            text-align: center;
            font-weight: bold;
        }
        
        .form-text {
            font-size: 0.875rem;
            color: #6c757d;
        }
        
        .loading-spinner {
            width: 1rem;
            height: 1rem;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        </style>
        {% endblock %}
        
        {% block content %}
        <div class="container">
            <div class="register-container">
                <div class="text-center mb-4">
                    <h2><i class="fas fa-user-plus me-2"></i>Create Your Account</h2>
                    <p class="text-muted">Start your journey to better cold calling</p>
                </div>
        
                <div class="step-indicator">
                    <div class="step active" id="step-1">
                        <i class="fas fa-user-circle"></i><br>
                        <small>Profile</small>
                    </div>
                    <div class="step" id="step-2">
                        <i class="fas fa-envelope"></i><br>
                        <small>Verify Email</small>
                    </div>
                    <div class="step" id="step-3">
                        <i class="fas fa-check-circle"></i><br>
                        <small>Complete</small>
                    </div>
                </div>
        
                <!-- Registration Form -->
                <div id="registration-section">
                    <form id="register-form">
                        <div class="row">
                            <div class="col-md-6 mb-3">
                                <label for="register-first-name" class="form-label">First Name *</label>
                                <input type="text" class="form-control" id="register-first-name" name="first_name" required>
                            </div>
                            <div class="col-md-6 mb-3">
                                <label for="register-email" class="form-label">Email *</label>
                                <input type="email" class="form-control" id="register-email" name="email" required>
                            </div>
                        </div>
        
                        <div class="mb-3">
                            <label for="register-password" class="form-label">Password *</label>
                            <input type="password" class="form-control" id="register-password" name="password" required minlength="6">
                            <div class="form-text">Minimum 6 characters</div>
                        </div>
        
                        <div class="row">
                            <div class="col-md-6 mb-3">
                                <label for="prospect-job-title" class="form-label">Prospect Job Title *</label>
                                <select class="form-select" id="prospect-job-title" name="prospect_job_title" required>
                                    <option value="">Select job title...</option>
                                    <option value="Brand/Communications Manager">Brand/Communications Manager</option>
                                    <option value="CEO (Chief Executive Officer)">CEO (Chief Executive Officer)</option>
                                    <option value="CFO (Chief Financial Officer)">CFO (Chief Financial Officer)</option>
                                    <option value="CIO (Chief Information Officer)">CIO (Chief Information Officer)</option>
                                    <option value="COO (Chief Operating Officer)">COO (Chief Operating Officer)</option>
                                    <option value="Content Marketing Manager">Content Marketing Manager</option>
                                    <option value="CTO (Chief Technology Officer)">CTO (Chief Technology Officer)</option>
                                    <option value="Demand Generation Manager">Demand Generation Manager</option>
                                    <option value="Digital Marketing Manager">Digital Marketing Manager</option>
                                    <option value="Engineering Manager">Engineering Manager</option>
                                    <option value="Finance Director">Finance Director</option>
                                    <option value="Founder / Owner / Managing Director (MD)">Founder / Owner / Managing Director (MD)</option>
                                    <option value="Head of Product">Head of Product</option>
                                    <option value="Purchasing Manager">Purchasing Manager</option>
                                    <option value="R&D/Product Development Manager">R&D/Product Development Manager</option>
                                    <option value="Sales Manager">Sales Manager</option>
                                    <option value="Sales Operations Manager">Sales Operations Manager</option>
                                    <option value="Social Media Manager">Social Media Manager</option>
                                    <option value="UX/UI Design Lead">UX/UI Design Lead</option>
                                    <option value="VP of Finance">VP of Finance</option>
                                    <option value="VP of HR">VP of HR</option>
                                    <option value="VP of IT/Engineering">VP of IT/Engineering</option>
                                    <option value="VP of Marketing">VP of Marketing</option>
                                    <option value="VP of Sales">VP of Sales</option>
                                    <option value="Other (Please specify)">Other (Please specify)</option>
                                </select>
                            </div>
                            <div class="col-md-6 mb-3">
                                <label for="prospect-industry" class="form-label">Prospect Industry *</label>
                                <select class="form-select" id="prospect-industry" name="prospect_industry" required>
                                    <option value="">Select industry...</option>
                                    <option value="Education & e-Learning">Education & e-Learning</option>
                                    <option value="Energy & Utilities">Energy & Utilities</option>
                                    <option value="Finance & Banking">Finance & Banking</option>
                                    <option value="Government & Public Sector">Government & Public Sector</option>
                                    <option value="Healthcare & Life Sciences">Healthcare & Life Sciences</option>
                                    <option value="Hospitality & Travel">Hospitality & Travel</option>
                                    <option value="Information Technology & Services">Information Technology & Services</option>
                                    <option value="Logistics, Transportation & Supply Chain">Logistics, Transportation & Supply Chain</option>
                                    <option value="Manufacturing & Industrial">Manufacturing & Industrial</option>
                                    <option value="Media & Entertainment">Media & Entertainment</option>
                                    <option value="Non-Profit & Associations">Non-Profit & Associations</option>
                                    <option value="Professional Services (Legal, Accounting, Consulting)">Professional Services (Legal, Accounting, Consulting)</option>
                                    <option value="Real Estate & Property Management">Real Estate & Property Management</option>
                                    <option value="Retail & e-Commerce">Retail & e-Commerce</option>
                                    <option value="Telecommunications">Telecommunications</option>
                                    <option value="Other (Please specify)">Other (Please specify)</option>
                                </select>
                            </div>
                        </div>
        
                        <div class="mb-3">
                            <label for="custom-ai-notes" class="form-label">Custom AI Notes (Optional)</label>
                            <textarea class="form-control" id="custom-ai-notes" name="custom_ai_notes" rows="3" 
                                placeholder="Any specific instructions for how the AI should behave during roleplays..."></textarea>
                            <div class="form-text">Help customize the AI's behavior to your specific needs</div>
                        </div>
        
                        <div class="d-grid gap-2">
                            <button type="button" class="btn btn-primary btn-lg" id="send-verification-btn">
                                <i class="fas fa-envelope me-2"></i>Send Verification Code
                            </button>
                        </div>
                    </form>
                </div>
        
                <!-- Email Verification Section -->
                <div id="verification-section">
                    <hr class="my-4">
                    <div class="text-center">
                        <h5><i class="fas fa-envelope-open-text me-2"></i>Verify Your Email</h5>
                        <p class="text-muted">We've sent a 6-digit code to your email address. Please enter it below:</p>
                    </div>
                    
                    <form id="verify-form">
                        <input type="hidden" id="verify-email" name="email">
                        <div class="row justify-content-center">
                            <div class="col-md-8">
                                <div class="mb-3">
                                    <label for="verification-code" class="form-label">Verification Code</label>
                                    <input type="text" class="form-control verification-code-input" id="verification-code" 
                                        name="code" placeholder="000000" maxlength="6" required 
                                        pattern="[0-9]{6}" title="Please enter a 6-digit code">
                                    <div class="form-text">Enter the 6-digit code from your email</div>
                                </div>
                                <div class="d-grid">
                                    <button type="submit" class="btn btn-success btn-lg">
                                        <i class="fas fa-check me-2"></i>Verify & Create Account
                                    </button>
                                </div>
                                <div class="text-center mt-3">
                                    <button type="button" class="btn btn-link" id="resend-code-btn">
                                        Didn't receive the code? Resend
                                    </button>
                                </div>
                            </div>
                        </div>
                    </form>
                </div>
        
                <div class="text-center mt-4">
                    <p>Already have an account? <a href="{{ url_for('login_page') }}" class="text-decoration-none">Login here</a></p>
                </div>
            </div>
        </div>
        
        <script>
        // Additional JavaScript for register page
        document.addEventListener('DOMContentLoaded', function() {
            // Format verification code input
            const codeInput = document.getElementById('verification-code');
            if (codeInput) {
                codeInput.addEventListener('input', function(e) {
                    // Only allow numbers
                    e.target.value = e.target.value.replace(/[^0-9]/g, '');
                    
                    // Auto-submit if 6 digits entered
                    if (e.target.value.length === 6) {
                        const form = document.getElementById('verify-form');
                        if (form) {
                            form.dispatchEvent(new Event('submit'));
                        }
                    }
                });
            }
        
            // Resend code functionality
            const resendBtn = document.getElementById('resend-code-btn');
            if (resendBtn) {
                resendBtn.addEventListener('click', function() {
                    if (window.coldCallingApp) {
                        window.coldCallingApp.sendVerificationCode();
                    }
                });
            }
        });
        </script>
        {% endblock %}

  📄 roleplay.html (6.8KB)
      Content:
        <!-- ===== FIXED: templates/roleplay.html ===== -->
        {% extends "base.html" %}
        
        {% block title %}{{ roleplay_info.name if roleplay_info else 'Roleplay Training' }} - Cold Calling Coach{% endblock %}
        
        {% block extra_css %}
        <link rel="stylesheet" href="{{ url_for('static', filename='css/roleplay.css') }}">
        <style>
            /* Add this style to ensure the phone container is initially hidden */
            #phone-container {
                display: none; 
            }
        </style>
        {% endblock %}
        
        {% block content %}
        <div class="training-container">
            <!-- Back to Dashboard Link -->
            <a href="/dashboard" class="back-to-dashboard">
                <i class="fas fa-arrow-left me-2"></i>Dashboard
            </a>
        
            <!-- Mode Selection Screen (Now outside the phone) -->
            <div class="mode-selection" id="mode-selection" style="position: static; max-width: 800px; background: none;">
                <h3 id="roleplay-title">Choose Training Mode</h3>
                <div class="roleplay-version" id="roleplay-version">Loading...</div>
                <div class="mode-grid" id="mode-grid">
                    <!-- Mode options will be populated by JavaScript -->
                    <div class="text-center text-white py-5">
                        <div class="spinner-border" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <p class="mt-2">Loading Modes...</p>
                    </div>
                </div>
                <button class="start-call-btn" id="start-call-btn" disabled>
                    Select a mode to start
                </button>
            </div>
        
            <!-- Phone Interface Container (Initially hidden) -->
            <div class="phone-container" id="phone-container">
                <div class="phone-screen">
                    <!-- Status Bar -->
                    <div class="status-bar" id="status-bar">
                        <div class="time" id="current-time">9:41</div>
                        <div class="status-icons">
                            <i class="fas fa-signal"></i>
                            <i class="fas fa-wifi"></i>
                            <i class="fas fa-battery-three-quarters"></i>
                        </div>
                    </div>
        
                    <!-- Conversation Quality Indicator -->
                    <div class="conversation-quality" id="conversation-quality" style="display: none;">50%</div>
        
                    <!-- Marathon Progress -->
                    <div class="marathon-progress" id="marathon-progress" style="display: none;">
                        <!-- Marathon stats will be populated here -->
                    </div>
        
                    <!-- Call Interface -->
                    <div class="call-interface" id="call-interface" style="display: none;">
                        <div class="call-status">
                            <img src="" alt="Contact" class="contact-avatar" id="contact-avatar">
                            <div class="contact-name" id="contact-name">...</div>
                            <div class="contact-info" id="contact-info">...</div>
                            <div class="call-status-text" id="call-status-text">...</div>
                            <div class="call-duration" id="call-duration">00:00</div>
                        </div>
                        <div class="live-transcript" id="live-transcript">...</div>
                        <div style="margin-top: auto;">
                            <div class="end-call-container">
                                <button class="end-call-btn" id="end-call-btn" title="End call"><i class="fas fa-phone"></i></button>
                            </div>
                        </div>
                    </div>
        
                    <!-- Feedback Section -->
                    <div class="feedback-section" id="feedback-section" style="display: none;">
                         <div class="feedback-header">
                            <div class="roleplay-badge" id="roleplay-badge">Roleplay</div>
                            <div class="score-circle" id="score-circle">0</div>
                            <h4 style="color: white; margin: 0;">Training Complete!</h4>
                         </div>
                         <div id="feedback-content" style="overflow-y: auto; flex: 1;"></div>
                         <div class="feedback-actions">
                             <button class="feedback-btn" id="try-again-btn"><i class="fas fa-redo me-2"></i>Try Again</button>
                             <button class="feedback-btn primary" id="new-mode-btn"><i class="fas fa-arrow-left me-2"></i>Change Roleplay</button>
                         </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="roleplay-data" 
             data-roleplay-id="{{ roleplay_id if roleplay_id else '1.1' }}"
             data-user-authenticated="{{ 'true' if session.get('user_id') else 'false' }}"
             style="display: none;">
        </div>
        
        <div id="voice-error" class="alert alert-warning position-fixed" style="display: none;"></div>
        {% endblock %}
        
        {% block extra_js %}
        <!-- CORRECTED PATH for voice-handler.js -->
        <script src="{{ url_for('static', filename='js/voice-handler.js') }}?v={{ get_file_version('js/voice-handler.js') }}"></script>
        <script src="{{ url_for('static', filename='js/roleplay/base-roleplay-manager.js') }}?v={{ get_file_version('js/roleplay/base-roleplay-manager.js') }}"></script>
        <script src="{{ url_for('static', filename='js/roleplay/roleplay-1-1-manager.js') }}?v={{ get_file_version('js/roleplay/roleplay-1-1-manager.js') }}"></script>
        <script src="{{ url_for('static', filename='js/roleplay/roleplay-1-2-manager.js') }}?v={{ get_file_version('js/roleplay/roleplay-1-2-manager.js') }}"></script>
        <script src="{{ url_for('static', filename='js/roleplay/roleplay-factory.js') }}?v={{ get_file_version('js/roleplay/roleplay-factory.js') }}"></script>
        <script>
            // Factory-based initialization
            document.addEventListener('DOMContentLoaded', () => {
                try {
                    const roleplayId = document.getElementById('roleplay-data').dataset.roleplayId;
                    console.log(`Initializing manager for roleplay ID: ${roleplayId}`);
                    
                    // This global instance `currentRoleplayManager` will be used by the page
                    window.currentRoleplayManager = RoleplayFactory.createManager(roleplayId);
                    
                    console.log('âœ… Roleplay successfully initialized via factory.');
                } catch (error) {
                    console.error('ðŸš¨ CRITICAL ERROR: Roleplay initialization failed.', error);
                    const container = document.querySelector('.training-container');
                    if (container) {
                        container.innerHTML = `
                            <div class="text-center text-white">
                                <h2>Initialization Failed</h2>
                                <p>Could not load the roleplay module. Please try again or go back to the dashboard.</p>
                                <p class="text-danger small">Error: ${error.message}</p>
                                <a href="/dashboard" class="btn btn-light mt-3">Back to Dashboard</a>
                            </div>
                        `;
                    }
                }
            });
        </script>
        {% endblock %}

  📄 verify-email.html (0KB)
      (Empty file)

  📁 components/
    📄 footer.html (0KB)
        (Empty file)

    📄 navbar.html (0KB)
        (Empty file)

  📁 roleplay/
    📄 base-roleplay.html (9.6KB)
        Content:
          <!-- ===== FIXED templates/roleplay/base-roleplay.html ===== -->
          
          {% extends "base.html" %}
          
          {% block title %}{{ roleplay_info.name if roleplay_info else 'Roleplay Training' }} - Cold Calling Coach{% endblock %}
          
          {% block extra_css %}
          <link rel="stylesheet" href="{{ url_for('static', filename='css/roleplay.css') }}">
          <style>
          /* Roleplay-specific styles */
          .roleplay-selector {
              padding: 20px;
              text-align: center;
          }
          
          .roleplay-grid {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
              gap: 20px;
              margin: 20px 0;
          }
          
          .roleplay-card {
              background: white;
              border-radius: 12px;
              padding: 24px;
              box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
              cursor: pointer;
              transition: all 0.3s ease;
              border: 2px solid transparent;
          }
          
          .roleplay-card:hover {
              transform: translateY(-2px);
              box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
          }
          
          .roleplay-card.selected {
              border-color: #3b82f6;
              background: #eff6ff;
          }
          
          .roleplay-card .icon {
              font-size: 3rem;
              margin-bottom: 16px;
          }
          
          .roleplay-card h3 {
              margin: 16px 0 8px 0;
              color: #1f2937;
          }
          
          .roleplay-card p {
              color: #6b7280;
              margin: 0;
          }
          
          .roleplay-features {
              list-style: none;
              padding: 0;
              margin: 16px 0 0 0;
          }
          
          .roleplay-features li {
              padding: 4px 0;
              color: #059669;
              font-size: 14px;
          }
          
          .roleplay-features li:before {
              content: "âœ“ ";
              font-weight: bold;
          }
          
          .marathon-progress {
              background: #f3f4f6;
              border-radius: 8px;
              padding: 16px;
              margin: 16px 0;
              display: none;
          }
          
          .marathon-progress.show {
              display: block;
          }
          
          .marathon-stats {
              display: flex;
              justify-content: space-between;
              align-items: center;
              flex-wrap: wrap;
              gap: 8px;
          }
          
          .marathon-stats span {
              background: white;
              padding: 8px 12px;
              border-radius: 6px;
              font-weight: 500;
              font-size: 14px;
          }
          
          .conversation-quality {
              position: absolute;
              top: 10px;
              right: 10px;
              background: rgba(0, 0, 0, 0.7);
              color: white;
              padding: 4px 8px;
              border-radius: 4px;
              font-size: 12px;
              font-weight: bold;
          }
          
          .conversation-quality.good { background: rgba(34, 197, 94, 0.9); }
          .conversation-quality.fair { background: rgba(234, 179, 8, 0.9); }
          .conversation-quality.poor { background: rgba(239, 68, 68, 0.9); }
          
          @media (max-width: 768px) {
              .roleplay-grid {
                  grid-template-columns: 1fr;
              }
              
              .marathon-stats {
                  flex-direction: column;
                  align-items: stretch;
              }
              
              .marathon-stats span {
                  text-align: center;
              }
          }
          </style>
          {% endblock %}
          
          {% block content %}
          <div class="training-container">
              <!-- Back to Dashboard -->
              <a href="/dashboard" class="back-to-dashboard">
                  <i class="fas fa-arrow-left me-2"></i>Dashboard
              </a>
          
              <!-- Roleplay Selector -->
              <div class="roleplay-selector" id="roleplay-selector">
                  <h2>Choose Your Training Type</h2>
                  <p>Select the roleplay type that matches your current skill level and goals.</p>
                  
                  <div class="roleplay-grid" id="roleplay-grid">
                      <!-- Roleplay cards will be populated by JavaScript -->
                  </div>
                  
                  <button class="btn btn-primary btn-lg" id="start-selected-roleplay" disabled>
                      <i class="fas fa-play me-2"></i>Start Training
                  </button>
              </div>
          
              <!-- Phone Interface Container -->
              <div class="phone-container" id="phone-container" style="display: none;">
                  <div class="phone-screen">
                      <!-- Status Bar -->
                      <div class="status-bar" id="status-bar">
                          <div class="time" id="current-time">9:41</div>
                          <div class="status-icons">
                              <i class="fas fa-signal"></i>
                              <i class="fas fa-wifi"></i>
                              <i class="fas fa-battery-three-quarters"></i>
                          </div>
                      </div>
          
                      <!-- Conversation Quality Indicator (for Practice Mode) -->
                      <div class="conversation-quality" id="conversation-quality" style="display: none;">
                          50%
                      </div>
          
                      <!-- Marathon Progress (for Marathon Mode) -->
                      <div class="marathon-progress" id="marathon-progress">
                          <div class="marathon-stats">
                              <span>Call 1/10</span>
                              <span>Passed: 0</span>
                              <span>Failed: 0</span>
                              <span>Need: 6</span>
                          </div>
                      </div>
          
                      <!-- Mode Selection Screen -->
                      <div class="mode-selection" id="mode-selection">
                          <h3 id="roleplay-title">Choose Training Mode</h3>
                          <div class="roleplay-version" id="roleplay-version">Loading...</div>
                          <div class="mode-grid" id="mode-grid">
                              <!-- Mode options will be populated by JavaScript -->
                          </div>
                          <button class="start-call-btn" id="start-call-btn" disabled>
                              Select a mode to start
                          </button>
                      </div>
          
                      <!-- Call Interface -->
                      <div class="call-interface" id="call-interface" style="display: none;">
                          <!-- Call Status -->
                          <div class="call-status">
                              <img src="https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=150&h=150&fit=crop&crop=face" 
                                   alt="Contact" class="contact-avatar" id="contact-avatar">
                              <div class="contact-name" id="contact-name">Alex Morgan</div>
                              <div class="contact-info" id="contact-info">CTO â€¢ TechCorp</div>
                              <div class="call-status-text" id="call-status-text">Calling...</div>
                              <div class="call-duration" id="call-duration">00:00</div>
                          </div>
          
                          <!-- Live Transcript -->
                          <div class="live-transcript" id="live-transcript">
                              Waiting for conversation...
                          </div>
          
                          <!-- Call Controls -->
                          <div style="margin-top: auto;">
                              <div class="call-controls">
                                  <button class="control-btn mute" id="mute-btn" title="Mute">
                                      <i class="fas fa-microphone"></i>
                                  </button>
                                  <button class="control-btn mic" id="mic-btn" title="Voice recognition">
                                      <i class="fas fa-microphone"></i>
                                  </button>
                                  <button class="control-btn speaker" id="speaker-btn" title="Speaker">
                                      <i class="fas fa-volume-up"></i>
                                  </button>
                              </div>
                              
                              <div class="end-call-container">
                                  <button class="end-call-btn" id="end-call-btn" title="End call">
                                      <i class="fas fa-phone"></i>
                                  </button>
                              </div>
                          </div>
                      </div>
          
                      <!-- Feedback Section -->
                      <div class="feedback-section" id="feedback-section">
                          <div class="feedback-header">
                              <div class="roleplay-badge" id="roleplay-badge">Roleplay</div>
                              <div class="score-circle" id="score-circle">85</div>
                              <h4 style="color: white; margin: 0;">Training Complete!</h4>
                              <p style="color: rgba(255,255,255,0.7); margin: 10px 0;">Here's your coaching feedback</p>
                          </div>
                          
                          <div id="feedback-content">
                              <!-- Feedback will be populated here -->
                          </div>
                          
                          <div class="feedback-actions">
                              <button class="feedback-btn" id="try-again-btn">
                                  <i class="fas fa-redo me-2"></i>Try Again
                              </button>
                              <button class="feedback-btn primary" id="new-mode-btn">
                                  <i class="fas fa-phone me-2"></i>New Training
                              </button>
                          </div>
                      </div>
                  </div>
              </div>
          </div>
          
          <!-- FIXED: Hidden Data with proper attributes -->
          <div id="roleplay-data" 
               data-roleplay-id="{{ roleplay_id if roleplay_id else '1.1' }}"
               data-user-authenticated="{{ 'true' if session.get('user_id') else 'false' }}"
               style="display: none;">
          </div>
          
          <!-- Voice Error Display -->
          <div id="voice-error" class="alert alert-warning position-fixed" 
               style="top: 20px; right: 20px; z-index: 9999; max-width: 300px; display: none;">
              <span id="voice-error-text"></span>
          </div>
          {% endblock %}
          {% block extra_js %}
          <!-- CORRECTED THE PATH in the line below -->
          <script src="{{ url_for('static', filename='js/voice-handler.js') }}?v={{ get_file_version('js/voice-handler.js') }}"></script>
          <script src="{{ url_for('static', filename='js/roleplay/base-roleplay-manager.js') }}?v={{ get_file_version('js/roleplay/base-roleplay-manager.js') }}"></script>
          <script src="{{ url_for('static', filename='js/roleplay/roleplay-1-1-manager.js') }}?v={{ get_file_version('js/roleplay/roleplay-1-1-manager.js') }}"></script>
          <script src="{{ url_for('static', filename='js/roleplay/roleplay-1-2-manager.js') }}?v={{ get_file_version('js/roleplay/roleplay-1-2-manager.js') }}"></script>
          <script src="{{ url_for('static', filename='js/roleplay/roleplay-factory.js') }}?v={{ get_file_version('js/roleplay/roleplay-factory.js') }}"></script>
          {% endblock %}

    📄 roleplay-1-selection.html (12.9KB)
        Content:
          <!-- ===== templates/roleplay/roleplay-1-selection.html ===== -->
          {% extends "base.html" %}
          
          {% block title %}Roleplay 1: Opener & Early Objections - Cold Calling Coach{% endblock %}
          
          {% block extra_css %}
          <link rel="stylesheet" href="{{ url_for('static', filename='css/roleplay.css') }}">
          <style>
          .selection-container {
              min-height: 100vh;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              display: flex;
              flex-direction: column;
              align-items: center;
              padding: 40px 20px;
          }
          
          .back-to-dashboard {
              position: absolute;
              top: 20px;
              left: 20px;
              color: rgba(255, 255, 255, 0.8);
              text-decoration: none;
              font-size: 16px;
              display: flex;
              align-items: center;
              transition: color 0.3s ease;
          }
          
          .back-to-dashboard:hover {
              color: white;
              text-decoration: none;
          }
          
          .selection-card {
              background: linear-gradient(135deg, #1e3c72, #2a5298);
              border-radius: 25px;
              padding: 40px;
              box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
              max-width: 800px;
              width: 100%;
              border: 3px solid rgba(255, 255, 255, 0.1);
              text-align: center;
          }
          
          .roleplay-header {
              margin-bottom: 40px;
          }
          
          .roleplay-title {
              color: white;
              font-size: 32px;
              font-weight: 700;
              margin-bottom: 10px;
          }
          
          .roleplay-description {
              color: rgba(255, 255, 255, 0.8);
              font-size: 18px;
              margin-bottom: 30px;
          }
          
          .modes-grid {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
              gap: 20px;
              margin-bottom: 30px;
          }
          
          .mode-card {
              background: rgba(255, 255, 255, 0.1);
              border: 2px solid transparent;
              border-radius: 16px;
              padding: 30px 20px;
              text-align: center;
              cursor: pointer;
              transition: all 0.3s ease;
              backdrop-filter: blur(10px);
              position: relative;
          }
          
          .mode-card:hover:not(.disabled) {
              background: rgba(255, 255, 255, 0.2);
              border-color: #60a5fa;
              transform: translateY(-5px);
              box-shadow: 0 10px 30px rgba(96, 165, 250, 0.3);
          }
          
          .mode-card.disabled {
              opacity: 0.5;
              cursor: not-allowed;
              background: rgba(255, 255, 255, 0.05);
          }
          
          .mode-card.completed {
              border-color: #10b981;
              background: rgba(16, 185, 129, 0.2);
          }
          
          .mode-icon {
              font-size: 48px;
              margin-bottom: 20px;
              color: #60a5fa;
          }
          
          .mode-card.completed .mode-icon {
              color: #10b981;
          }
          
          .mode-card.disabled .mode-icon {
              color: rgba(255, 255, 255, 0.3);
          }
          
          .mode-name {
              color: white;
              font-size: 22px;
              font-weight: 600;
              margin-bottom: 10px;
          }
          
          .mode-description {
              color: rgba(255, 255, 255, 0.8);
              font-size: 14px;
              line-height: 1.4;
              margin-bottom: 15px;
          }
          
          .mode-requirements {
              font-size: 12px;
              color: rgba(255, 255, 255, 0.6);
              font-style: italic;
          }
          
          .mode-status {
              position: absolute;
              top: 15px;
              right: 15px;
              padding: 4px 8px;
              border-radius: 12px;
              font-size: 10px;
              font-weight: 600;
              text-transform: uppercase;
          }
          
          .status-available {
              background: rgba(16, 185, 129, 0.8);
              color: white;
          }
          
          .status-locked {
              background: rgba(239, 68, 68, 0.8);
              color: white;
          }
          
          .status-completed {
              background: rgba(16, 185, 129, 0.8);
              color: white;
          }
          
          .progress-info {
              background: rgba(255, 255, 255, 0.1);
              border-radius: 12px;
              padding: 20px;
              margin-top: 20px;
              text-align: left;
          }
          
          .progress-title {
              color: white;
              font-size: 16px;
              font-weight: 600;
              margin-bottom: 10px;
          }
          
          .progress-item {
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 8px;
              font-size: 14px;
              color: rgba(255, 255, 255, 0.8);
          }
          
          .progress-status {
              font-weight: 600;
          }
          
          .status-pass {
              color: #10b981;
          }
          
          .status-fail {
              color: #ef4444;
          }
          
          .status-pending {
              color: #f59e0b;
          }
          
          @media (max-width: 768px) {
              .modes-grid {
                  grid-template-columns: 1fr;
              }
              
              .selection-card {
                  padding: 30px 20px;
              }
              
              .roleplay-title {
                  font-size: 24px;
              }
          }
          </style>
          {% endblock %}
          
          {% block content %}
          <div class="selection-container">
              <!-- Back to Dashboard -->
              <a href="/dashboard" class="back-to-dashboard">
                  <i class="fas fa-arrow-left me-2"></i>Dashboard
              </a>
          
              <!-- Selection Card -->
              <div class="selection-card">
                  <!-- Header -->
                  <div class="roleplay-header">
                      <h1 class="roleplay-title">Roleplay 1: Opener & Early Objections</h1>
                      <p class="roleplay-description">
                          Master your cold call openers and handle early objections with confidence. 
                          Choose your training mode below.
                      </p>
                  </div>
          
                  <!-- Modes Grid -->
                  <div class="modes-grid">
                      <!-- Practice Mode (1.1) -->
                      <div class="mode-card" id="mode-1-1" data-mode="1.1" onclick="selectMode('1.1')">
                          <div class="mode-status status-available">Available</div>
                          <div class="mode-icon">
                              <i class="fas fa-user-graduate"></i>
                          </div>
                          <h3 class="mode-name">Practice Mode</h3>
                          <p class="mode-description">
                              Single call with detailed AI coaching and feedback. 
                              Perfect for learning the fundamentals.
                          </p>
                          <div class="mode-requirements">
                              Always available â€¢ Detailed feedback
                          </div>
                      </div>
          
                      <!-- Marathon Mode (1.2) -->
                      <div class="mode-card" id="mode-1-2" data-mode="1.2" onclick="selectMode('1.2')">
                          <div class="mode-status status-available">Available</div>
                          <div class="mode-icon">
                              <i class="fas fa-running"></i>
                          </div>
                          <h3 class="mode-name">Marathon Mode</h3>
                          <p class="mode-description">
                              10 calls in a row. Pass 6 out of 10 to unlock Legend Mode. 
                              Tests your consistency.
                          </p>
                          <div class="mode-requirements">
                              Need 6/10 passes â€¢ No in-call feedback
                          </div>
                      </div>
          
                      <!-- Legend Mode (1.3) -->
                      <div class="mode-card disabled" id="mode-1-3" data-mode="1.3">
                          <div class="mode-status status-locked">Locked</div>
                          <div class="mode-icon">
                              <i class="fas fa-crown"></i>
                          </div>
                          <h3 class="mode-name">Legend Mode</h3>
                          <p class="mode-description">
                              6 perfect calls in a row. Ultimate test of mastery. 
                              Unlocks Roleplay 2.
                          </p>
                          <div class="mode-requirements">
                              Requires Marathon completion â€¢ No second chances
                          </div>
                      </div>
                  </div>
          
                  <!-- Progress Info -->
                  <div class="progress-info">
                      <div class="progress-title">
                          <i class="fas fa-chart-line me-2"></i>Your Progress
                      </div>
                      <div class="progress-item">
                          <span>Practice Mode Best Score:</span>
                          <span class="progress-status status-pending" id="practice-score">Not attempted</span>
                      </div>
                      <div class="progress-item">
                          <span>Marathon Mode Status:</span>
                          <span class="progress-status status-pending" id="marathon-status">Not attempted</span>
                      </div>
                      <div class="progress-item">
                          <span>Legend Mode Status:</span>
                          <span class="progress-status status-pending" id="legend-status">Locked</span>
                      </div>
                      <div class="progress-item">
                          <span>Roleplay 2 Access:</span>
                          <span class="progress-status status-pending" id="roleplay2-status">Complete Legend to unlock</span>
                      </div>
                  </div>
              </div>
          </div>
          
          <!-- Hidden Data -->
          <div id="user-progress" style="display: none;">
              {{ user_progress | tojson if user_progress else '{}' }}
          </div>
          {% endblock %}
          
          {% block extra_js %}
          <script>
          console.log('ðŸŽ® Roleplay 1 Selection Page Loaded');
          
          let userProgress = {};
          
          // Initialize page
          document.addEventListener('DOMContentLoaded', async () => {
              await loadUserProgress();
              updateUIBasedOnProgress();
          });
          
          async function loadUserProgress() {
              try {
                  // Get user progress from hidden element
                  const progressElement = document.getElementById('user-progress');
                  if (progressElement && progressElement.textContent.trim()) {
                      userProgress = JSON.parse(progressElement.textContent);
                  }
                  
                  // Also fetch latest progress from API
                  const response = await fetch('/api/user/roleplay-progress');
                  if (response.ok) {
                      const data = await response.json();
                      userProgress = data.progress || {};
                  }
                  
                  console.log('ðŸ“Š User progress loaded:', userProgress);
              } catch (error) {
                  console.error('âŒ Failed to load user progress:', error);
                  userProgress = {};
              }
          }
          
          function updateUIBasedOnProgress() {
              // Update Practice Mode (1.1)
              const practiceScore = userProgress['1.1']?.best_score || 0;
              const practiceElement = document.getElementById('practice-score');
              if (practiceScore > 0) {
                  practiceElement.textContent = `${practiceScore}/100`;
                  practiceElement.className = practiceScore >= 70 ? 'progress-status status-pass' : 'progress-status status-fail';
              }
          
              // Update Marathon Mode (1.2)
              const marathonData = userProgress['1.2'];
              const marathonElement = document.getElementById('marathon-status');
              if (marathonData) {
                  const passed = marathonData.calls_passed || 0;
                  const total = marathonData.total_calls || 10;
                  marathonElement.textContent = `${passed}/${total} passed`;
                  marathonElement.className = marathonData.completed ? 'progress-status status-pass' : 'progress-status status-fail';
              }
          
              // Update Legend Mode (1.3) availability
              const marathonCompleted = userProgress['1.2']?.completed && userProgress['1.2']?.passed;
              const legendCard = document.getElementById('mode-1-3');
              const legendStatus = document.getElementById('legend-status');
              
              if (marathonCompleted) {
                  legendCard.classList.remove('disabled');
                  legendCard.setAttribute('onclick', "selectMode('1.3')");
                  legendCard.querySelector('.mode-status').textContent = 'Available';
                  legendCard.querySelector('.mode-status').className = 'mode-status status-available';
                  legendStatus.textContent = 'Available';
                  legendStatus.className = 'progress-status status-available';
              }
          
              // Check if Legend is completed
              const legendCompleted = userProgress['1.3']?.completed;
              const roleplay2Status = document.getElementById('roleplay2-status');
              if (legendCompleted) {
                  legendCard.classList.add('completed');
                  legendStatus.textContent = 'Completed';
                  legendStatus.className = 'progress-status status-pass';
                  roleplay2Status.textContent = 'Unlocked!';
                  roleplay2Status.className = 'progress-status status-pass';
              }
          }
          
          function selectMode(modeId) {
              const modeCard = document.getElementById(`mode-${modeId.replace('.', '-')}`);
              
              // Check if mode is disabled
              if (modeCard.classList.contains('disabled')) {
                  alert('This mode is locked. Complete Marathon Mode first to unlock Legend Mode.');
                  return;
              }
              
              // Check specific requirements
              if (modeId === '1.3') {
                  const marathonCompleted = userProgress['1.2']?.completed && userProgress['1.2']?.passed;
                  if (!marathonCompleted) {
                      alert('Legend Mode requires completing Marathon Mode first. Pass 6 out of 10 calls in Marathon Mode to unlock.');
                      return;
                  }
              }
              
              console.log(`ðŸŽ¯ Selected mode: ${modeId}`);
              
              // Add visual feedback
              document.querySelectorAll('.mode-card').forEach(card => {
                  card.style.transform = 'scale(1)';
                  card.style.opacity = '1';
              });
              
              modeCard.style.transform = 'scale(0.95)';
              modeCard.style.opacity = '0.8';
              
              // Navigate to roleplay
              setTimeout(() => {
                  window.location.href = `/roleplay/${modeId}`;
              }, 200);
          }
          
          // Add hover effects
          document.querySelectorAll('.mode-card:not(.disabled)').forEach(card => {
              card.addEventListener('mouseenter', () => {
                  card.style.transform = 'translateY(-5px) scale(1.02)';
              });
              
              card.addEventListener('mouseleave', () => {
                  card.style.transform = 'translateY(0) scale(1)';
              });
          });
          
          console.log('âœ… Roleplay selection page initialized');
          </script>
          {% endblock %}

    📄 roleplay-selection.html (11KB)
        Content:
          <!-- ===== templates/roleplay/roleplay-selection.html ===== -->
          
          {% extends "base.html" %}
          
          {% block title %}{{ roleplay_info.name }} - Choose Mode - Cold Calling Coach{% endblock %}
          
          {% block extra_css %}
          <style>
          .selection-container {
              max-width: 1200px;
              margin: 2rem auto;
              padding: 0 1rem;
          }
          
          .back-link {
              color: #6c757d;
              text-decoration: none;
              margin-bottom: 2rem;
              display: inline-flex;
              align-items: center;
              font-size: 0.9rem;
          }
          
          .back-link:hover {
              color: #495057;
          }
          
          .roleplay-header {
              text-align: center;
              margin-bottom: 3rem;
          }
          
          .roleplay-header h1 {
              color: #2c3e50;
              margin-bottom: 0.5rem;
          }
          
          .roleplay-header p {
              color: #6c757d;
              font-size: 1.1rem;
          }
          
          .modes-grid {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
              gap: 2rem;
              margin-bottom: 3rem;
          }
          
          .mode-card {
              background: white;
              border-radius: 16px;
              padding: 2rem;
              box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
              cursor: pointer;
              transition: all 0.3s ease;
              border: 3px solid transparent;
              position: relative;
              overflow: hidden;
          }
          
          .mode-card:hover {
              transform: translateY(-4px);
              box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
          }
          
          .mode-card.practice-mode {
              border-color: #28a745;
          }
          
          .mode-card.marathon-mode {
              border-color: #ffc107;
          }
          
          .mode-card.legend-mode {
              border-color: #dc3545;
          }
          
          .mode-card::before {
              content: '';
              position: absolute;
              top: 0;
              left: 0;
              right: 0;
              height: 4px;
              background: linear-gradient(90deg, #28a745, #20c997);
          }
          
          .mode-card.marathon-mode::before {
              background: linear-gradient(90deg, #ffc107, #fd7e14);
          }
          
          .mode-card.legend-mode::before {
              background: linear-gradient(90deg, #dc3545, #e83e8c);
          }
          
          .mode-icon {
              font-size: 3rem;
              margin-bottom: 1rem;
              text-align: center;
          }
          
          .mode-icon.practice { color: #28a745; }
          .mode-icon.marathon { color: #ffc107; }
          .mode-icon.legend { color: #dc3545; }
          
          .mode-title {
              font-size: 1.5rem;
              font-weight: bold;
              margin-bottom: 0.5rem;
              color: #2c3e50;
              text-align: center;
          }
          
          .mode-description {
              color: #6c757d;
              margin-bottom: 1.5rem;
              text-align: center;
              line-height: 1.6;
          }
          
          .mode-features {
              list-style: none;
              padding: 0;
              margin-bottom: 1.5rem;
          }
          
          .mode-features li {
              padding: 0.25rem 0;
              color: #495057;
              font-size: 0.9rem;
              display: flex;
              align-items: center;
          }
          
          .mode-features li::before {
              content: "âœ“";
              color: #28a745;
              font-weight: bold;
              margin-right: 0.5rem;
          }
          
          .mode-button {
              width: 100%;
              padding: 0.75rem 1.5rem;
              border: none;
              border-radius: 8px;
              font-weight: 600;
              text-decoration: none;
              text-align: center;
              transition: all 0.3s ease;
              display: block;
          }
          
          .mode-button.practice {
              background: #28a745;
              color: white;
          }
          
          .mode-button.practice:hover {
              background: #218838;
              color: white;
          }
          
          .mode-button.marathon {
              background: #ffc107;
              color: #212529;
          }
          
          .mode-button.marathon:hover {
              background: #e0a800;
              color: #212529;
          }
          
          .mode-button.legend {
              background: #dc3545;
              color: white;
          }
          
          .mode-button.legend:hover {
              background: #c82333;
              color: white;
          }
          
          .unlock-badge {
              position: absolute;
              top: 1rem;
              right: 1rem;
              padding: 0.25rem 0.75rem;
              border-radius: 20px;
              font-size: 0.75rem;
              font-weight: 600;
          }
          
          .unlock-badge.unlocked {
              background: #d4edda;
              color: #155724;
              border: 1px solid #c3e6cb;
          }
          
          .unlock-badge.locked {
              background: #f8d7da;
              color: #721c24;
              border: 1px solid #f5c6cb;
          }
          
          .mode-card.locked {
              opacity: 0.6;
              cursor: not-allowed;
          }
          
          .mode-card.locked:hover {
              transform: none;
              box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
          }
          
          @media (max-width: 768px) {
              .modes-grid {
                  grid-template-columns: 1fr;
                  gap: 1.5rem;
              }
              
              .mode-card {
                  padding: 1.5rem;
              }
          }
          </style>
          {% endblock %}
          
          {% block content %}
          <div class="selection-container">
              <!-- Back to Dashboard -->
              <a href="/dashboard" class="back-link">
                  <i class="fas fa-arrow-left me-2"></i>Back to Dashboard
              </a>
          
              <!-- Roleplay Header -->
              <div class="roleplay-header">
                  <h1>{{ roleplay_info.name }}</h1>
                  <p>{{ roleplay_info.description }}</p>
                  <p class="text-muted">Choose your training mode to get started</p>
              </div>
          
              <!-- Modes Grid -->
              <div class="modes-grid">
                  {% if main_roleplay_id == '1' %}
                      <!-- Practice Mode 1.1 -->
                      <div class="mode-card practice-mode" onclick="window.location.href='/roleplay/1.1'">
                          <div class="unlock-badge unlocked">Unlocked</div>
                          <div class="mode-icon practice">
                              <i class="fas fa-user-graduate"></i>
                          </div>
                          <div class="mode-title">Practice Mode</div>
                          <div class="mode-description">
                              Single call with detailed CEFR A2 coaching. Perfect for learning the fundamentals.
                          </div>
                          <ul class="mode-features">
                              <li>One-on-one roleplay session</li>
                              <li>Detailed performance feedback</li>
                              <li>Grammar and vocabulary coaching</li>
                              <li>Natural conversation flow</li>
                              <li>Pronunciation guidance</li>
                          </ul>
                          <a href="/roleplay/1.1" class="mode-button practice">
                              <i class="fas fa-play me-2"></i>Start Practice Mode
                          </a>
                      </div>
          
                      <!-- Marathon Mode 1.2 -->
                      <div class="mode-card marathon-mode" onclick="window.location.href='/roleplay/1.2'">
                          <div class="unlock-badge unlocked">Unlocked</div>
                          <div class="mode-icon marathon">
                              <i class="fas fa-running"></i>
                          </div>
                          <div class="mode-title">Marathon Mode</div>
                          <div class="mode-description">
                              10 consecutive calls - pass 6 to complete. Build stamina and consistency.
                          </div>
                          <ul class="mode-features">
                              <li>10 calls in succession</li>
                              <li>Need 6 successful calls to pass</li>
                              <li>Random hang-ups included</li>
                              <li>Builds conversation endurance</li>
                              <li>Aggregated performance report</li>
                          </ul>
                          <a href="/roleplay/1.2" class="mode-button marathon">
                              <i class="fas fa-fire me-2"></i>Start Marathon Mode
                          </a>
                      </div>
          
                      <!-- Legend Mode 1.3 -->
                      <div class="mode-card legend-mode" onclick="window.location.href='/roleplay/1.3'">
                          <div class="unlock-badge locked">Locked</div>
                          <div class="mode-icon legend">
                              <i class="fas fa-crown"></i>
                          </div>
                          <div class="mode-title">Legend Mode</div>
                          <div class="mode-description">
                              6 perfect calls in a row. The ultimate challenge for sales legends.
                          </div>
                          <ul class="mode-features">
                              <li>6 consecutive perfect calls</li>
                              <li>No mistakes allowed</li>
                              <li>Unlock after Marathon success</li>
                              <li>Ultimate bragging rights</li>
                              <li>Elite performance certification</li>
                          </ul>
                          <div class="mode-button legend" style="opacity: 0.5; cursor: not-allowed;">
                              <i class="fas fa-lock me-2"></i>Complete Marathon First
                          </div>
                      </div>
          
                  {% elif main_roleplay_id == '2' %}
                      <!-- Practice Mode 2.1 -->
                      <div class="mode-card practice-mode" onclick="window.location.href='/roleplay/2.1'">
                          <div class="unlock-badge locked">Locked</div>
                          <div class="mode-icon practice">
                              <i class="fas fa-user-graduate"></i>
                          </div>
                          <div class="mode-title">Practice Mode</div>
                          <div class="mode-description">
                              Master your pitch and handle advanced objections with detailed coaching.
                          </div>
                          <ul class="mode-features">
                              <li>Advanced pitch practice</li>
                              <li>Complex objection handling</li>
                              <li>Meeting closing techniques</li>
                              <li>Detailed performance feedback</li>
                              <li>Advanced conversation flows</li>
                          </ul>
                          <div class="mode-button practice" style="opacity: 0.5; cursor: not-allowed;">
                              <i class="fas fa-lock me-2"></i>Complete Roleplay 1 First
                          </div>
                      </div>
          
                      <!-- Marathon Mode 2.2 -->
                      <div class="mode-card marathon-mode" onclick="window.location.href='/roleplay/2.2'">
                          <div class="unlock-badge locked">Locked</div>
                          <div class="mode-icon marathon">
                              <i class="fas fa-running"></i>
                          </div>
                          <div class="mode-title">Marathon Mode</div>
                          <div class="mode-description">
                              10 advanced calls with complex scenarios. Master the full sales process.
                          </div>
                          <ul class="mode-features">
                              <li>10 advanced scenario calls</li>
                              <li>Complex objection patterns</li>
                              <li>Full sales cycle practice</li>
                              <li>Advanced closing techniques</li>
                              <li>Professional-level challenges</li>
                          </ul>
                          <div class="mode-button marathon" style="opacity: 0.5; cursor: not-allowed;">
                              <i class="fas fa-lock me-2"></i>Complete Roleplay 1 First
                          </div>
                      </div>
                  {% endif %}
              </div>
          
              <!-- Additional Info -->
              <div class="text-center text-muted">
                  <p><i class="fas fa-info-circle me-1"></i>
                      Not sure which mode to choose? Start with Practice Mode to learn the basics.
                  </p>
              </div>
          </div>
          {% endblock %}
          
          {% block extra_js %}
          <script>
          document.addEventListener('DOMContentLoaded', function() {
              console.log('Roleplay selection page loaded for:', '{{ main_roleplay_id }}');
              
              // Add click handlers for locked modes
              document.querySelectorAll('.mode-card.locked').forEach(card => {
                  card.addEventListener('click', function(e) {
                      e.preventDefault();
                      e.stopPropagation();
                      
                      alert('This mode is locked. Complete the previous requirements to unlock it.');
                  });
              });
          });
          </script>
          {% endblock %}

📁 utils/
  📄 constants.py (25.8KB)
      Content:
        # ===== UPDATED API/UTILS/CONSTANTS.PY (Add these to your existing file) =====
        
        # Job titles (alphabetically sorted)
        JOB_TITLES = [
            "Brand/Communications Manager",
            "CEO (Chief Executive Officer)", 
            "CFO (Chief Financial Officer)",
            "CIO (Chief Information Officer)",
            "COO (Chief Operating Officer)",
            "Content Marketing Manager",
            "CTO (Chief Technology Officer)",
            "Demand Generation Manager",
            "Digital Marketing Manager",
            "Engineering Manager",
            "Finance Director",
            "Founder / Owner / Managing Director (MD)",
            "Head of Product",
            "Purchasing Manager",
            "R&D/Product Development Manager",
            "Sales Manager",
            "Sales Operations Manager",
            "Social Media Manager",
            "UX/UI Design Lead",
            "VP of Finance",
            "VP of HR",
            "VP of IT/Engineering", 
            "VP of Marketing",
            "VP of Sales",
            "Other (Please specify)"
        ]
        
        # Industries
        INDUSTRIES = [
            "Education & e-Learning",
            "Energy & Utilities", 
            "Finance & Banking",
            "Government & Public Sector",
            "Healthcare & Life Sciences",
            "Hospitality & Travel",
            "Information Technology & Services",
            "Logistics, Transportation & Supply Chain",
            "Manufacturing & Industrial",
            "Media & Entertainment",
            "Non-Profit & Associations", 
            "Professional Services (Legal, Accounting, Consulting)",
            "Real Estate & Property Management",
            "Retail & e-Commerce",
            "Telecommunications",
            "Other (Please specify)"
        ]
        
        # Early objections (29 total) - used in Roleplay 1
        EARLY_OBJECTIONS = [
            "What's this about?",
            "I'm not interested",
            "We don't take cold calls", 
            "Now is not a good time",
            "I have a meeting",
            "Can you call me later?",
            "I'm about to go into a meeting",
            "Send me an email",
            "Can you send me the information?",
            "Can you message me on WhatsApp?",
            "Who gave you this number?",
            "This is my personal number",
            "Where did you get my number?",
            "What are you trying to sell me?",
            "Is this a sales call?",
            "Is this a cold call?",
            "Are you trying to sell me something?",
            "We are ok for the moment",
            "We are all good / all set",
            "We're not looking for anything right now",
            "We are not changing anything",
            "How long is this going to take?",
            "Is this going to take long?",
            "What company are you calling from?",
            "Who are you again?",
            "Where are you calling from?",
            "I never heard of you",
            "Not interested right now",
            "Just send me the details"
        ]
        
        # Post-pitch objections (24 total) - used in Roleplay 2
        POST_PITCH_OBJECTIONS = [
            "It's too expensive for us",
            "We have no budget for this right now",
            "Your competitor is cheaper",
            "Can you give us a discount?", 
            "This isn't a good time",
            "We've already set this year's budget",
            "Call me back next quarter",
            "We're busy with other projects right now",
            "We already use [competitor] and we're happy",
            "We built something similar ourselves",
            "How exactly are you better than [competitor]?",
            "Switching providers seems like a lot of work",
            "I've never heard of your company",
            "Who else like us have you worked with?",
            "Can you send customer testimonials?",
            "How do I know this will really work?",
            "I'm not the decision-maker",
            "I need approval from my team first",
            "Can you send details so I can forward them?",
            "We'll need buy-in from other departments",
            "How long does this take to implement?",
            "We don't have time to learn a new system",
            "I'm concerned this won't integrate with our existing tools",
            "What happens if this doesn't work as promised?"
        ]
        
        # AI pitch prompts (10 total) - used in Roleplay 2
        PITCH_PROMPTS = [
            "Alright, go ahead â€” what's this about?",
            "Soâ€¦ what are you calling me about?",
            "You've got 30 seconds. Impress me.",
            "I'm listening. What do you do?",
            "This better be good. What is it?",
            "Okay. Tell me why you're calling.",
            "Go on â€” what's the offer?",
            "Convince me.",
            "What's your pitch?",
            "Let's hear it."
        ]
        
        # Impatience phrases for silence handling
        IMPATIENCE_PHRASES = [
            "Hello? Are you still with me?",
            "Can you hear me?",
            "Just checking you're thereâ€¦",
            "Still on the line?",
            "I don't have much time for this.",
            "Sounds like you are gone.",
            "Are you an idiot.",
            "What is going on.",
            "Are you okay to continue?",
            "I am afraid I have to go"
        ]
        
        # Warm-up challenge questions (54 total) - used in Roleplay 3
        WARMUP_QUESTIONS = [
            # Opener questions (3)
            "Give your opener",
            "What's your pitch in one sentence?", 
            "Ask me for a meeting",
            
            # Early objection responses (29) 
            "What's this about?",
            "I'm not interested",
            "We don't take cold calls",
            "Now is not a good time", 
            "I have a meeting",
            "Can you call me later?",
            "I'm about to go into a meeting",
            "Send me an email",
            "Can you send me the information?",
            "Can you message me on WhatsApp?",
            "Who gave you this number?",
            "This is my personal number",
            "Where did you get my number?",
            "What are you trying to sell me?",
            "Is this a sales call?",
            "Is this a cold call?",
            "Are you trying to sell me something?",
            "We are ok for the moment",
            "We are all good / all set",
            "We're not looking for anything right now",
            "We are not changing anything",
            "How long is this going to take?",
            "Is this going to take long?",
            "What company are you calling from?",
            "Who are you again?",
            "Where are you calling from?",
            "I never heard of you",
            "Not interested right now",
            "Just send me the details",
            
            # Post-pitch objection responses (22 remaining to make 54 total)
            "It's too expensive for us",
            "We have no budget right now",
            "Your competitor is cheaper",
            "Can you give us a discount?",
            "This isn't a good time",
            "We've already set this year's budget",
            "Call me back next quarter",
            "We're busy with other projects right now",
            "We already use [competitor] and we're happy",
            "We built something similar ourselves",
            "How exactly are you better than [competitor]?",
            "Switching providers seems like a lot of work",
            "I've never heard of your company",
            "Who else like us have you worked with?",
            "Can you send customer testimonials?",
            "How do I know this will really work?",
            "I'm not the decision-maker",
            "I need approval from my team first",
            "Can you send details so I can forward them?",
            "We'll need buy-in from other departments",
            "How long does this take to implement?",
            "We don't have time to learn a new system"
        ]
        
        # ===== NEW: ROLEPLAY 1 DETAILED RUBRICS =====
        
        # Roleplay 1 specific rubrics - matches your specification exactly
        ROLEPLAY_1_RUBRICS = {
            "opener": {
                "name": "Opener Evaluation",
                "pass_requirement": 3,  # Need 3 out of 4 criteria
                "total_criteria": 4,
                "criteria": {
                    "clear_opener": {
                        "name": "Clear cold call opener",
                        "description": "Pattern interrupt, permission-based, or value-first approach",
                        "keywords": ["calling about", "calling from", "reason", "help with", "quick question", "wondered if"],
                        "negative_keywords": ["hi", "hello", "good morning", "how are you"]  # Just greeting alone
                    },
                    "casual_tone": {
                        "name": "Casual, confident tone",
                        "description": "Uses contractions and short phrases", 
                        "contractions": ["i'm", "don't", "can't", "won't", "we're", "you're", "it's", "that's"],
                        "formal_words": ["i am", "do not", "cannot", "will not", "we are", "you are"]  # Negative indicators
                    },
                    "shows_empathy": {
                        "name": "Demonstrates empathy", 
                        "description": "Acknowledges interruption, unfamiliarity, or randomness",
                        "empathy_phrases": [
                            "i know this is out of the blue",
                            "you don't know me", 
                            "this is a cold call",
                            "feel free to hang up",
                            "caught you off guard",
                            "i know this is unexpected",
                            "sorry to bother you",
                            "i know you're busy",
                            "interrupting your day",
                            "know i'm calling out of nowhere"
                        ]
                    },
                    "ends_with_question": {
                        "name": "Ends with soft question",
                        "description": "Soft invite or permission-seeking question",
                        "question_patterns": [
                            "can i tell you why i'm calling",
                            "would you be open to",
                            "does that make sense",
                            "fair enough",
                            "sound reasonable",
                            "quick question",
                            "minute to chat",
                            "okay if i"
                        ]
                    }
                },
                "auto_fail_conditions": [
                    "robotic or overly formal",
                    "pushy or too long", 
                    "no empathy demonstrated",
                    "no question or invite"
                ]
            },
            
            "objection_handling": {
                "name": "Objection Handling",
                "pass_requirement": 3,  # Need 3 out of 4 criteria
                "total_criteria": 4,
                "criteria": {
                    "acknowledges_calmly": {
                        "name": "Acknowledges calmly",
                        "description": "Calm acknowledgment without defensiveness",
                        "acknowledge_phrases": [
                            "fair enough", "totally get that", "i understand", "i hear you", 
                            "makes sense", "no problem", "i get it", "completely understand",
                            "appreciate that", "respect that", "of course"
                        ]
                    },
                    "no_arguing": {
                        "name": "Doesn't argue or pitch",
                        "description": "Avoids defensive responses or immediate pitching",
                        "negative_phrases": [
                            "but you", "actually", "well you should", "you're wrong", 
                            "let me tell you", "our solution", "we can help you",
                            "you need this", "everyone says that"
                        ]
                    },
                    "reframes_buys_time": {
                        "name": "Reframes or buys time in 1 sentence", 
                        "description": "Brief reframe without long explanation",
                        "reframe_phrases": [
                            "the reason i'm calling", "here's why", "that's exactly why",
                            "let me explain quickly", "one quick thing", "30 seconds",
                            "real quick", "briefly"
                        ]
                    },
                    "forward_question": {
                        "name": "Ends with forward-moving question",
                        "description": "Question that moves conversation forward",
                        "question_indicators": ["?", "can i", "would you", "could i", "is it worth", "make sense"]
                    }
                },
                "auto_fail_conditions": [
                    "gets defensive or pushy",
                    "ignores the objection",
                    "pitches immediately", 
                    "no forward-moving question"
                ]
            },
            
            "mini_pitch": {
                "name": "Mini Pitch",
                "pass_requirement": 3,  # Need 3 out of 4 criteria  
                "total_criteria": 4,
                "criteria": {
                    "short_concise": {
                        "name": "Short (1-2 sentences)",
                        "description": "Concise delivery under 30 words",
                        "max_words": 30,
                        "max_sentences": 2
                    },
                    "outcome_focused": {
                        "name": "Focuses on problem solved or outcome",
                        "description": "Benefits and outcomes, not features",
                        "outcome_words": [
                            "save", "increase", "reduce", "improve", "help", "solve", "fix",
                            "eliminate", "boost", "grow", "achieve", "get", "avoid"
                        ],
                        "feature_words": [
                            "platform", "software", "tool", "system", "technology", "solution",
                            "features", "capabilities", "functions"
                        ]
                    },
                    "simple_language": {
                        "name": "Simple English, no jargon",
                        "description": "Clear, accessible language",
                        "jargon_words": [
                            "leverage", "synergies", "paradigm", "scalable", "robust", 
                            "enterprise-grade", "cutting-edge", "revolutionary", "disruptive",
                            "best-in-class", "world-class", "next-generation"
                        ]
                    },
                    "natural_delivery": {
                        "name": "Sounds natural, not robotic",
                        "description": "Conversational tone with contractions",
                        "natural_indicators": ["we help", "i work with", "basically", "simply put"],
                        "robotic_indicators": ["our solution provides", "we offer", "our platform enables"]
                    }
                },
                "auto_fail_conditions": [
                    "too long or detailed",
                    "focuses on features instead of outcomes",
                    "uses jargon or buzzwords",
                    "sounds scripted or robotic"
                ]
            },
            
            "soft_discovery": {
                "name": "Soft Discovery",
                "pass_requirement": 2,  # Need 2 out of 3 criteria
                "total_criteria": 3,
                "criteria": {
                    "tied_question": {
                        "name": "Short question tied to the pitch",
                        "description": "Question connects to what was just pitched",
                        "connection_words": ["how are you", "what's your", "how do you", "where are you"]
                    },
                    "open_curious": {
                        "name": "Open/curious question",
                        "description": "Open-ended, not leading",
                        "open_patterns": ["how", "what", "where", "when", "why", "tell me about"],
                        "closed_patterns": ["do you", "are you", "is it", "can you"]  # Leading questions
                    },
                    "soft_tone": {
                        "name": "Soft and non-pushy tone", 
                        "description": "Gentle, curious approach",
                        "soft_indicators": ["curious", "wondering", "just wondering", "mind if i ask"],
                        "pushy_indicators": ["you need to", "you should", "everyone", "all companies"]
                    }
                },
                "auto_fail_conditions": [
                    "no question asked",
                    "too broad or generic question",
                    "sounds scripted or pushy"
                ]
            }
        }
        
        # Hang-up probability matrix for Roleplay 1
        ROLEPLAY_1_HANGUP_RULES = {
            "opener_stage": {
                "score_0_1": 0.8,   # 80% chance if terrible opener (0-1 criteria)
                "score_2": 0.3,     # 30% chance if poor opener (2 criteria) 
                "score_3_4": 0.1    # 10% chance if good opener (3-4 criteria)
            },
            "random_opener": 0.25,  # 25% baseline random hang-up chance
            "objection_stage": 0.05,  # 5% chance during objection handling
            "pitch_stage": 0.02       # 2% chance during pitch
        }
        
        # Silence handling for Roleplay 1 - matches your 10s/15s specification
        ROLEPLAY_1_SILENCE_RULES = {
            "impatience_trigger_seconds": 10,
            "hangup_trigger_seconds": 15,
            "impatience_phrases": [
                "Hello? Are you still with me?",
                "Can you hear me?", 
                "Just checking you're thereâ€¦",
                "Still on the line?",
                "I don't have much time for this.",
                "Sounds like you are gone.",
                "Are you an idiot.",
                "What is going on.",
                "Are you okay to continue?",
                "I am afraid I have to go"
            ]
        }
        
        # ===== EXISTING CONSTANTS (Updated) =====
        
        # Roleplay configuration
        ROLEPLAY_CONFIG = {
            1: {
                "name": "Opener + Early Objections",
                "description": "Practice call opening, handling early objections, and delivering mini-pitch",
                "unlock_condition": "Always available",
                "modes": ["practice", "marathon", "legend"],
                "unlock_target": 2,  # Unlocks roleplay 2
                "marathon_threshold": 6,  # Need 6/10 to pass
                "legend_threshold": 6,  # Need 6/6 to pass
                "includes_hang_ups": True,
                "hang_up_chance": "dynamic",  # Now uses dynamic calculation based on rubrics
                "uses_detailed_rubrics": True,  # New flag
                "silence_rules": "ROLEPLAY_1_SILENCE_RULES",  # Reference to silence rules
                "evaluation_system": "rubric_based"  # New evaluation type
            },
            2: {
                "name": "Pitch + Objections + Close", 
                "description": "Practice post-pitch conversation, objection handling, and meeting closing",
                "unlock_condition": "Complete Marathon 1 (6/10 calls)",
                "modes": ["practice", "marathon", "legend"],
                "unlock_target": 3,  # Unlocks roleplay 3
                "marathon_threshold": 6,
                "legend_threshold": 6,
                "includes_hang_ups": False,
                "requires_qualification": True,  # Must get company-fit admission
                "requires_meeting_ask": True     # Must ask for meeting with time slot
            },
            3: {
                "name": "Warm-up Challenge",
                "description": "25 random questions from master list (18/25 to pass)",
                "unlock_condition": "Complete Marathon 2 (6/10 calls)",
                "modes": ["challenge"],  # No marathon/legend mode
                "unlock_target": 4,
                "pass_threshold": 18,  # Need 18/25 correct
                "total_questions": 25,
                "time_limit_seconds": 5,  # >5 seconds = "too slow" warning
                "skip_allowed": True
            },
            4: {
                "name": "Full Cold Call Simulation",
                "description": "Complete call flow: opener â†’ objection â†’ pitch â†’ objections â†’ meeting ask",
                "unlock_condition": "Pass Warm-up Challenge (18/25)", 
                "modes": ["simulation"],  # No marathon/legend mode
                "unlock_target": 5,
                "success_criteria": "Successfully book a meeting",
                "includes_hang_ups": True,
                "hang_up_chance": 0.25,
                "requires_all_stages": True
            },
            5: {
                "name": "Power Hour Challenge",
                "description": "10 consecutive full cold calls - book as many meetings as possible",
                "unlock_condition": "Complete Full Cold Call Simulation",
                "modes": ["power_hour"],
                "unlock_target": None,  # Final roleplay
                "total_calls": 10,
                "success_metric": "meetings_booked",  # Track booking rate
                "no_pass_fail": True  # Focus on performance metrics
            }
        }
        
        # Pass criteria for different elements
        PASS_CRITERIA = {
            "opener": {
                "required_count": 3,
                "total_criteria": 4,
                "criteria": [
                    "Clear cold call opener (pattern interrupt, permission-based, or value-first)",
                    "Casual, confident tone (contractions, short phrases)", 
                    "Demonstrates empathy ('I know this is out of the blue...', 'You don't know me...')",
                    "Ends with soft question ('Can I tell you why I'm calling?')"
                ]
            },
            "objection_handling": {
                "required_count": 3,
                "total_criteria": 4,
                "criteria": [
                    "Acknowledges calmly ('Fair enough', 'Totally get that')",
                    "Doesn't argue or pitch immediately",
                    "Reframes or buys time in 1 sentence",
                    "Ends with forward-moving question"

  📄 decorators.py (3.7KB)
      Content:
        # ===== API/UTILS/DECORATORS.PY =====
        from functools import wraps
        from flask import session, request, jsonify, redirect, url_for
        import logging
        from typing import List
        
        logger = logging.getLogger(__name__)
        
        def require_auth(f):
            """Decorator to require authentication"""
            @wraps(f)
            def decorated_function(*args, **kwargs):
                # Check if user is logged in
                if 'user_id' not in session:
                    # For API requests, return JSON error
                    if request.path.startswith('/api/'):
                        return jsonify({'error': 'Authentication required'}), 401
                    # For page requests, redirect to login
                    return redirect(url_for('login_page'))
                
                return f(*args, **kwargs)
            return decorated_function
        
        def check_usage_limits(f):
            """Decorator to check user usage limits"""
            @wraps(f)
            def decorated_function(*args, **kwargs):
                try:
                    from services.supabase_client import SupabaseService
                    from utils.helpers import calculate_usage_limits
                    
                    user_id = session.get('user_id')
                    if not user_id:
                        return jsonify({'error': 'Authentication required'}), 401
                    
                    supabase_service = SupabaseService()
                    profile = supabase_service.get_user_profile_by_service(user_id)
                    
                    if not profile:
                        return jsonify({'error': 'User profile not found'}), 404
                    
                    # Calculate usage limits
                    usage_info = calculate_usage_limits(profile)
                    
                    # Check if user has exceeded limits
                    if usage_info['remaining_minutes'] <= 0:
                        return jsonify({
                            'error': 'Usage limit exceeded',
                            'limit_type': usage_info['limit_type'],
                            'upgrade_required': True
                        }), 403
                    
                    return f(*args, **kwargs)
                    
                except Exception as e:
                    logger.error(f"Error checking usage limits: {e}")
                    return f(*args, **kwargs)  # Continue if check fails
            
            return decorated_function
        
        def validate_json_input(required_fields: List[str] = None):
            """Decorator to validate JSON input"""
            def decorator(f):
                @wraps(f)
                def decorated_function(*args, **kwargs):
                    if not request.is_json:
                        return jsonify({'error': 'Content-Type must be application/json'}), 400
                    
                    data = request.get_json()
                    if not data:
                        return jsonify({'error': 'No JSON data provided'}), 400
                    
                    if required_fields:
                        missing_fields = [field for field in required_fields if field not in data]
                        if missing_fields:
                            return jsonify({
                                'error': f'Missing required fields: {", ".join(missing_fields)}'
                            }), 400
                    
                    return f(*args, **kwargs)
                return decorated_function
            return decorator
        
        def log_api_call(f):
            """Decorator to log API calls"""
            @wraps(f)
            def decorated_function(*args, **kwargs):
                user_id = session.get('user_id', 'anonymous')
                logger.info(f"API call: {request.method} {request.path} - User: {user_id}")
                
                try:
                    result = f(*args, **kwargs)
                    logger.info(f"API call completed: {request.method} {request.path} - User: {user_id}")
                    return result
                except Exception as e:
                    logger.error(f"API call failed: {request.method} {request.path} - User: {user_id} - Error: {e}")
                    raise
            
            return decorated_function

  📄 helpers.py (21.4KB)
      Content:
        
        # ===== API/UTILS/HELPERS.PY =====
        import re
        import logging
        from datetime import datetime, timezone, timedelta
        from typing import Dict, List, Any, Optional, Union
        import hashlib
        import secrets
        import json
        
        logger = logging.getLogger(__name__)
        
        def validate_email(email: str) -> bool:
            """Validate email format"""
            pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            return bool(re.match(pattern, email))
        
        def validate_password(password: str) -> Dict[str, Any]:
            """
            Validate password strength
            Returns dict with 'valid' boolean and 'errors' list
            """
            errors = []
            
            if not password:
                errors.append("Password is required")
                return {'valid': False, 'errors': errors}
            
            if len(password) < 6:
                errors.append("Password must be at least 6 characters long")
            
            if len(password) > 128:
                errors.append("Password must be less than 128 characters")
            
            # Check for common weak passwords
            weak_passwords = ['password', '123456', 'qwerty', 'abc123', 'password123']
            if password.lower() in weak_passwords:
                errors.append("Password is too common")
            
            return {
                'valid': len(errors) == 0,
                'errors': errors
            }
        
        def sanitize_input(text: str, max_length: int = 1000) -> str:
            """Sanitize user input text"""
            if not text:
                return ""
            
            # Remove control characters except newlines and tabs
            text = re.sub(r'[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]', '', text)
            
            # Limit length
            if len(text) > max_length:
                text = text[:max_length]
            
            # Strip whitespace
            return text.strip()
        
        def generate_session_id(user_id: str, roleplay_id: int) -> str:
            """Generate unique session ID"""
            timestamp = datetime.now().timestamp()
            data = f"{user_id}_{roleplay_id}_{timestamp}_{secrets.token_hex(8)}"
            return hashlib.sha256(data.encode()).hexdigest()[:16]
        
        def calculate_usage_limits(profile: Dict[str, Any]) -> Dict[str, Any]:
            """Calculate user's usage limits and remaining time"""
            access_level = profile.get('access_level', 'limited_trial')
            monthly_usage = profile.get('monthly_usage_minutes', 0) or 0
            lifetime_usage = profile.get('lifetime_usage_minutes', 0) or 0
            
            result = {
                'access_level': access_level,
                'monthly_usage_minutes': monthly_usage,
                'lifetime_usage_minutes': lifetime_usage
            }
            
            if access_level == 'limited_trial':
                # 3 hours lifetime limit or 7 days from signup
                trial_limit_minutes = 180  # 3 hours
                remaining_minutes = max(0, trial_limit_minutes - lifetime_usage)
                
                # Check days remaining
                signup_date_str = profile.get('trial_signup_date') or profile.get('created_at')
                if signup_date_str:
                    try:
                        signup_date = parse_iso_datetime(signup_date_str)
                        current_time = datetime.now(timezone.utc)
                        days_since_signup = (current_time - signup_date).days
                        days_remaining = max(0, 7 - days_since_signup)
                    except:
                        days_remaining = 7  # Default if can't parse
                else:
                    days_remaining = 7
                
                result.update({
                    'trial_minutes_remaining': remaining_minutes,
                    'trial_days_remaining': days_remaining,
                    'usage_percentage': round((lifetime_usage / trial_limit_minutes) * 100, 1) if trial_limit_minutes > 0 else 0,
                    'is_expired': remaining_minutes == 0 or days_remaining == 0,
                    'limit_type': 'trial'
                })
            
            else:  # Basic or Pro
                # 50 hours monthly limit
                monthly_limit_minutes = 3000  # 50 hours
                remaining_minutes = max(0, monthly_limit_minutes - monthly_usage)
                
                result.update({
                    'monthly_minutes_remaining': remaining_minutes,
                    'monthly_limit_minutes': monthly_limit_minutes,
                    'usage_percentage': round((monthly_usage / monthly_limit_minutes) * 100, 1) if monthly_limit_minutes > 0 else 0,
                    'is_expired': remaining_minutes == 0,
                    'limit_type': 'monthly'
                })
            
            return result
        
        def parse_iso_datetime(date_string: str) -> datetime:
            """Parse ISO datetime string with timezone handling"""
            if not date_string:
                return datetime.now(timezone.utc)
            
            try:
                # Handle various datetime formats
                if 'T' in date_string:
                    if date_string.endswith('Z'):
                        return datetime.fromisoformat(date_string.replace('Z', '+00:00'))
                    elif '+' in date_string or date_string.endswith('00'):
                        return datetime.fromisoformat(date_string)
                    else:
                        return datetime.fromisoformat(date_string + '+00:00')
                else:
                    # Legacy format
                    return datetime.strptime(date_string, '%Y-%m-%d %H:%M:%S').replace(tzinfo=timezone.utc)
            except (ValueError, TypeError) as e:
                logger.warning(f"Could not parse datetime {date_string}: {e}")
                return datetime.now(timezone.utc)
        
        def format_duration(minutes: int) -> str:
            """Format duration in minutes to human readable string"""
            if minutes < 60:
                return f"{minutes}m"
            
            hours = minutes // 60
            remaining_minutes = minutes % 60
            
            if remaining_minutes == 0:
                return f"{hours}h"
            else:
                return f"{hours}h {remaining_minutes}m"
        
        def calculate_success_rate(sessions: List[Dict]) -> float:
            """Calculate success rate from sessions list"""
            if not sessions:
                return 0.0
            
            successful = sum(1 for s in sessions if s.get('success') is True)
            return round((successful / len(sessions)) * 100, 1)
        
        def get_time_periods() -> Dict[str, datetime]:
            """Get common time periods for analytics"""
            now = datetime.now(timezone.utc)
            return {
                'now': now,
                'hour_ago': now - timedelta(hours=1),
                'day_ago': now - timedelta(days=1),
                'week_ago': now - timedelta(days=7),
                'month_ago': now - timedelta(days=30),
                'year_ago': now - timedelta(days=365)
            }
        
        def safe_json_loads(json_string: str, default: Any = None) -> Any:
            """Safely parse JSON string with fallback"""
            try:
                return json.loads(json_string) if json_string else default
            except (json.JSONDecodeError, TypeError):
                return default
        
        def safe_json_dumps(data: Any, default: str = "{}") -> str:
            """Safely convert data to JSON string"""
            try:
                return json.dumps(data) if data is not None else default
            except (TypeError, ValueError):
                return default
        
        def mask_email(email: str) -> str:
            """Mask email for privacy (e.g., user@domain.com -> u***@domain.com)"""
            if not email or '@' not in email:
                return email
            
            local, domain = email.split('@', 1)
            if len(local) <= 1:
                return email
            
            masked_local = local[0] + '*' * (len(local) - 1)
            return f"{masked_local}@{domain}"
        
        def generate_prospect_name(job_title: str, industry: str) -> str:
            """Generate realistic prospect name based on role"""
            first_names = {
                'executive': ['Alex', 'Jordan', 'Taylor', 'Casey', 'Morgan', 'Riley'],
                'technical': ['Sam', 'Blake', 'Quinn', 'Avery', 'Sage', 'Cameron'],
                'manager': ['Jamie', 'Drew', 'Peyton', 'Skyler', 'Emery', 'Parker'],
                'sales': ['Dakota', 'Reese', 'Phoenix', 'River', 'Scout', 'Finley']
            }
            
            last_names = ['Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Garcia', 
                          'Miller', 'Davis', 'Rodriguez', 'Martinez', 'Hernandez', 'Lopez']
            
            # Determine name category based on job title
            title_lower = job_title.lower()
            if any(word in title_lower for word in ['ceo', 'cto', 'cfo', 'president', 'founder']):
                category = 'executive'
            elif any(word in title_lower for word in ['engineer', 'technical', 'developer', 'architect']):
                category = 'technical'
            elif any(word in title_lower for word in ['sales', 'business', 'account']):
                category = 'sales'
            else:
                category = 'manager'
            
            first_name = secrets.choice(first_names[category])
            last_name = secrets.choice(last_names)
            
            return f"{first_name} {last_name}"
        
        def get_avatar_path(job_title: str, gender_preference: str = 'neutral') -> str:
            """Get appropriate avatar image path"""
            title_lower = job_title.lower()
            
            if any(word in title_lower for word in ['ceo', 'president', 'founder']):
                return '/static/images/prospect-avatars/executive.jpg'
            elif any(word in title_lower for word in ['engineer', 'technical', 'developer']):
                return '/static/images/prospect-avatars/technical.jpg'
            elif any(word in title_lower for word in ['manager', 'director']):
                return '/static/images/prospect-avatars/manager.jpg'
            else:
                return '/static/images/prospect-avatars/default.jpg'
        
        def log_user_action(user_id: str, action: str, details: Dict = None):
            """Log user action for analytics"""
            try:
                log_entry = {
                    'user_id': user_id,
                    'action': action,
                    'timestamp': datetime.now(timezone.utc).isoformat(),
                    'details': details or {}
                }
                logger.info(f"User action: {json.dumps(log_entry)}")
            except Exception as e:
                logger.error(f"Failed to log user action: {e}")
        
        # ===== API/UTILS/DECORATORS.PY (ENHANCED) =====
        from functools import wraps
        from flask import session, request, jsonify, redirect, url_for
        from services.supabase_client import SupabaseService
        import os
        
        def require_auth(f):
            """Decorator to require authentication"""
            @wraps(f)
            def decorated_function(*args, **kwargs):
                # Check session
                if 'user_id' not in session:
                    if request.is_json:
                        return jsonify({'error': 'Authentication required'}), 401
                    else:
                        return redirect(url_for('login_page'))
                
                # Verify token if provided
                access_token = request.headers.get('Authorization', '').replace('Bearer ', '')
                if not access_token:
                    access_token = session.get('access_token')
                
                if access_token:
                    supabase_service = SupabaseService()
                    user = supabase_service.authenticate_user(access_token)
                    if not user:
                        session.clear()
                        if request.is_json:
                            return jsonify({'error': 'Invalid or expired token'}), 401
                        else:
                            return redirect(url_for('login_page'))
                
                return f(*args, **kwargs)
            return decorated_function
        
        def require_admin(f):
            """Decorator to require admin privileges"""
            @wraps(f)
            def decorated_function(*args, **kwargs):
                # First check authentication
                if 'user_id' not in session:
                    logger.warning("Admin access denied: No user_id in session")
                    if request.is_json:
                        return jsonify({'error': 'Authentication required'}), 401
                    else:
                        return redirect(url_for('login_page'))
                
                # Get user profile to check admin status
                try:
                    supabase_service = SupabaseService()
                    profile = supabase_service.get_user_profile_by_service(session['user_id'])
                    
                    if not profile:
                        logger.warning(f"Admin access denied: Profile not found for user {session['user_id']}")
                        return jsonify({'error': 'User profile not found'}), 404
                    
                    logger.info(f"Checking admin access for user {session['user_id']}")
                    logger.info(f"User access_level: {profile.get('access_level')}")
                    
                    # Check access_level first (if you've updated schema)
                    if profile.get('access_level') == 'admin':
                        logger.info("Admin access granted via access_level")
                        return f(*args, **kwargs)
                    
                    # Fallback: Check if user is admin via environment variable
                    admin_email = os.getenv('REACT_APP_ADMIN_EMAIL')
                    logger.info(f"Admin email from env: {admin_email}")
                    
                    if admin_email:
                        try:
                            access_token = session.get('access_token')
                            if access_token:
                                user = supabase_service.authenticate_user(access_token)
                                if user:
                                    # Handle different user object formats
                                    user_email = None
                                    
                                    # Try different ways to get email
                                    if hasattr(user, 'email'):
                                        user_email = user.email
                                    elif isinstance(user, dict) and 'email' in user:
                                        user_email = user['email']
                                    elif hasattr(user, 'user') and hasattr(user.user, 'email'):
                                        user_email = user.user.email
                                    elif isinstance(user, dict) and 'user' in user and isinstance(user['user'], dict):
                                        user_email = user['user'].get('email')
                                    
                                    logger.info(f"User email extracted: {user_email}")
                                    logger.info(f"Comparing with admin email: {admin_email}")
                                    
                                    if user_email and user_email.lower().strip() == admin_email.lower().strip():
                                        logger.info("Admin access granted via email match")
                                        return f(*args, **kwargs)
                                    else:
                                        logger.warning(f"Email mismatch: '{user_email}' != '{admin_email}'")
                                else:
                                    logger.warning("Failed to authenticate user with token")
                            else:
                                logger.warning("No access token found in session")
                        except Exception as e:
                            logger.error(f"Error getting user email: {e}")
                    else:
                        logger.warning("No REACT_APP_ADMIN_EMAIL environment variable set")
                    
                    logger.warning(f"Admin access denied for user {session['user_id']}")
                    return jsonify({'error': 'Admin privileges required'}), 403
                    
                except Exception as e:
                    logger.error(f"Error checking admin privileges: {e}")
                    return jsonify({'error': 'Internal server error'}), 500
            
            return decorated_function
        
        def require_access_level(min_level: str):
            """Decorator to require minimum access level"""
            def decorator(f):
                @wraps(f)
                def decorated_function(*args, **kwargs):
                    if 'user_id' not in session:
                        if request.is_json:
                            return jsonify({'error': 'Authentication required'}), 401
                        else:
                            return redirect(url_for('login_page'))
                    
                    try:
                        supabase_service = SupabaseService()
                        profile = supabase_service.get_user_profile_by_service(session['user_id'])
                        
                        if not profile:
                            return jsonify({'error': 'User profile not found'}), 404
                        
                        user_level = profile.get('access_level', 'limited_trial')
                        
                        # Define access level hierarchy
                        level_hierarchy = {
                            'limited_trial': 1,
                            'unlimited_basic': 2,
                            'unlimited_pro': 3,
                            'admin': 4
                        }
                        
                        user_level_num = level_hierarchy.get(user_level, 0)
                        required_level_num = level_hierarchy.get(min_level, 0)
                        
                        if user_level_num >= required_level_num:
                            return f(*args, **kwargs)
                        else:
                            return jsonify({'error': f'Access level {min_level} required'}), 403
                            
                    except Exception as e:
                        logger.error(f"Error checking access level: {e}")
                        return jsonify({'error': 'Internal server error'}), 500
                
                return decorated_function
            return decorator
        
        def check_usage_limits(f):
            """Decorator to check if user has exceeded usage limits"""
            @wraps(f)
            def decorated_function(*args, **kwargs):
                if 'user_id' not in session:
                    return jsonify({'error': 'Authentication required'}), 401
                
                try:
                    supabase_service = SupabaseService()
                    profile = supabase_service.get_user_profile_by_service(session['user_id'])
                    
                    if not profile:
                        return jsonify({'error': 'User profile not found'}), 404
                    
                    # Calculate usage limits
                    usage_info = calculate_usage_limits(profile)
                    
                    if usage_info.get('is_expired'):
                        return jsonify({
                            'error': 'Usage limit exceeded',
                            'usage_info': usage_info
                        }), 403
                    
                    # Add usage info to request context for the view
                    request.usage_info = usage_info
                    
                    return f(*args, **kwargs)
                    
                except Exception as e:
                    logger.error(f"Error checking usage limits: {e}")
                    return jsonify({'error': 'Internal server error'}), 500
            
            return decorated_function
        
        def log_api_call(f):
            """Decorator to log API calls for analytics"""
            @wraps(f)
            def decorated_function(*args, **kwargs):
                start_time = datetime.now()
                user_id = session.get('user_id', 'anonymous')
                
                try:
                    result = f(*args, **kwargs)
                    
                    # Log successful call
                    duration = (datetime.now() - start_time).total_seconds()
                    log_user_action(user_id, f'api_call_{f.__name__}', {
                        'endpoint': request.endpoint,
                        'method': request.method,
                        'duration_seconds': duration,
                        'status': 'success'
                    })
                    
                    return result
                    
                except Exception as e:
                    # Log failed call
                    duration = (datetime.now() - start_time).total_seconds()
                    log_user_action(user_id, f'api_call_{f.__name__}', {
                        'endpoint': request.endpoint,
                        'method': request.method,
                        'duration_seconds': duration,
                        'status': 'error',
                        'error': str(e)
                    })
                    
                    raise e  # Re-raise the exception
            
            return decorated_function
        
        def validate_json_input(required_fields: List[str] = None, optional_fields: List[str] = None):
            """Decorator to validate JSON input"""
            def decorator(f):
                @wraps(f)
                def decorated_function(*args, **kwargs):
                    if not request.is_json:
                        return jsonify({'error': 'Content-Type must be application/json'}), 400
                    
                    data = request.get_json()
                    if not data:
                        return jsonify({'error': 'Invalid JSON data'}), 400
                    
                    # Check required fields
                    if required_fields:
                        missing_fields = [field for field in required_fields if field not in data]
                        if missing_fields:
                            return jsonify({
                                'error': f'Missing required fields: {", ".join(missing_fields)}'
                            }), 400
                    
                    # Sanitize inputs
                    all_fields = (required_fields or []) + (optional_fields or [])
                    for field in all_fields:

  📄 __init__.py (0KB)
      (Empty file)

